[{"content":"개발환경 및 기본 지식 구성 파일들 analysis_options.yaml : flutter rule을 설정하는 파일 assets : 이미지 등 리소스들을 저장하는 경로 lib/main.dart : 메인 App 소스가 구동되는 dart 파일 pubspec.yaml : 리소스 경로 및 API들을 설정할 수 있는 파일 (assets 폴더 설정 가능)\n# 경로 설정\rflutter:\rassets:\r- assets/\r# dependency 설정\rdependencies:\rflutter:\rsdk: flutter\rcupertino_icons: ^1.0.2\randroid/app/src/main/AndroidManifext.xml : 안드로이드 앱 개발시 권한 부여를 위한 파일\n빌드 및 실행 main.dart 파일을 지정하고 실행시켜야 한다. 이때, dart 빌드가 아닌 flutter 빌드를 해준다.\n문법 길이 단위 (LP) 길이 단위는 LP로 사용된다. 100LP는 약 2.4cm\nWidget xml의 tag와 유사하게 정의된 형태의 class widget은 대문자로 시작한다. 참조 : (flutter widget library)[https://api.flutter.dev/flutter/material/material-library.html]\nMaterialApp() Scaffold() Row() Column() Text() Icon Container() SizedBox() Center() ","permalink":"https://AswinBlue.github.io/post/flutter/","summary":"개발환경 및 기본 지식 구성 파일들 analysis_options.yaml : flutter rule을 설정하는 파일 assets : 이미지 등 리소스들을 저장하는 경로 lib/main.dart : 메인 App 소스가 구동되는 dart 파일 pubspec.yaml : 리소스 경로 및 API들을 설정할 수 있는 파일 (assets 폴더 설정 가능)\n# 경로 설정\rflutter:\rassets:\r- assets/\r# dependency 설정\rdependencies:\rflutter:\rsdk: flutter\rcupertino_icons: ^1.0.2\randroid/app/src/main/AndroidManifext.xml : 안드로이드 앱 개발시 권한 부여를 위한 파일\n빌드 및 실행 main.dart 파일을 지정하고 실행시켜야 한다.","title":"Flutter"},{"content":"CPU Segment 프로세스가 사용하는 메모리를 Segment라 칭하며, 리눅스에서는 5가지 종류로 이를 분류한다.\n코드 세그먼트 : 실행 가능한 코드가 위치한 영역으로, text segment라고도 부른다. 데이터 세그먼트 : 코드 실행에 필요한 데이터가 있는 영역으로, 전역변수 및 전역 상수들이 위치한다. 쓰기가 가능한 데이터들과 읽기만 가능한 상수 데이터들은 각각 data segment와 rodata(read-only) segment 에 저장된다. BSS 세그먼트 : Block Started by Symbol 의 약자로, 컴파일시점에 값이 정해지지 않은 전역변수가 저장되는 영역이다. 이 영역은 프로그램 시작시 모두 0으로 초기화 된다. C에서 전역변수가 0 으로 초기화되는 이유가 이 때문이다. 힙 세그먼트 : 동적으로 할당되는 데이터들을 저장하는 영역이다. 스택과 마주보는 방향으로 증가한다. 스택 세그먼트 : 프로세스의 스택이 위치하는 영역으로, 지역변수 및 함수 인자들이 저장된다. 스택 세그먼트는 메모리 마지막 주소(가장 큰 주소)부터 시작해서 힙과 마주보는 방향으로 증가한다. 운영체제가 프로세스 동작 상황에 따라 스택 영역을 관리한다. 세그먼트는 위에서 언급된 순서대로 메모리에 배치되며, 스택 세그먼트만 특이하게 메모리 가장 마지막을 기준으로 할당된다.\nISA Instruction Set Architecture 의 약자로, 명령어 집합 구조라 해석한다.\nx86-64, ARM, MIPS, AVR 등이 대표적인 예시이다.\n컴퓨터 구조는 \u0026lsquo;기능구조\u0026rsquo; \u0026lsquo;ISA\u0026rsquo; \u0026lsquo;마이크로 아키텍처\u0026rsquo; \u0026lsquo;하드웨어 및 컴퓨팅 방법론\u0026rsquo; 과 같이 레벨에 따라 분류가 가능하다.\nx86-64 아키텍처 레지스터 x86-64 아키텍처는 아래와 같이 레지스터를 용도에 따라 구분한다.\n범용 레지스터(General Register) : 8byte를 저장 가능 아래 용도로 주로 사용되지만 그외 용도로도 다양하게 사용 가능한 레지스터. rax (accumulator register) : 함수의 반환 값 rbx (base register) : x64에서는 주된 용도 없음 rcx (counter register) : 반복문의 반복 횟수, 각종 연산의 시행 횟수 rdx (data register) : x64에서는 주된 용도 없음 rsi (source index) : 데이터를 옮길 때 원본을 가리키는 포인터 rdi (destination index) : 데이터를 옮길 때 목적지를 가리키는 포인터 rsp (stack pointer) : 사용중인 스택의 위치를 가리키는 포인터 rbp (stack base pointer) : 스택의 바닥을 가리키는 포인터 세그먼트 레지스터(Segment Register) : 16bit를 저장 가능 과거에는 사용 가능한 물리 메모리의 크기를 늘리기 위해 사용했으나, x64 아키텍처에서는 주소영역이 확장되면서 주로 메모리 보호를 위해 사용 cs, ss, ds, es, fs, gs 종류가 존재 cs, ds, ss 레지스터는 코드 영역과 데이터, 스택 메모리 영역을 가리킬 때 사용 명령어 포인터 레지스터(Instruction Pointer Register, IP) : 8byte 크기 CPU가 실행할 코드 위치를 가리키는 역할 종류로는 rip 가 있다. 플래그 레지스터(Flag Register) : 64bit 프로세서의 현재 상태를 저장하고 있는 레지스터 64비트로 CPU의 현재 상태를 표시한다. 주로 우측 20개를 사용 CF(Carry Flag) : 부호 없는 수의 연산 결과가 비트의 범위를 넘을 경우 설정 됩니다. ZF(Zero Flag) : 연산의 결과가 0일 경우 설정 됩니다. SF(Sign Flag) : 연산의 결과가 음수일 경우 설정 됩니다. OF(Overflow Flag) : 부호 있는 수의 연산 결과가 비트 범위를 넘을 경우 설정 됩니다. CPU의 레지스터들은 32비트 크기를 가지며, eax, ebx, ecx, edx, esi, edi, esp, ebp 가 있다.\n","permalink":"https://AswinBlue.github.io/post/computer_science/","summary":"CPU Segment 프로세스가 사용하는 메모리를 Segment라 칭하며, 리눅스에서는 5가지 종류로 이를 분류한다.\n코드 세그먼트 : 실행 가능한 코드가 위치한 영역으로, text segment라고도 부른다. 데이터 세그먼트 : 코드 실행에 필요한 데이터가 있는 영역으로, 전역변수 및 전역 상수들이 위치한다. 쓰기가 가능한 데이터들과 읽기만 가능한 상수 데이터들은 각각 data segment와 rodata(read-only) segment 에 저장된다. BSS 세그먼트 : Block Started by Symbol 의 약자로, 컴파일시점에 값이 정해지지 않은 전역변수가 저장되는 영역이다. 이 영역은 프로그램 시작시 모두 0으로 초기화 된다.","title":"Computer_science"},{"content":"Thymeleaf 서버에서 view를 구성할 때 사용하는 라이브러리 태그 형식의 문법을 사용하며 vue와 유사하다. 기본 문법 thymeleaf 공식 튜토리얼 에서 기본적인 문법을 확인할 수 있다. 태그 안에 th:속성=\u0026quot;값\u0026quot; 형태의 속성을 추가하는 형태로 사용한다. text \u0026lt;span th:text=\u0026quot;${text}\u0026quot;\u0026gt;default text\u0026lt;/span\u0026gt;: 서버에서 \u0026rsquo;text\u0026rsquo;라는 이름으로 정의한 태그가 있으면 text를 표시한다. text변수가 없으면 \u0026lt;span\u0026gt;default text\u0026lt;/span\u0026gt;를 표시한다. utext \u0026lt;span th:utext=\u0026quot;${utext}\u0026quot;\u0026gt;default text\u0026lt;/span\u0026gt;: \u0026rsquo;text\u0026rsquo; 이름으로 정의한 텍스트를 \u0026lsquo;span\u0026rsquo; 태그에 넣어 표시한다. \u0026rsquo;text\u0026rsquo;변수가 없으면 \u0026lsquo;default text\u0026rsquo;를 표시한다. fragment \u0026lt;div th:fragment=\u0026quot;name\u0026quot;\u0026gt;: \u0026rsquo;name\u0026rsquo; 이라는 이름으로 fragment를 생성한다. fragment는 th:replace, th:copy 를 사용해서 재활용 가능하다. copy \u0026lt;div th:copy=\u0026quot;this::name\u0026quot;\u0026gt;: 현재 파일의 \u0026rsquo;name\u0026rsquo; fragment를 \u0026lsquo;div\u0026rsquo;태그로 표현한다. \u0026rsquo;this\u0026rsquo; 대신 파일 이름을 사용하면 다른 파일의 fragment를 사용 가능하다. replace \u0026lt;div th:replace=\u0026quot;this::name\u0026quot;\u0026gt;: 현재 파일의 \u0026rsquo;name\u0026rsquo; fragment로 대체한다.(태그도 바뀐다.) \u0026rsquo;this\u0026rsquo; 대신 파일 이름을 사용하면 다른 파일의 fragment를 사용가능하다. ","permalink":"https://AswinBlue.github.io/post/thymeleaf/","summary":"Thymeleaf 서버에서 view를 구성할 때 사용하는 라이브러리 태그 형식의 문법을 사용하며 vue와 유사하다. 기본 문법 thymeleaf 공식 튜토리얼 에서 기본적인 문법을 확인할 수 있다. 태그 안에 th:속성=\u0026quot;값\u0026quot; 형태의 속성을 추가하는 형태로 사용한다. text \u0026lt;span th:text=\u0026quot;${text}\u0026quot;\u0026gt;default text\u0026lt;/span\u0026gt;: 서버에서 \u0026rsquo;text\u0026rsquo;라는 이름으로 정의한 태그가 있으면 text를 표시한다. text변수가 없으면 \u0026lt;span\u0026gt;default text\u0026lt;/span\u0026gt;를 표시한다. utext \u0026lt;span th:utext=\u0026quot;${utext}\u0026quot;\u0026gt;default text\u0026lt;/span\u0026gt;: \u0026rsquo;text\u0026rsquo; 이름으로 정의한 텍스트를 \u0026lsquo;span\u0026rsquo; 태그에 넣어 표시한다. \u0026rsquo;text\u0026rsquo;변수가 없으면 \u0026lsquo;default text\u0026rsquo;를 표시한다. fragment \u0026lt;div th:fragment=\u0026quot;name\u0026quot;\u0026gt;: \u0026rsquo;name\u0026rsquo; 이라는 이름으로 fragment를 생성한다.","title":"thymeleaf"},{"content":"Tailwind Css 프레임워크로 빠르고 효율적으로 css를 설정할 수 있는 툴이다. Tailwind Docs Installation npm install -D tailwindcss@latest 명령을 사용하여 설치가 가능하다.\nnpx tailwindcss init -P 명령을 사용하면 tailwind.config.js 파일이 생성되며, 현재 위치에서 tailwind를 적용할 수 있게 된다.\ntailwind.config.js 파일은 다음과 같이 구성된다. module.exports = {\r// 포함할 항목\rcontent: [\u0026#39;./src/**/*.{html,js,jsx,ts,tsx, mustache}\u0026#39;],\r// 제외할 항목 (최신 버전에서 사용되지 않는 문법)\r// purge: [\u0026#34;./src/**/*.html\u0026#34;, \u0026#34;./src/**/*.js\u0026#34;],\r// jit mode는 purge와 함께 세트로 사용되었고, 세트로 사라졌다.(?)\r// mode: process.env.NODE_ENV ? \u0026#39;jit\u0026#39; : undefined,\rdarkMode: \u0026#39;class\u0026#39;, // [false, \u0026#39;mdeia\u0026#39;, \u0026#39;class\u0026#39;]\rtheme: {\rfontFamily: {\rdisplay: [\u0026#39;Open Sans\u0026#39;, \u0026#39;sans-serif\u0026#39;],\rbody: [\u0026#39;Open Sans\u0026#39;, \u0026#39;sans-serif\u0026#39;],\r},\rextend: {\rfontSize: {\r14: \u0026#39;14px\u0026#39;,\r},\rbackgroundColor: {\r\u0026#39;main-bg\u0026#39;: \u0026#39;#FAFBFB\u0026#39;,\r\u0026#39;main-dark-bg\u0026#39;: \u0026#39;#20232A\u0026#39;,\r\u0026#39;secondary-dark-bg\u0026#39;: \u0026#39;#33373E\u0026#39;,\r\u0026#39;light-gray\u0026#39;: \u0026#39;#F7F7F7\u0026#39;,\r\u0026#39;half-transparent\u0026#39;: \u0026#39;rgba(0, 0, 0, 0.5)\u0026#39;,\r},\rborderWidth: {\r1: \u0026#39;1px\u0026#39;,\r},\rborderColor: {\rcolor: \u0026#39;rgba(0, 0, 0, 0.1)\u0026#39;,\r},\rwidth: {\r400: \u0026#39;400px\u0026#39;,\r760: \u0026#39;760px\u0026#39;,\r780: \u0026#39;780px\u0026#39;,\r800: \u0026#39;800px\u0026#39;,\r1000: \u0026#39;1000px\u0026#39;,\r1200: \u0026#39;1200px\u0026#39;,\r1400: \u0026#39;1400px\u0026#39;,\r},\rheight: {\r80: \u0026#39;80px\u0026#39;,\r},\rminHeight: {\r590: \u0026#39;590px\u0026#39;,\r},\rbackgroundImage: {\r\u0026#39;hero-pattern\u0026#39;:\r\u0026#34;url(\u0026#39;https://demos.wrappixel.com/premium-admin-templates/react/flexy-react/main/static/media/welcome-bg-2x-svg.25338f53.svg\u0026#39;)\u0026#34;,\r},\r},\r},\rplugins: [],\r}; tailwind는 react와 같은 framework에서는 자동으로 적용이 가능하지만, 그 외의 경우에는 postcss 등과 같은 모듈의 도움이 필요하다.\npostcss\nnpm install -D postcss postcss-cli : postcss 모듈과, 명령어 입력을 위한 postcss-cli를 설치한다. 이후 cmd창에 postcss 명령어가 동작한다.\npostcss SOURCE_FILE -o OBJECT_FILE : SOURCE_FILE 의 내용을 참조하여 OBJECT_FILE 경로에 파일 생성. SOURCE_FILE의 내용은 아래와 같다.\n@tailwind base;\r@tailwind components;\r@tailwind utilities; --watch 옵션을 붙이면 파일 변경시 다시 빌드하지 않아도 된다.\nscript\npackage.json 파일에 다음 스크립트를 작성한다. 이후 npm run build:postcss 명령으로 세팅을 할 수 있다.\n\u0026#34;scripts\u0026#34;: {\r\u0026#34;build:postcss\u0026#34;:\u0026#34;npx cross-env NODE_ENV=production postcss base.tailwind.css -o target/classes/static/css/tailwind.css\u0026#34;,\r\u0026#34;watch:postcss\u0026#34;:\u0026#34;npx cross-env NODE_ENV=production postcss base.tailwind.css -o src/main/resources/static/css/tailwind.css -w\u0026#34;\r} tailwind를 적용할 파일들을 앞서 tailwind.config.js 파일에서 \u0026lsquo;content\u0026rsquo; 항목에 넣어 지정했었다. 이 파일들에 새로운 class를 사용하였다면 postcss 명령으로 새로 build를 해줘야 한다.\nbuild가 아닌 watch를 사용했다면 실시간으로 변경점이 적용된다.\nConfig\nProject root 경로에 tailwind.config.js 파일에서 tailwind에 사용되는 custom 설정을 할 수 있다. font theme.extend.fontFamily에 사용할 font 이름을 정의하고,\ntheme: {\rextend: {\rfontFamily: {\rbody: [\u0026#39;Nunito\u0026#39;],\r}\r}\r}, 빌드할 tailwind.css 원본 파일에 해당 font가 정의된 url을 import한다.\ngoogle에서 지원하는 font 사이트 에서 font들 import 가능\n@import url(\u0026#39;@import url(\u0026#39;https://fonts.googleapis.com/css2?family=Nunito:ital,wght@0,200;1,200\u0026amp;display=swap\u0026#39;);\u0026#39;)\r@tailwind base;\r@tailwind components;\r@tailwind utilities; Classes tailwind에서 사용되는 대표적인 Class들에 대해 사용법을 설명한다. Box flex flex는 특정 tag 안의 내용물들을 가로로 정렬시켜준다. \u0026lt;div class=\u0026#34;flex\u0026#34;\u0026gt;\r\u0026lt;div\u0026gt;1\u0026lt;/div\u0026gt;\r\u0026lt;div\u0026gt;2\u0026lt;/div\u0026gt;\r\u0026lt;div\u0026gt;3\u0026lt;/div\u0026gt;\r\u0026lt;/div\u0026gt; 위치 정렬 위치는 content, item, self 세 가지에 대해 정렬이 가능하다. y축 정렬(위아래)은 align으로 하고, x축 정렬(좌우)은 justify로 한다. justify content: 가로방향 정렬\njustify-start: 좌측 모서리 기준 정렬 justify-end: 우측 모서리 기준 정렬 justify-center: 가운데 정렬 justify-between: 컨테이너 좌우 공간 없이 각 항목들 동등 간격으로 배치 justify-around: 컨테이너 좌우도 공간을 넣으며 항목들 좌우에 일정한 margin을 두고 배치 justify-evenly: 컨테이너 좌우를 포함하여 항목들 사이 간격이 동일하도록 배치 align items: 세로방향 정렬\nitems-start: 위쪽 모서리를 기준으로 정렬 items-end: 아래쪽 모서리를 기준으로 정렬 items-center: 정중앙 가로선을 기준으로 정렬 items-baseline: container의 baseline, 즉 내용물이 표시되는 기준점이 서로 통일되도록 정렬 items-stretch: 가장 긴 항목에 맞게 다른 항목들을 늘려서 정렬 Responsive items 화면 크기에 따라 다르게 Css를 다르게 적용하고 싶다면, sm:, md:, lg:, xl:, 2xl: class를 이용하면 된다.\n기본 설정으로는 각각 640px, 768px, 1024px, 1280px, 1536px 이상일 때 특정 속성을 갖도록 설정할 수 있다.\n아무것도 붙이지 않으면 0~640px의 속성을 정의하며, 더 큰 화면에 대해서는 sm, md 등으로 속성을 덮어쓰는 형식으로 반응형 페이지를 만든다.\n: 0px ~ 640px sm : 640px ~ 768px md : 768px ~ 1024px lg : 768px ~ 1024px xl : 1024px ~ 1280px 2xl : 1280px ~ 1536px \u0026lt;h1 class=\u0026quot;text-sm md:text-lg lg:text-xl\u0026quot;\u0026gt; test \u0026lt;/h1\u0026gt;\n화면 크기에 따라 글자 크기가 바뀌는 예시 Refs ","permalink":"https://AswinBlue.github.io/post/tailwind/","summary":"Tailwind Css 프레임워크로 빠르고 효율적으로 css를 설정할 수 있는 툴이다. Tailwind Docs Installation npm install -D tailwindcss@latest 명령을 사용하여 설치가 가능하다.\nnpx tailwindcss init -P 명령을 사용하면 tailwind.config.js 파일이 생성되며, 현재 위치에서 tailwind를 적용할 수 있게 된다.\ntailwind.config.js 파일은 다음과 같이 구성된다. module.exports = {\r// 포함할 항목\rcontent: [\u0026#39;./src/**/*.{html,js,jsx,ts,tsx, mustache}\u0026#39;],\r// 제외할 항목 (최신 버전에서 사용되지 않는 문법)\r// purge: [\u0026#34;./src/**/*.html\u0026#34;, \u0026#34;./src/**/*.js\u0026#34;],\r// jit mode는 purge와 함께 세트로 사용되었고, 세트로 사라졌다.","title":"Tailwind"},{"content":"Spring Boot Spring boot는 서버 생성을 위한 도구로, spring 프레임워크에 편의성을 향상시킨 프레임워크이다. Java, Kitlin, Groovy 등의 언어로 구현이 가능하다. 개발환경 java 기반으로 동작하기에 jdk 설치가 필요하다. (22년 기준) 11버전 이상을 다운받는것을 추천한다. IDE vs code를 사용한다면 확장패키지로 \u0026lsquo;Java Extension Pack\u0026rsquo; 과 \u0026lsquo;Spring Boot Extension Pack\u0026rsquo; 을 설치한다. java 개발을 위한 eclips나 intelliJ를 사용해도 된다. spring 프로젝트 생성 start.spring.io 페이지에 들어가면 프로젝트를 생성할 수 있는 UI가 구성되어 있다. 원하는대로 설정 후 다운로드를 받아서 사용하면 된다. gradle 설치 https://gradle.org/releases/ 주소에서 gradle 파일을 다운받는다. 이후 path 설정을 마친 후, 프로젝트 root directory에서 gradle wrapper 명령을 수행해 gradlew파일을 생성한다. 기본 설정 포트 설정 application.properties (혹은 yml)파일을 열고, server.port = 8080 와 같이 기입하면 동작 포트를 8080으로 설정할 수 있다. devtools 설정 정적 파일들을 갱신했을 때, 서버 재실행 없이 explorer만 reload 해 주면 변경점이 반영될 수 있도록 한다.\n이 외에 DB, 포트, mvc, thymleaf 등 각종 설정이 포함된 yml 파일 예시는 다음과 같다.\n```\r# web 서버 동작 설정\rserver:\r# 포트 설정\rport: 8080\r# spring boot 설정\rspring:\rconfig:\ractivate:\ron-profile: deploy\r# h2 database 설정\rh2:\rconsole:\renabled: true\r# jpa 설정\rjpa:\rdatabase: h2\rgenerate-ddl: off\rdatasource:\rdriver-class-name: org.h2.Driver\rurl: jdbc:h2:mem:testdb;MODE=MySQL;\rusername: SA\rpassword:\rinitialization-mode: always\rschema: classpath:schema-h2.sql\rdata: classpath:data-h2.sql\r# spring의 MVC 모델 설정\rmvc:\r# view로 사용할 static resources의 위치 및 파일 확장자 설정\r# thymeleaf가 view역할을 하기 때문에 본 프로젝트에서는 mvc 모듈 내용 활용 안됨\rview:\rprefix: /myApp/\rsuffix: .jsp\r# thymeleaf 설정, MVC에서 view를 담당\rthymeleaef:\rcache: false\rmode: HTML\rencoding: UTF-8\rprefix: file:src/main/resources/templates/\r# web 서버 동작시 설정\rweb:\rresources:\r# resource 위치, html파일에서 참조시 연결될 root 디렉터리\rstatic-locations: file:src/main/resources/static/\rcache:\rperiod: 0\r# devtools 설정, apply static resources instantly\rdevtools:\rlivereload:\renabled: true\r# SLF4J 설정, 로그 시스템\rlogging:\rfile:\rname: ${user.dir}/log/test.log # Log file path\rmax-history: 7 # delete period\rmax-size: 10MB # max size of single log file\rlevel: # set log level to each package\rcom.aswinblue.RankServer : debug\rpattern:\rconsole: \u0026quot;%d{HH:mm:ss.SSS} [%t] %-5level %logger{36} - %msg%n\u0026quot;\rfile: \u0026quot;%d %p %c{1.} [%t] %m%n\u0026quot;\r```\r빌드 설정\ngradle 프로젝트는 ./gradlew build 명령으로 프로젝트를 빌드한다.\n이때 build.gralde 파일 설정으로 하위 프로젝트의 빌드까지 함께 정의할 수 있다.\ngradle 파일이 수정되면 ./gradlew build 명령을 새로 돌려서 업데이트 해 준다.\n아래는 React 프로젝트의 빌드 세팅이다.\n/*********************\r* 기본 설정 및 dependency\r*********************/\rplugins {\rid \u0026#39;org.springframework.boot\u0026#39; version \u0026#39;2.7.1\u0026#39;\rid \u0026#39;io.spring.dependency-management\u0026#39; version \u0026#39;1.0.11.RELEASE\u0026#39;\rid \u0026#39;java\u0026#39;\r}\rgroup = \u0026#39;com.aswinblue\u0026#39;\rversion = \u0026#39;0.0.1-SNAPSHOT\u0026#39;\rsourceCompatibility = \u0026#39;18\u0026#39;\rrepositories {\rmavenCentral()\r}\rdependencies {\rimplementation \u0026#39;org.springframework.boot:spring-boot-starter-data-jpa\u0026#39;\rimplementation \u0026#39;org.springframework.boot:spring-boot-starter-thymeleaf\u0026#39;\rimplementation \u0026#39;org.springframework.boot:spring-boot-starter-web\u0026#39;\rimplementation \u0026#39;com.h2database:h2\u0026#39;\rtestImplementation \u0026#39;org.springframework.boot:spring-boot-starter-test\u0026#39;\rimplementation \u0026#39;org.springframework.boot:spring-boot-devtools\u0026#39; //devtools\r}\rtasks.named(\u0026#39;test\u0026#39;) {\ruseJUnitPlatform()\r}\r/*********************\r* React 설정\r*********************/\rdef reactDir = \u0026#34;$projectDir/src/main/webapp\u0026#34;; // react 프로젝트 경로 설정\rsourceSets{\rmain{\rresources{\rsrcDirs = [\u0026#34;$projectDir/src/main/resources\u0026#34;]\r}\r}\r}\r// 최초로 수행할 task 지정\rprocessResources{\rdependsOn \u0026#34;copyReactBuildFiles\u0026#34;\r}\r// $reactDir 위치에서 `npm audit fix` 명령 실행\rtask installReact(type:Exec){\rworkingDir \u0026#34;$reactDir\u0026#34;\rinputs.dir \u0026#34;$reactDir\u0026#34;\rgroup = BasePlugin.BUILD_GROUP\rif(System.getProperty(\u0026#39;os.name\u0026#39;).toLowerCase(Locale.ROOT).contains(\u0026#39;windows\u0026#39;)){\rcommandLine \u0026#34;npm.cmd\u0026#34;, \u0026#34;audit\u0026#34;, \u0026#34;fix\u0026#34;\rcommandLine \u0026#39;npm.cmd\u0026#39;, \u0026#39;install\u0026#39;\r}else{\rcommandLine \u0026#34;npm\u0026#34;, \u0026#34;audit\u0026#34;, \u0026#34;fix\u0026#34;\rcommandLine \u0026#39;npm\u0026#39;, \u0026#39;install\u0026#39;\r}\r}\r// installReact task를 호출\r// $reactDir 위치에서 `npm run-script build` 실행\r// react 프로젝트의 `package.json` 파일에 적힌 build 스크립트가 실행됨.\rtask buildReact(type:Exec){\rdependsOn \u0026#34;installReact\u0026#34;\rworkingDir \u0026#34;$reactDir\u0026#34;\rinputs.dir \u0026#34;$reactDir\u0026#34;\rgroup = BasePlugin.BUILD_GROUP\rif(System.getProperty(\u0026#39;os.name\u0026#39;).toLowerCase(Locale.ROOT).contains(\u0026#39;windows\u0026#39;)){\rcommandLine \u0026#34;npm.cmd\u0026#34;, \u0026#34;run-script\u0026#34;, \u0026#34;build\u0026#34;\r}else{\rcommandLine \u0026#34;npm\u0026#34;, \u0026#34;run-script\u0026#34;, \u0026#34;build\u0026#34;\r}\r}\r// buildReact task를 호출\r// 앞서 지정한 $reactDir 경로의 /build 위치에서 생성된 데이터를 $projectDir/src/main/resources/static 로 복사\rtask copyReactBuildFiles(type:Copy) {\rdependsOn \u0026#34;buildReact\u0026#34;\rfrom \u0026#34;$reactDir/build\u0026#34;\rinto \u0026#34;$projectDir/src/main/resources/static\u0026#34;\r} 각종 설정을 해주는 batch 파일 예시이다.\ngradle wrapper\rgradlew build\r@REM package.json에 script 작성 필요\rnpm run build:postcss 폴더 설정\nresources : html, css 등 화면 구성을 위한 파일들의 root 디렉터리 resources/static : html파일에서 href로 참조하면 아래 디렉터리를 root로 경로 설정 가능 resources/template : mustache 파일에서 root 디렉터리로 사용 웹 서비스 개발 tomcat spring boot에서 web 패키지를 설치하면 tomcat을 사용하여 web server를 동작시킨다. localhost:8080으로 default 주소가 처리되어 있고, application.yml 파일에서 아래와 같이 수정 가능하다. server:\rport : 8081 MVC 모델 model, view, control 을 나누어 개발하는 형태를 MVC 모델이라고 한다. View template view template 은 controller와 model을 합친 개념으로, 화면을 구성하는 역할을 한다. mustache 패키지를 설치하여 view template를 만들 수 있다. jsp 활용\nSpring boot에는 jsp가 잘 어울리지 않는다고 한다. 대신 Thymleaf, mustache 등을 사용하는걸 권장한다?\njsp를 사용하여 model을 구성할 수도 있다.\njsp는 사용하기 전 application.properties(혹은 yml) 파일의 수정이 필요하다. 아래 내용을 추가한다.\nspring.mvc.view.prefix=/myApp/\rspring.mvc.view.suffix=.jsp 위 내용을 적용하면 src/main/webapp/myApp/ 경로 내부에서 jsp파일을 찾게 된다. \u0026lsquo;webapp\u0026rsquo; 폴더는 default로 필요하다.\nmustache 활용\n앞서 말헀듯 mustache는 view template용 패키지로 controller와 model을 관장한다.\ncontroller는 기본 패키지 경로 하위에 배치한다.\ncontroller는 다음과 같이 구성한다.\npackage com.example.firstproject.controller;\rimport org.springframework.stereotype.Controller;\rimport org.springframework.web.bind.annotation.GetMapping;\rimport org.springframework.ui.Model;\r@Controller // controller를 정의하는 annotation\rpublic class FirstController {\r@GetMapping(\u0026#34;/index\u0026#34;) // 연결될 url을 지정하는 annotation, /index 로 연결하면\rpublic String mainPage(Model model) // model 을 통해 가변 인자 control\r{\rmodel.addAttribute(\u0026#34;title\u0026#34;, \u0026#34;hello world\u0026#34;); // title 이름으로 hello world 라는 문자열을 설정\rreturn \u0026#34;mainPage\u0026#34;; // mainPage.mustache 파일과 연동\r}\r} model(.mustache .html 등)은 resources/templates 파일 경로 하위에 배치하고, 확장자를 .mustache로 지정한다.\nhtml 파일은 사실 view에 가깝지만, mustache 파일은 view에 변수를 적용하여 model에 해당한다.\nmodel은 다음과 같이 구성한다.\n\u0026lt;body\u0026gt;\r\u0026lt;h1\u0026gt;{{title}}\u0026lt;/h1\u0026gt; \u0026lt;!-- controller에서 정의한 title이 {{title}}에 치환됨 --\u0026gt;\r\u0026lt;/body\u0026gt; Layout\nmodel을 만들 때는 layout에 따라 화면에 보여지는 형태를 구성할 수 있다. layout을 template화 하여 사용 가능하다. 재사용 되는 부분을 모듈화 하여 파일로 분리하고, 이를 다른 파일에서 불러올 수 있다. {{\u0026gt;FILE_NAME}} 형태로 다른 파일을 호출해 올 수 있다. Controller Controller는 request를 받아 어떤 화면을 보여줄지 결정하는 routing 로직을 담당하게 된다. controller class는 @Controller annotation을 붙여서 선언하며 routing 함수로는 @GetMapping, @RequestMapping annotation을 사용하여 정의한다. 에러 화면 에러 화면도 controller에 의해 유도되며 BasicErrorController가 이를 담당한다. application.yml 파일에서 따로 설정을 하지 않았다면 server.error.path=/error 가 기본이다. JPA spring은 mysql, postgress, M2 등 여러 DB를 적용할 수 있다. controller는 Java로 구현되고, DB는 sql로 동작하기 때문에 java로 sql을 조작하기 위한 JPA라는 라이브러리가 필요하다. Entity : java 객체를 DB가 이해할 수 있게 재구성한 데이터 @Entity : 해당 class를 entity 로 선언 @Table(name=\u0026quot;\u0026quot;) : 특정 table과 객체를 연동. 기본적으로는 calss 이름에 해당하는 DB의 table과 매핑 된다. @Column : 지정한 변수를 DB의 컬럼으로 선언 Repository : entity를 DB에 저장하는 역할을 수행하는 객체 save(ENTITY) : 저장, DB의 insert / update 에 해당\ndelete(ENTITY) : 특정 Entity 삭제, DB의 delete에 해당\n상세 내용은 링크를 참조한다.\nJPA Usage Links\rJPA Repository Query function JPA Repository Query annotation JPA Repository get Top x result JPA update data from DTO DTO 정의\n서버의 Controller에서 이를 처리 가능하며, 사용자 입력을 Java Class로 대응시킨 형태를 DTO라 칭한다. DTO를 다음과 같이 정의하였다고 하자 class DtoSample {\rprivate String name;\rpublic DtoSample(String name) {\rthis.name = name;\r}\r} Entity 정의\nDTO에 해당하는 entity를 정의해야하며, 그 형태는 다음과 같다. entity는 @Entity annotation을 붙여야 한다. Entity는 primary key를 가져야 하며, 이는 @Id annotation으로 지정한다. DB의 column에 해당하는 값들은 @Column annotation을 붙여준다. @GeneratedValue는 자동으로 생성된 값이 들어가도록 한다. \u0026lsquo;실제 DB table\u0026rsquo; ⊃ \u0026lsquo;DTO에 정의된 column들\u0026rsquo; 이 성립해야 한다. @Entity\rpublic class sampleEntity {\r@Id // 대표값\r@GeneratedValue // 자동생성\rprivate Long id;\r@Column\rprivate String name;\rpublic sampleEntity(Long id, String name) {\rthis.id = id;\rthis.name = name;\r}\r} Repository 구현\nEntity를 DB에 저장하기 위한 Repository도 생성한다. repository는 entity로 DB에 접근하는 방법을 정의하기 위한 객체이다. spring에서 기본으로 제공하는 형태를 상속받아 사용도 가능하다. // CrudRepository\u0026lt;관리대상, 대표값의 type\u0026gt;\rpublic interface searchNameRepository extends CrudRepository\u0026lt;sampleEntity, Long\u0026gt; {\r// CrudRepository 의 기본값을 사용\r} 직접 구상한 쿼리를 사용하고 싶다면 camelcase로 구성된 함수 이름으로 쿼리를 추가할 수 있다.\nTips [no property ~ found for type ~ 오류 해결법](https://stackoverflow.com/questions/19733464/order-by-date-asc-with-spring-data)\rpublic interface searchNameRepository extends CrudRepository\u0026lt;SampleEntity, Long\u0026gt; {\r// select * from SampleEntity where name = ?1 @Query(\u0026#34;Select s From SampleEntity\u0026#34;)\rList\u0026lt;sampleEntity\u0026gt; findByName(String name);\r// select * from SampleEntity where name = ?1 and id = 1\r@Query(\u0026#34;Select s From SampleEntity where s.id = 1\u0026#34;)\rList\u0026lt;sampleEntity\u0026gt; findByName(String name);\r} 기타 추가작업\n이전에 만들었던 controller 에 내용을 추가한다. DTO로 받은 내용을 Entity로 변환시켜 repository를 통해 처리한다. @Autowired // String boot가 알아서 new 해서 사용하는 annotation\rsearchNameRepository snr;\r@PostMapping(\u0026#34;/data/part1\u0026#34;)\rpublic String handleForm(DtoSample dto) {\rsampleEntity name = dto.toEntity(); // toEntity 구현 필요\rname = snr.save(name); // \u0026#39;save\u0026#39;는 저장 및 저장된 데이터를 반환함\rreturn \u0026#34;returnView\u0026#34;;\r} contorller에서 받은 DTO 데이터를 entity로 변환시킬 때 사용한 toEntity() 함수를 구현해야 한다. DTO 파일을 추가로 수정한다. class DtoSample {\rprivate String name;\rpublic DtoSample(String name) {\rthis.name = name;\r}\rpublic sampleEntity toEntity() {\rreturn new sampleEntity(null, this.name); // id에 null을 넣는다. @GeneratedValue에 의해 자동으로 생성된다.\r}\r} 데이터 교환 view에서 사용자 입력을 받아 처리하는 과정을 다룬다. 앞서 JPA를 통해 구현한 DB 시스템에 데이터를 넣을 수 있다. view 구현 view쪽에서는 form 태그를 사용하여 controller에 데이터를 전송할 수 있다. form 태그의 인자로 action, method를 적용 가능하다. action : 데이터를 보낼 url을 설정. ex) action=\u0026quot;/data/part1\u0026quot; method : 전송 방법을 설정한다. post 혹은 get 적용 가능 form 태그 안의 input태그를 두고, 인자로 name을 설정한다. \u0026lt;form action=\u0026#34;/data/userRank\u0026#34; method=\u0026#34;post\u0026#34;\u0026gt;\r\u0026lt;label\u0026gt;type your character name\u0026lt;/label\u0026gt;\r\u0026lt;input type=\u0026#34;text\u0026#34; name=\u0026#34;userName\u0026#34;\u0026gt;\r\u0026lt;br/\u0026gt;\r\u0026lt;button\u0026gt;see table\u0026lt;/button\u0026gt;\r\u0026lt;br/\u0026gt;\r\u0026lt;/form\u0026gt; controller 구현 DTO로 사용할 class를 선언한다. (ex: DtoSample) controller 를 구현한 java 파일에서 @PostMapping annotation을 달고, 인자로 위에서 선언한 DTO를 받는다. return 값으로 지정한 이름의 view로 redirect 한다. (ex: returnView) @PostMapping(\u0026#34;/data/part1\u0026#34;)\rpublic String handleForm(DtoSample dto) {\rreturn \u0026#34;returnView\u0026#34;;\r} parameter를 꼭 DTO 형태로 받지 않을 수도 있다. @RequestBody, @RequestParam annotation을 이용하여 데이터를 받을 수 있다. public String handleUserNameForm(@RequestBody String userName, Model model) {}\r// userName = \u0026#34;userName=TESTNAME\u0026#34; 과 같이 데이터가 받아진다. public String handleUserNameForm(@RequestParam String userName, Model model) {}\r// userName = \u0026#34;TESTNAME\u0026#34; 과 같이 데이터를 받을 수 있다. Bean Spring boot를 실행하면 container가 동작하는데, 이 container가 관리하는 객체를 bean이라고 한다. 선언\nComponent 사용 @Component annotation을 class에 붙여주면, 해당 class가 bean으로 등록된다. 직접 구현한 객체를 bean으로 적용할 떄 사용할 수 있다. @AutoWired annotation을 이용해 의존성을 정의할 수 있다. @Component\rclass C {\r// C가 bean으로 등록\rpublic C() {\rSystem.out.println(\u0026#34;use C as bean\u0026#34;);\r}\r@AutoWired\rprivate D d; // D 라는 class에 대한 dependency 정의\r} Bean 사용 @Configuration annotation을 class에 붙여주고, 해당 class에 선언된 함수에 @Bean annotation을 붙여준다. @Bean 이 붙은 함수에서 반환되는 값들은 모두 Bean으로 관리된다. 3rd party에서 구현된 객체를 bean으로 적용할 때 사용할 수 있다. bean으로 반환할 객체 생성자에 인자를 넣어 의존성을 정의할 수 있다. class Foo {\rpublic Foo() {\rSystem.out.println(\u0026#34;use Foo as bean\u0026#34;);\r}\r}\rclass Bar {\rpublic Bar() {\rSystem.out.println(\u0026#34;Bar as dependency\u0026#34;);\r}\r}\r@Configuration\rclass configure {\r@Bean\rpublic Bar bar() {\rreturn new Bar(); // Bar을 bean으로 선언\r}\r@Bean\rpublic Foo foo() {\rreturn new Foo(new Bar()); // Foo가 Bar의 의존성을 가짐을 표현\r}\r} spring은 @ComponentScan annotation이 붙은 class에서 component(bean)을 찾아가기 시작한다. spring 프로젝트를 생성하면 main 함수가 있는 class가 있는데, 이 clalss에 붙은 @SpringBootApplication annotation이 @ComponentScan annotation을 포함하고 있다. @Configuration annotation 도 @Component annotation을 포함하고 있어 scan 대상이 된다. @Controller 로 선언된 class들도 bean으로 관리되는데, 이는 @Controller가 @Component annotation을 포함하고 있기 때문이다. Annotation 및 기능 Value @Value annotation을 변수에 선언하면 프로젝트 설정파일(application.yml) 에서 변수를 가져올 수 있다. @Value(${server.port})\rprivate int port; Scheduled spring boot로 특정 주기마다 반복 동작을 수행하는 기능을 구현할 수 있다. main 함수가 선언된 class에 @EnableScheduling 을 선언한다. schedule을 관리할 class(Scheduler)를 선언하고, @Component annotation을 붙인다. 에서 생성한 Scheduler class에 함수를 선언하고, @Scheduled annotation을 붙인다. @Scheduled(cron = \u0026quot;1 2 3 4 5 ?\u0026quot;) : 매 5월4일3시2분1초 에 동작 숫자대신 *을 하면 모든 값에 동작하도록 설정 가능 앞에서부터 초,분,시,일,월,요일이며 요일은 0이 일요일 6이 토요일, 7또한 일요일이다. 상세 내용은 공식 document 참조 fixedDelay=1000 : 매 1초마다 동작(함수 종료 시점부터 1초) fixedRate=1000 : 매 1초마다 동작(함수 시작 시점부터 1초) SLF4J 로그를 쉽게 설정하기 위한 툴 참조한 사이트 https://allonsyit.tistory.com/43 https://galid1.tistory.com/494 https://atoz-develop.tistory.com/entry/Spring-%EC%8A%A4%ED%94%84%EB%A7%81-%EB%B9%88Bean%EC%9D%98-%EA%B0%9C%EB%85%90%EA%B3%BC-%EC%83%9D%EC%84%B1-%EC%9B%90%EB%A6%AC https://goateedev.tistory.com/128 https://itworldyo.tistory.com/40 https://docs.spring.io/spring-data/jpa/docs/current/reference/html/ ","permalink":"https://AswinBlue.github.io/post/spring_boot/","summary":"Spring Boot Spring boot는 서버 생성을 위한 도구로, spring 프레임워크에 편의성을 향상시킨 프레임워크이다. Java, Kitlin, Groovy 등의 언어로 구현이 가능하다. 개발환경 java 기반으로 동작하기에 jdk 설치가 필요하다. (22년 기준) 11버전 이상을 다운받는것을 추천한다. IDE vs code를 사용한다면 확장패키지로 \u0026lsquo;Java Extension Pack\u0026rsquo; 과 \u0026lsquo;Spring Boot Extension Pack\u0026rsquo; 을 설치한다. java 개발을 위한 eclips나 intelliJ를 사용해도 된다. spring 프로젝트 생성 start.spring.io 페이지에 들어가면 프로젝트를 생성할 수 있는 UI가 구성되어 있다. 원하는대로 설정 후 다운로드를 받아서 사용하면 된다.","title":"Spring_boot"},{"content":"Algorithm 그래프 탐색 SP(Shortest Path) 단일 출발점에서 단일 목적지까지 최단 경로를 찾는 알고리즘\nDFS 용도 : 경로가 있는지 확인할 때 사용 가능 자로구조 : stack 방법 : 시작 node를 stack에 넣는다. stack이 모두 빌때까지 아래 동작을 반복한다. stack의 top을 현재 node로 설정한다. 현재 node를 \u0026lsquo;visited\u0026rsquo; 처리하고 stack에서 제거한다. 다음으로 이동할 node가 있는지 확인한다. 다음으로 이동할 node \u0026lsquo;A\u0026rsquo;가 있다면, 현재 node에서 그다음에 탐색할 방향을 stack에 push하고, node \u0026lsquo;A\u0026rsquo;도 stack에 push한다. 더이상 갈 곳이 없으면 현재 node의 visited 처리를 복원한다. 최종 목적지에 도달한 경우를 모아 결과값을 비교한다. 예시 : BFS 용도 : 최단경로 탐색에 사용 가능 자로구조 : queue 방법 : 시작 node를 queue에 넣는다. queue가 비거나 목적지에 도달할 때 까지 아래 동작을 반복한다. queue의 front를 pop 하여 현재 node로 설정한다. 현재 node에서 이동 가능한 node가 있는지 확인하고, 이동 가능하다면 모두 queue에 push한다. queue에 push하면서 해당 경로는 \u0026lsquo;visited\u0026rsquo; 처리를 한다. (주의) queue에 넣으면서 visited 처리를 하고, queue에 넣기전에 방문 여부를 판단해야 메모리 부족을 예방할 수 있다. SSSP (Single Source Shortest Path) 단일 출발점에서 모든 node까지 최단 경로를 찾는 알고리즘\nDijkstra 용도: cycle이 없는 graph 음수 node가 없는 graph 자료구조 : list, heap 방법: 출발점 S에서 각 node까지 거리를 list에 표현한다. 현재 S에서 최적의 거리를 가진 node M을 선택한다. (heap 사용) M을 거쳐서 각 node까지 이동하는 경로와 현재 list에 표기된 값을 비교해 최적을 선택한다. for (edge in graph[M]) { // M에서 발생되는 모든 edge들에 대해\rif (list[M] + edge.cost \u0026lt; list[edge.destination]) { // S -\u0026gt; * -\u0026gt; M -\u0026gt; T 까지 거리가 S -\u0026gt; * -\u0026gt; T 거리보다 짧다면\r// S -\u0026gt; * -\u0026gt; T 거리 = list[M], M -\u0026gt; T 거리 = edge.cost\rlist[edge.destination] = list[M] + edge.cost // 값 갱신\r} Bellman-Ford 용도: 자료구조: 방법: APSP (All Pair Shortest Path) 모든 node에서 모든 node로 가는 최적 경로를 찾는 알고리즘\nFloyd-Warshall 용도: 자료구조: 방법: Dynamic Programming 0 1 knapsack 용도 : 나눌수 없는 물건을 최대 무게 한도로 담고 싶을 때 사용 최소 단위로 나눌 수 있다면 greedy를 사용하면 된다. 자료구조: 2d array 방법: 2차원 배열 D를 선언한다. 행은 최대한도 k를 뜻하며, 열은 1부터 n번째 물건을 판단했을 때 최선의 값을 의미한다.\n최대 한도를 0부터 K까지 늘려가고, 모든 물건을 순회하며 가치(v)와 무게(w)를 고려해 아래 식을 체크한다.\n한도가 k일때 n번째 인자에 대해 D[k][n] = max(D[k - w[n]][n-1] + v[n], D[k - 1])[n-1]\n만약 w[n] \u0026gt; k 라면 그냥 D[k][n] = D[k - 1][n-1]\n2차원배열 대신 1차원 배열을 사용하면, 이미 선택한 인자를 중복해서 선택하게 되므로 오답\n2차원 배열에서 첫 열과 첫 행의 값은 0으로 세팅해 주어야 한다. (아무것도 담지 않은/못한 상황)\n예시: # https://www.acmicpc.net/submit/12865\rif __name__ == \u0026#39;__main__\u0026#39;:\rN, K = map(int, input().split())\rW = [0]\rV = [0]\rfor i in range(N):\rw, v = map(int, input().split())\rW.append(w)\rV.append(v)\rresult = [[0 for j in range(N+1)] for i in range(K+1)]\r# 배낭의 한계를 를 1부터 증가시켜가며 dynamic programming을 수행한다.\rfor i in range(1, K+1):\r# 모든 물건에 대해 물건을 넣었을 때와 넣지 않았을 때를 확인한다.\rfor j in range(1, N+1):\rif W[j] \u0026lt;= i:\r# 확인 결과 더 최선의 값을 도출한다.\rresult[i][j] = max(result[i - W[j]][j-1] + V[j], result[i][j-1]) # 넣었을때 vs 넣지 않았을 때\relse:\rresult[i][j] = result[i][j-1]\rprint(result[K][N]) 순서 정렬 minHeap + maxHeap maxHeap + minHeap 을 사용하여 \u0026lsquo;상위 n개의 데이터\u0026rsquo; 혹은 \u0026lsquo;중앙 값\u0026rsquo;을 구할 수 있다. 아래와 같이 top과 top이 마주보는 구조로 minHeap과 maxHeap을 사용한다. https://www.acmicpc.net/problem/1655\r/*\r* by using two heap(minH, maxH), always can get middle value at maxH.top()\r*\r* (maxH) (minH)\r* input -\u0026gt; [ a1, a2, a3, ... an(top)] [ b1(top), b2, b3, .. bm]\r* ^\r* middle value\r*/ 규칙 찾기 정해진 공식을 대입하는것이 아닌, 문제에서 규칙을 찾아 해결하는 방식 키보드 좌표계\n키보드 자판을 보면 행은 똑바르지만, 열은 살짝 어긋나있다. S를 보면 Q,W,E,A,D,Z,X,C 와 접해있다. 한 버튼에서 다른 버튼까지 이동하는데 걸리는 시간을 계산한다 해 보자. Q에서 E까지는 2번, Q에서 D까지는 3번, Q에서 X까지는 3번에 걸쳐 이동할 수 있다. 이러한 좌표에서 특정 문자를 입력하기 위해 각 자판을 이동하는데 걸리는 시간을 계산한다면? 통용되는 규칙을 찾아서 해결한 경우\nPython Code\rdef solve():\r# 키보드 배열을 좌표평면으로 본다. # Q를 (0,2)로, W를 (2,2) E를 (4,2) ...\r# A를 (1,1), S를 (3,1), D를 (5,1) ...\r# Z를 (2,0), X를 (4,0), C를 (6,0) ...\r# 이후 x좌표 거리를 2로 나누고 y좌표 거리를 더한 후, y 좌표의 거리를 2로 나눈 값을 빼주면 실제 이동 거리가 나온다. # 단, x좌표가 동일할 경우에는 예외로 y좌표 거리가 실제 이동 거리이다. # 이는 y좌표가 3 초과여도 적용되는 규칙이다.\r# ex1) Q(0,2) -\u0026gt; C(6,0) = (6/2 + 2) - 2/2 = 4\r# ex2) T(8,2) -\u0026gt; V(8,0) = (0 + 2) = 2\t(예외)\r# ex3) Q(0,2) -\u0026gt; T(8,2) = (8/2 + 0) - 0 = 4\rcoord = {}\rkey3 = ['Q','W','E','R','T','Y','U','I','O','P']\rkey2 = ['A','S','D','F','G','H','J','K','L']\rkey1 = ['Z','X','C','V','B','N','M']\rMOVING_TIME = 2\rTYPING_TIME = 1\rfor i in range(len(key3)):\rcoord[key3[i]] = (i * 2, 2)\rfor i in range(len(key2)):\rcoord[key2[i]] = (i * 2 + 1, 1)\rfor i in range(len(key1)):\rcoord[key1[i]] = (i * 2 + 2, 0)\rword = input()\rtime = len(word) * TYPING_TIME # time elapsed when typing\rprev = None\r# for all words, calculate distance\rfor w in word:\rif prev is None:\rprev = w\rcontinue\rstart = coord[prev]\rend = coord[w]\r# rule exception\rif start[0] == end[0]:\rtime += abs(end[1] - start[1]) * MOVING_TIME\rprev = w\rcontinue\r# time eplased when moving\rtime += (abs(end[0] - start[0]) // 2 + abs(end[1] - start[1]) - abs(end[1] - start[1]) // 2) * MOVING_TIME\r# settings for next cycle\rprev = w\rprint(time)\rif __name__ == '__main__':\rT = int(input())\rfor t in range(T):\rsolve()\r모든 case를 구분하여 해결한 경우\nC++ Code\r#include \u0026lt;map\u0026gt;\r#include \u0026lt;iostream\u0026gt;\r#define DEBUG 0\rusing namespace std;\rint main(void) {\r// initialize keyboard array\rmap\u0026lt;char,pair\u0026lt;int,int\u0026gt;\u0026gt; qwerty;\rchar row1[] = {'Q','W','E','R','T','Y','U','I','O','P'};\rchar row2[] = {'A','S','D','F','G','H','J','K','L'};\rchar row3[] = {'Z','X','C','V','B','N','M'};\rfor (int i = 0; i \u0026lt; (int)sizeof(row1); i++) {\rqwerty.insert(make_pair(row1[i], make_pair(0, i)));\r}\rfor (int i = 0; i \u0026lt; (int)sizeof(row2); i++) {\rqwerty.insert(make_pair(row2[i], make_pair(1, i)));\r}\rfor (int i = 0; i \u0026lt; (int)sizeof(row3); i++) {\rqwerty.insert(make_pair(row3[i], make_pair(2, i)));\r}\r#if DEBUG\rfor (int i = 0; i \u0026lt; (int)sizeof(row1); i++) {\rcout \u0026lt;\u0026lt; qwerty[row1[i]].first \u0026lt;\u0026lt; \u0026quot; \u0026quot; \u0026lt;\u0026lt; qwerty[row1[i]].second \u0026lt;\u0026lt; \u0026quot; \u0026quot;;\r}\rcout \u0026lt;\u0026lt; endl;\rfor (int i = 0; i \u0026lt; (int)sizeof(row2); i++) {\rcout \u0026lt;\u0026lt; qwerty[row2[i]].first \u0026lt;\u0026lt; \u0026quot; \u0026quot; \u0026lt;\u0026lt; qwerty[row2[i]].second \u0026lt;\u0026lt; \u0026quot; \u0026quot;;\r}\rcout \u0026lt;\u0026lt; endl;\rfor (int i = 0; i \u0026lt; (int)sizeof(row3); i++) {\rcout \u0026lt;\u0026lt; qwerty[row3[i]].first \u0026lt;\u0026lt; \u0026quot; \u0026quot; \u0026lt;\u0026lt; qwerty[row3[i]].second \u0026lt;\u0026lt; \u0026quot; \u0026quot;;\r}\rcout \u0026lt;\u0026lt; endl;\r#endif\r// get input\rint T;\rchar txt[110];\rcin \u0026gt;\u0026gt; T;\rfor (int t = 0; t \u0026lt; T; t++) {\rcin \u0026gt;\u0026gt; txt;\r// calculate result\rint total_diff = 0;\rint pre_row = qwerty[txt[0]].first;\rint pre_col = qwerty[txt[0]].second;\rint idx = 1;\rwhile(txt[idx]) {\rint row = qwerty[txt[idx]].first;\rint col = qwerty[txt[idx]].second;\rint diff_row = abs(row - pre_row);\rint diff_col = abs(col - pre_col);\r// ↔ direction\rif (diff_row == 0) {\rtotal_diff += diff_col;\r}\r// ↕ direction\relse if (diff_col == 0) {\rtotal_diff += diff_row;\r}\r// ↙ direction\relse if (col \u0026lt; pre_col \u0026amp;\u0026amp; row \u0026gt; pre_row) {\rtotal_diff += max(diff_row, diff_col);\r}\r// ↗ direction\relse if (col \u0026gt; pre_col \u0026amp;\u0026amp; row \u0026lt; pre_row) {\rtotal_diff += max(diff_row, diff_col);\r}\r// ↘ direction\relse if (col \u0026gt; pre_col \u0026amp;\u0026amp; row \u0026gt; pre_row) {\rtotal_diff += diff_row + diff_col;\r}\r// ↖ direction\relse {\rtotal_diff += diff_row + diff_col;\r}\r# if DEBUG\rcout \u0026lt;\u0026lt; \u0026quot;row: \u0026quot; \u0026lt;\u0026lt; row \u0026lt;\u0026lt; \u0026quot; col: \u0026quot; \u0026lt;\u0026lt; col\r\u0026lt;\u0026lt; \u0026quot; diff_row: \u0026quot; \u0026lt;\u0026lt; diff_row \u0026lt;\u0026lt; \u0026quot; diff_col: \u0026quot; \u0026lt;\u0026lt; diff_col\r\u0026lt;\u0026lt; \u0026quot; idx: \u0026quot; \u0026lt;\u0026lt; idx \u0026lt;\u0026lt; \u0026quot; total_diff: \u0026quot; \u0026lt;\u0026lt; total_diff \u0026lt;\u0026lt; endl;\r# endif\r++idx;\rpre_row = row;\rpre_col = col;\r} // -\u0026gt; while\r// print result\rcout \u0026lt;\u0026lt; idx + total_diff * 2 \u0026lt;\u0026lt; endl;\r} // -\u0026gt; for\r} // -\u0026gt; main\r두 수의 곱이 최대가 나오도록 숫자 배정\n가장 큰 결과값이 나오도록 두 수를 정의하려면,\n높은 자리수가 낮은자리 수보다 값이 커야한다. (21 * 43 \u0026gt; 12 * 34) 두 수의 길이가 같을수록 두 수의 곱은 크다. (12 * 34 \u0026gt; 123 * 4) C++ Code\r#include \u0026lt;iostream\u0026gt;\r#include \u0026lt;cstring\u0026gt;\r#define DEBUG 0\rusing namespace std;\rint main(void) {\rint T = 0;\rcin \u0026gt;\u0026gt; T;\rfor (int t = 0; t \u0026lt; T; ++t) {\r// 1. get inputs\rchar card[20] = {0,};\rcin \u0026gt;\u0026gt; card;\rint card_len = strlen(card);\r# if DEBUG\rcout \u0026lt;\u0026lt; \u0026#34;len : \u0026#34; \u0026lt;\u0026lt; card_len \u0026lt;\u0026lt; endl;\r# endif\rint number[10] = {0,};\rfor (char c : card) {\rnumber[c - \u0026#39;0\u0026#39;] += 1;\r}\r// change all \u0026#39;6\u0026#39; into \u0026#39;9\u0026#39;\rnumber[9] += number[6];\rnumber[6] = 0;\r// 2. divide into two number\rint idx = 9;\rbool flag = false;\r// find max number\rwhile (number[idx] == 0) idx--;\rnumber[idx] -= 1;\runsigned long long num1 = idx;\runsigned long long num2 = 0;\rint l = 1;\rwhile (l \u0026lt; card_len) {\rwhile (number[idx] == 0) idx--;\rnumber[idx] -= 1;\r// 다음 숫자를 어디에 이어붙일지 결정\r// 이전 조합이 최적이라면, 아래 두 번의 비교를 통해 도출된 두 숫자 조합도 최적값임이 보장된다. unsigned long long cmp1 = (num1 * 10 + idx) * num2;\runsigned long long cmp2 = (num2 * 10 + idx) * num1;\rif (cmp1 \u0026gt; cmp2) {\rnum1 = num1 * 10 + idx;\r}\relse {\rnum2 = num2 * 10 + idx;\r}\r++l;\r/*\r// num1 : max, max-3, max-4, max-7, max-8 ...\r// num2 : max-1, max-2, max-5, max-6, ...\rfor (int i = 0; i \u0026lt; 2; ++i) {\rwhile (number[idx] == 0) idx--;\rnumber[idx] -= 1;\rif (flag) {\rnum1 = num1 * 10 + idx;\r}\relse {\rnum2 = num2 * 10 + idx;\r}\r# if DEBUG\rcout \u0026lt;\u0026lt; l \u0026lt;\u0026lt; \u0026#34; / num : \u0026#34; \u0026lt;\u0026lt; num1 \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; num2 \u0026lt;\u0026lt; endl;\r# endif\r// check condition\rl += 1;\rif (l \u0026gt;= card_len) break;\r} // -\u0026gt; for i\rflag = !flag;\r*/\r} // -\u0026gt; while card_len\rcout \u0026lt;\u0026lt; num1 * num2 \u0026lt;\u0026lt; endl;\r} // -\u0026gt; for T\r} ","permalink":"https://AswinBlue.github.io/post/algorithm/","summary":"Algorithm 그래프 탐색 SP(Shortest Path) 단일 출발점에서 단일 목적지까지 최단 경로를 찾는 알고리즘\nDFS 용도 : 경로가 있는지 확인할 때 사용 가능 자로구조 : stack 방법 : 시작 node를 stack에 넣는다. stack이 모두 빌때까지 아래 동작을 반복한다. stack의 top을 현재 node로 설정한다. 현재 node를 \u0026lsquo;visited\u0026rsquo; 처리하고 stack에서 제거한다. 다음으로 이동할 node가 있는지 확인한다. 다음으로 이동할 node \u0026lsquo;A\u0026rsquo;가 있다면, 현재 node에서 그다음에 탐색할 방향을 stack에 push하고, node \u0026lsquo;A\u0026rsquo;도 stack에 push한다. 더이상 갈 곳이 없으면 현재 node의 visited 처리를 복원한다.","title":"Algorithm"},{"content":"VS code visual studio code 사용법 개발환경 C / C++ 컴파일러 gcc 혹은 mingw 설치가 필요하다. 인터넷에서 설치하도록 한다. 설정파일 컴파일 및 실행을 위해서는 launch.json, setting.json, tasks.json 파일이 필요하다. vs code에서 알아서 작성해 주지만, 기본 설정으로 부족한 부분은 수정해야 한다. # settings.json\r{\r\u0026#34;C_Cpp_Runner.cStandard\u0026#34;: \u0026#34;\u0026#34;,\r\u0026#34;C_Cpp_Runner.cppStandard\u0026#34;: \u0026#34;\u0026#34;,\r\u0026#34;C_Cpp_Runner.msvcBatchPath\u0026#34;: \u0026#34;\u0026#34;,\r\u0026#34;C_Cpp_Runner.warnings\u0026#34;: [\r\u0026#34;-Wall\u0026#34;,\r\u0026#34;-Wextra\u0026#34;,\r\u0026#34;-Wpedantic\u0026#34;\r],\r\u0026#34;C_Cpp_Runner.enableWarnings\u0026#34;: true,\r\u0026#34;C_Cpp_Runner.warningsAsError\u0026#34;: false,\r\u0026#34;C_Cpp_Runner.compilerArgs\u0026#34;: [],\r\u0026#34;C_Cpp_Runner.linkerArgs\u0026#34;: [],\r\u0026#34;C_Cpp_Runner.includePaths\u0026#34;: [],\r\u0026#34;C_Cpp_Runner.includeSearch\u0026#34;: [\r\u0026#34;*\u0026#34;,\r\u0026#34;**/*\u0026#34;\r],\r\u0026#34;C_Cpp_Runner.excludeSearch\u0026#34;: [\r\u0026#34;**/build\u0026#34;,\r\u0026#34;**/build/**\u0026#34;,\r\u0026#34;**/.*\u0026#34;,\r\u0026#34;**/.*/**\u0026#34;,\r\u0026#34;**/.vscode\u0026#34;,\r\u0026#34;**/.vscode/**\u0026#34;\r],\r\u0026#34;C_Cpp_Runner.cCompilerPath\u0026#34;: \u0026#34;gcc\u0026#34;,\r\u0026#34;C_Cpp_Runner.cppCompilerPath\u0026#34;: \u0026#34;C:/Program Files (x86)/mingw-w64/i686-8.1.0-posix-dwarf-rt_v6-rev0/mingw32/bin/g++.exe\u0026#34;,\r\u0026#34;C_Cpp_Runner.debuggerPath\u0026#34;: \u0026#34;C:/Program Files (x86)/mingw-w64/i686-8.1.0-posix-dwarf-rt_v6-rev0/mingw32/bin/gdb.exe\u0026#34;,\r\u0026#34;files.associations\u0026#34;: {\r\u0026#34;hash_map\u0026#34;: \u0026#34;cpp\u0026#34;\r}\r} # launch.json\r{\r\u0026#34;version\u0026#34;: \u0026#34;0.2.0\u0026#34;,\r\u0026#34;configurations\u0026#34;: [\r{\r\u0026#34;name\u0026#34;: \u0026#34;C/C++ Runner: Debug Session\u0026#34;,\r\u0026#34;type\u0026#34;: \u0026#34;cppdbg\u0026#34;,\r\u0026#34;request\u0026#34;: \u0026#34;launch\u0026#34;,\r\u0026#34;args\u0026#34;: [],\r\u0026#34;stopAtEntry\u0026#34;: false,\r\u0026#34;cwd\u0026#34;: \u0026#34;f:/Documents/GitHub/acmicpc/15997\u0026#34;,\r\u0026#34;environment\u0026#34;: [],\r\u0026#34;program\u0026#34;: \u0026#34;동작시킬 프로그램 경로\u0026#34;,\r\u0026#34;internalConsoleOptions\u0026#34;: \u0026#34;openOnSessionStart\u0026#34;,\r\u0026#34;MIMode\u0026#34;: \u0026#34;gdb\u0026#34;,\r\u0026#34;miDebuggerPath\u0026#34;: \u0026#34;C:/Program Files (x86)/mingw-w64/i686-8.1.0-posix-dwarf-rt_v6-rev0/mingw32/bin/gdb.exe\u0026#34;,\r\u0026#34;externalConsole\u0026#34;: false,\r\u0026#34;setupCommands\u0026#34;: [\r{\r\u0026#34;description\u0026#34;: \u0026#34;Enable pretty-printing for gdb\u0026#34;,\r\u0026#34;text\u0026#34;: \u0026#34;-enable-pretty-printing\u0026#34;,\r\u0026#34;ignoreFailures\u0026#34;: true\r}\r]\r}\r]\r} # tasks.json\r{\r// See https://go.microsoft.com/fwlink/?LinkId=733558\r// for the documentation about the tasks.json format\r\u0026#34;version\u0026#34;: \u0026#34;2.0.0\u0026#34;,\r\u0026#34;tasks\u0026#34;: [\r{\r\u0026#34;type\u0026#34;: \u0026#34;shell\u0026#34;,\r\u0026#34;label\u0026#34;: \u0026#34;execute\u0026#34;,\r\u0026#34;command\u0026#34;: \u0026#34;${fileDirname}/${fileBasenameNoExtension}.exe\u0026#34;,\r\u0026#34;group\u0026#34;: {\r\u0026#34;kind\u0026#34;: \u0026#34;test\u0026#34;,\r\u0026#34;isDefault\u0026#34;: true\r},\r\u0026#34;problemMatcher\u0026#34;: []\r},\r{\r\u0026#34;type\u0026#34;: \u0026#34;cppbuild\u0026#34;,\r\u0026#34;label\u0026#34;: \u0026#34;C/C++: g++.exe 활성 파일 빌드\u0026#34;,\r\u0026#34;command\u0026#34;: \u0026#34;C:\\\\Program Files (x86)\\\\mingw-w64\\\\i686-8.1.0-posix-dwarf-rt_v6-rev0\\\\mingw32\\\\bin\\\\g++.exe\u0026#34;,\r\u0026#34;args\u0026#34;: [\r\u0026#34;-fdiagnostics-color=always\u0026#34;,\r\u0026#34;-g\u0026#34;,\r\u0026#34;${file}\u0026#34;,\r\u0026#34;-o\u0026#34;,\r\u0026#34;${fileDirname}\\\\${fileBasenameNoExtension}.exe\u0026#34;\r],\r\u0026#34;options\u0026#34;: {\r\u0026#34;cwd\u0026#34;: \u0026#34;${fileDirname}\u0026#34;\r},\r\u0026#34;problemMatcher\u0026#34;: [\r\u0026#34;$gcc\u0026#34;\r],\r\u0026#34;group\u0026#34;: \u0026#34;build\u0026#34;,\r\u0026#34;detail\u0026#34;: \u0026#34;컴파일러: \\\u0026#34;C:\\\\Program Files (x86)\\\\mingw-w64\\\\i686-8.1.0-posix-dwarf-rt_v6-rev0\\\\mingw32\\\\bin\\\\g++.exe\\\u0026#34;\u0026#34;\r}\r]\r} 단축키 Ctrl + Shift + P 단축키로 명령을 일일이 수행해도 되지만, 단축키를 설정해 바로 실행하는게 빠르다. 파일 -\u0026gt; 기본설정 -\u0026gt; 바로가기키 (Ctrl + K \u0026amp; Ctrl + S) 를 누르고, 우측 상단 \u0026lsquo;바로가기 키 열기\u0026rsquo; 를 클릭하여 단축키를 직접 입력한다. // 키 바인딩을 이 파일에 넣어서 기본값 재정의\r[\r{\r\u0026#34;key\u0026#34;: \u0026#34;ctrl+alt+c\u0026#34;,\r\u0026#34;command\u0026#34;: \u0026#34;workbench.action.tasks.build\u0026#34;,\r},\r{\r\u0026#34;key\u0026#34;: \u0026#34;ctrl+alt+e\u0026#34;,\r\u0026#34;command\u0026#34;: \u0026#34;workbench.action.tasks.test\u0026#34;,\r}\r] ","permalink":"https://AswinBlue.github.io/post/vscode/","summary":"VS code visual studio code 사용법 개발환경 C / C++ 컴파일러 gcc 혹은 mingw 설치가 필요하다. 인터넷에서 설치하도록 한다. 설정파일 컴파일 및 실행을 위해서는 launch.json, setting.json, tasks.json 파일이 필요하다. vs code에서 알아서 작성해 주지만, 기본 설정으로 부족한 부분은 수정해야 한다. # settings.json\r{\r\u0026#34;C_Cpp_Runner.cStandard\u0026#34;: \u0026#34;\u0026#34;,\r\u0026#34;C_Cpp_Runner.cppStandard\u0026#34;: \u0026#34;\u0026#34;,\r\u0026#34;C_Cpp_Runner.msvcBatchPath\u0026#34;: \u0026#34;\u0026#34;,\r\u0026#34;C_Cpp_Runner.warnings\u0026#34;: [\r\u0026#34;-Wall\u0026#34;,\r\u0026#34;-Wextra\u0026#34;,\r\u0026#34;-Wpedantic\u0026#34;\r],\r\u0026#34;C_Cpp_Runner.enableWarnings\u0026#34;: true,\r\u0026#34;C_Cpp_Runner.warningsAsError\u0026#34;: false,\r\u0026#34;C_Cpp_Runner.compilerArgs\u0026#34;: [],\r\u0026#34;C_Cpp_Runner.linkerArgs\u0026#34;: [],\r\u0026#34;C_Cpp_Runner.includePaths\u0026#34;: [],\r\u0026#34;C_Cpp_Runner.includeSearch\u0026#34;: [\r\u0026#34;*\u0026#34;,\r\u0026#34;**/*\u0026#34;\r],\r\u0026#34;C_Cpp_Runner.","title":"VsCode"},{"content":"C++ STL 자료구조 map key-value 쌍으로 이루어진 tree형태의 자료구조 중복을 허용하지 않음 C++에서는 red black tree로 구현되어 삽입,삭제가 O(log n) 안에 이루어진다. 내부적으로 key를 기준으로 오름차순으로 자료를 정렬한다. 헤더 : #include \u0026lt;map\u0026gt;\n선언 : map\u0026lt;int, int\u0026gt; map1;\n내림차순으로 선언 : map \u0026lt;int, int, greater\u0026gt; map2 삽입 : insert : map1.insert({\u0026quot;key\u0026quot;,VALUE}) [] : map1[\u0026quot;key\u0026quot;] = VALUE 삭제 : 특정 index : map1.erase(map1.begin()+2) 특정 key : map1.erase(KEY) 구간 : map1.erase(map1.begin(), map1.end()) 전체 : map1.clear() 검색 : map\u0026lt;int, int\u0026gt;::Iterator res;\rif ((res = map1.find(KEY)) != m.end()) {\rres -\u0026gt; first; // key\rres -\u0026gt; second; // value\r} 반복문 : for (auto itr = map1.begin(); itr != map1.end(); itr++) {\ritr-\u0026gt;first // key\ritr-\u0026gt;second // value\r} hash map hash table을 이용한 자료구조 정렬이 필요없는 비순차적 구조 헤더 : #include\u0026lt;hash_map\u0026gt;\n선언 : hash_map\u0026lt;int, float\u0026gt; h1\n삽입 :\ninsert 구문 : h1.insert(hash_map\u0026lt;int, float\u0026gt;::value_type(1,2.0f)) [] 구문 : h1[1] = 2.0f 검색 : hash_map\u0026lt;int, float\u0026gt;::Iterator res;\rif ((res = h1.find(10)) != h1.end()) {\rres-\u0026gt;first; // key\rres-\u0026gt;second; // value\r} 반복문 for (auto itr = h1.begin(); itr != h1.end(); itr++) {\ritr-\u0026gt;first; // key\ritr-\u0026gt;second; // value\r} 삭제 : 특정 index : h1.erase(h1.begin()) 특정 key : h1.erase(1) 구간 : h1.erase(h1.begin(), h1.end()) 전체 : h1.clear() Heap 헤더: #include\u0026lt;queue\u0026gt; 선언: min queue : priority_queue\u0026lt;int, vector\u0026lt;int\u0026gt;, greater\u0026lt;int\u0026gt;\u0026gt; Heap max queue : priority_queue\u0026lt;int, vector\u0026lt;int\u0026gt;, less\u0026lt;int\u0026gt;\u0026gt; Heap greater, less가 반대로 되어있음에 주의한다. 활용: Heap.push() : 삽입 Heap.top() : 가장 작은/큰 값 Heap.pop() : top 값을 삭제 Heap.size() : 인자 개수 Heap.empty() : size가 1 이상이면 false, 아니면 true 정렬 stable_sort 오름차순 혹은 내림차순으로 정렬하되, 같은 값의 경우 기존의 순서를 유지하는 정렬방식 int v[10];\rint idx[10];\r// 오름차순 정렬\rstable_sort(idx, idx + 10, [](int a, int b){return a \u0026gt; b;});\r// index를 이용한 정렬\rstable_sort(idx, idx + 10, [\u0026amp;v](int a, int b){return v[a] \u0026gt; v[b];}); ","permalink":"https://AswinBlue.github.io/post/c++_stl/","summary":"C++ STL 자료구조 map key-value 쌍으로 이루어진 tree형태의 자료구조 중복을 허용하지 않음 C++에서는 red black tree로 구현되어 삽입,삭제가 O(log n) 안에 이루어진다. 내부적으로 key를 기준으로 오름차순으로 자료를 정렬한다. 헤더 : #include \u0026lt;map\u0026gt;\n선언 : map\u0026lt;int, int\u0026gt; map1;\n내림차순으로 선언 : map \u0026lt;int, int, greater\u0026gt; map2 삽입 : insert : map1.insert({\u0026quot;key\u0026quot;,VALUE}) [] : map1[\u0026quot;key\u0026quot;] = VALUE 삭제 : 특정 index : map1.erase(map1.begin()+2) 특정 key : map1.erase(KEY) 구간 : map1.erase(map1.begin(), map1.end()) 전체 : map1.","title":"C++_stl"},{"content":"#MS Window\nMS window 사용시 필요한 편이 기능들을 나열 WSL2 윈도우에서 리눅스를 실행하는 방법이다. windows 10 이상부터 지원 가능하며, microsoft store에서 ubuntu를 설치하는 방식이다. PowerShell을 관리자 권한으로 실행하여 아래 명령어 입력 $ dism.exe /online /enable-feature /featurename:Microsoft-Windows-Subsystem-Linux /all /norestart\n$ dism.exe /online /enable-feature /featurename:VirtualMachinePlatform /all /norestart\n$ wsl \u0026ndash;set-default-version 2\n환경변수 환경변수 설정시 컴퓨터를 재부팅하지 않고 적용하는 방법 콘솔에 taskkill /f /im explorer.exe, explorer.exe 명령을 순서대로 입력한다. 작업표시줄이 없어졌다 생겨나면 적용이 된 것이다. 켜져있던 탐색기는 복원되지 않으니 주의 batch call 기본 command가 아닌 package command를 수행할 경우, batch파일에 명령어를 그대로 넣어서 수행하면 첫번째 줄만 수행될 수 있다. 이때 call 명령어를 사용해주면 여러 라인을 실행 가능하다. ex) call npm run build\rcd server\rcall gradle wrapper ","permalink":"https://AswinBlue.github.io/post/window/","summary":"#MS Window\nMS window 사용시 필요한 편이 기능들을 나열 WSL2 윈도우에서 리눅스를 실행하는 방법이다. windows 10 이상부터 지원 가능하며, microsoft store에서 ubuntu를 설치하는 방식이다. PowerShell을 관리자 권한으로 실행하여 아래 명령어 입력 $ dism.exe /online /enable-feature /featurename:Microsoft-Windows-Subsystem-Linux /all /norestart\n$ dism.exe /online /enable-feature /featurename:VirtualMachinePlatform /all /norestart\n$ wsl \u0026ndash;set-default-version 2\n환경변수 환경변수 설정시 컴퓨터를 재부팅하지 않고 적용하는 방법 콘솔에 taskkill /f /im explorer.exe, explorer.exe 명령을 순서대로 입력한다. 작업표시줄이 없어졌다 생겨나면 적용이 된 것이다.","title":"Window"},{"content":"Firebase with React react에서 firebase를 활용하는 방법 firebase SDK를 설치하거나 웹상에서 설치없이 사용하는 방법은 firebase 기본을 참조 인증 (Auth) firebase 로 계정 생성 및 로그인 firebase API를 import하여 사용 \u0026lt;AppFirebase.js\u0026gt; import firebase from \u0026#34;firebase/compat/app\u0026#34;;\rimport \u0026#34;firebase/compat/auth\u0026#34;;\rconst firebaseConfig = {\rapiKey: process.env.REACT_APP_API_KEY,\rauthDomain: process.env.REACT_APP_AUTHDOMAIN,\rprojectId: process.env.REACT_APP_PROJECTID,\rstorageBucket: process.env.REACT_APP_STORAGEBUCKET,\rmessagingSenderId: process.env.REACT_APP_MESSAGINGSENDERID,\rappId: process.env.REACT_APP_APPID\r};\rexport default firebase.initializeApp(firebaseConfig);\rexport const authService = firebase.auth(); AppFirebase.js 를 활용하여 business logic에 필요한 로그인 / 회원가입 기능을 구현 \u0026lt;Auth.js\u0026gt; import { authService } from \u0026#34;../components/AppFirebase\u0026#34;;\rconst data = await authService.createUserWithEmailAndPassword(email, password) // email, passwd로 계정 생성\rconst data = await authService.signInWithEmailAndPassword(email, password) // email, passwd로 로그인 createUserWithEmailAndPassword / signInWithEmailAndPassword 실행 이후 authService.currentUser를 참조하면 user 정보를 받아올 수 있다. 하지만, authService.currentUser 정보를 갱신하는데는 시간이 걸린다. firebase API에서는 observer를 등록하여 currentUser의 변경 시점을 확인할 수 있다. currentUser 변경시점에 특정함수 동작 user 정보가 갱신된 시점에 특정 동작을 원한다면, 아래와 같이 onAuthStateChanged 함수를 사용하면 된다. authService.onAuthStateChanged((user) =\u0026gt; { /* something to do */ }}); 로그아웃 authService.signOut() 함수를 호출하여 로그아웃이 가능하다. 참고로 크롬 웹 디버깅 화면에서 \u0026lsquo;Application\u0026rsquo;탭에 들어가서 IndexedDB -\u0026gt; firebaseLocalDb 안의 내용을 🚫버튼으로 삭제해 주면 로그인 정보가 사라진다. 에러 authService의 함수(createUserWithEmailAndPassword, signInWithEmailAndPassword, \u0026hellip;) 사용시 에러가 발생할 수 있으므로, try, catch문으로 묶어서 사용한다. try {\rlet data\rdata = await authService.createUserWithEmailAndPassword(email, password)\r} catch(error) {\rconsole.log(error.code) // 에러의 원인이 코드 형태로 출력된다.\rconsole.log(error.message) // 에러의 원인이 메시지 형태로 출력된다.\r} ref) 오류발생 원인\n6자리 이하로 비밀번호 생성시 동일한 e-mail로 계정 생성시 Google 계정으로 로그인 firebase에서는 google, facebook 등 계정으로 로그인 할 수 있도록 기능을 제공한다. 팝업으로 로그인을 유도하는 방식과, redirect로 로그인하는 방식이 있다. import { authService, firebaseModule } from \u0026#34;../components/AppFirebase\u0026#34;;\rconst onSocialClick = async (event) =\u0026gt; {\rtry {\rlet provider;\rprovider = new firebaseModule.auth.GoogleAuthProvider(); //\r} catch (error) {\rconsole.log(error);\r}\rawait authService.signInWithPopup(provider); // 팝업으로 로그인\r} ","permalink":"https://AswinBlue.github.io/post/firebase_react/","summary":"Firebase with React react에서 firebase를 활용하는 방법 firebase SDK를 설치하거나 웹상에서 설치없이 사용하는 방법은 firebase 기본을 참조 인증 (Auth) firebase 로 계정 생성 및 로그인 firebase API를 import하여 사용 \u0026lt;AppFirebase.js\u0026gt; import firebase from \u0026#34;firebase/compat/app\u0026#34;;\rimport \u0026#34;firebase/compat/auth\u0026#34;;\rconst firebaseConfig = {\rapiKey: process.env.REACT_APP_API_KEY,\rauthDomain: process.env.REACT_APP_AUTHDOMAIN,\rprojectId: process.env.REACT_APP_PROJECTID,\rstorageBucket: process.env.REACT_APP_STORAGEBUCKET,\rmessagingSenderId: process.env.REACT_APP_MESSAGINGSENDERID,\rappId: process.env.REACT_APP_APPID\r};\rexport default firebase.initializeApp(firebaseConfig);\rexport const authService = firebase.auth(); AppFirebase.js 를 활용하여 business logic에 필요한 로그인 / 회원가입 기능을 구현 \u0026lt;Auth.","title":"Firebase_react"},{"content":"Cryptocurrency Cryptographic Hash function hash function은 아래와 같은 속성을 갖는다. 모든 크기의 String을 input 으로 받는다. 정해진 크기의 output을 생성한다. (bitcoin에서는 256bit) 적당한 시간 안에 계산이 가능하다. (계산 시간이 너무 길지 않다) cryptographic hash function은 아래와 같은 security 속성을 추가로 갖는다.\ncollision-free hiding puzzle-friendly 속성1. collision-free x != y 라면, H(x) = H(y) 인 경우를 찾을 수 없어야 한다. 이 말은 collision 이 존재하지 않는다는 뜻은 아니다. num(possible_input) \u0026gt; num(possible_outputs) 이다. \u0026lsquo;찾을 수 없다\u0026rsquo; 라는 말은, collision이 존재하지만, hahs function의 결과를 예측할 수 없다는 뜻이다. 실제로, 2^130 개의 무작위 수를 선택하여 hash function을 돌렸을 때, 99.8%의 확률로 충돌이 발생한다. 하지만 이 수치는 천문학적으로 크기 때문에 걱정할 필요가 없다. (collision을 발견할 확률은 인류가 만든 최고의 컴퓨터로 우주 생성시부터 계산을 해도, 2초뒤 지구에 운석이 떨어질 확률만큼 낮다.) collision을 쉽게 구하는 방법이 있는가? -\u0026gt; 특정 hash function에 대해서는(SHA256에 대해서도 최단기간 collision을 찾아내는 방법이 알려져 있다.) 가능하지만, 대부분은 그렇지 않다. hash as message digest collision을 구하는 것이 매우 어렵기 때문에, H(x) = H(y)라면, x = y라고 확신해도 된다. 즉, hash를 이용해 데이터 전송/비교에 드는 비용을 절감 가능하다. (전체 message 대신 hash만 비교) 속성2. hiding H(x)를 갖고 x를 유추할 수 없다. hiding 속성을 가지려면 아래와 같은 방법을 사용한다. high min-entropy 를 가진 무작위 상수 \u0026lsquo;r\u0026rsquo;을 x와 조합(concatenate)하여 hash function의 input에 넣으면 hiding 속성을 갖게 된다. (H(r|x)) high min-entropy 란 넓고 고르게 퍼져있음을 뜻한다. 즉, 넓은 선택범위 안에서 특정 값이 특출나게 여려번 중복해서 뽑히지 않는다는 뜻이다. (no particular value is chosen with more than negligible probability) commitment 편지를 동봉하듯 데이터가 가지고 있는 내용을 공개하지 않고 데이터를 공개하는 것\ncommitment를 위해 제공하는 commitment API 는 다음과 같이 동작한다.\n(commitment, key) = commit(msg) msg를 동봉하고, 그 결과로 commitment와 key를 생성한다. commitment는 봉투에 해당하고, key는 열쇠에 해당한다. commit은 hash function으로 다음과 같이 구성된다. commit(msg) = (H(key | msg), key) 즉, (commitment, key) = H(key|msg), key 이다. match = verify(commitment, key, msg) commitment, key, msg 세가지를 이용해 msg가 올바른지 검증한다. commitment는 두 가지 security property를 갖는다.\nhiding : commitment만으로 msg를 파악할 수 없다.\nbinding : msg1 != msg2 라면, verify(commit(msg1),msg2) != false 이다.\n속성3. puzzle-friendly 임의의 \u0026lsquo;k\u0026rsquo;가 high min-entropy 속성을 갖고 있다면, H(k|x) = y 를 만족시키는 x를 찾을 수 없다. 즉, 특정 값 y가 나오도록 x를 임의로 조작할 수 없다는 뜻이다. 앞서 말한 hash function으로는 여러가지 종류들이 있다. 그중 SHA-256에 대해 살펴보자.\nSHA-256 동작 방법은 아래와 같다. message를 512bit씩 잘라서, 256bit의 데이터\u0026rsquo;IV\u0026rsquo;와 함께 hashing 연산 \u0026lsquo;C\u0026rsquo;을 수행한다. 위 결과와 다음 256bit 메시지를 다시 \u0026lsquo;C\u0026rsquo;연산시킨다. 이를 메시지 끝까지 반복한다. 마지막 메시지가 256bit가 되지 않는다면 (10*|length) 로 이루어진 padding을 집어넣어 연산한다. collision-free를 만족하기 때문에 \u0026lsquo;C\u0026rsquo; 연산 각각도 collision-free이다. Hash Pointer data structure의 hash와 동일하게, hash pointer는 특정 데이터를 가리키는 pointer이다. 다만, 데이터는 info와 cryptographic hash를 포함한다. hash pointer를 이용하면 데이터와, 데이터의 변경여부를 확인할 수 있다. hash pointer를 이용하여 다양한 data structure를 구성할 수 있다. hash pointer를 이용해 linked list를 구성하면 흔히 block chain이라 불리는 구조가 형성된다. linked-list의 block 하나가 \u0026lsquo;주소 + 데이터\u0026rsquo; 로 이루어져 있는데, block chain 에서는 \u0026lsquo;주소\u0026rsquo; 부분이 이전 block의 hash값(hash + data 의 hash값)으로 구성되어 있다. ex) H(root) - B1[data1, H(B2)] - B2[data2, H(B3)] - B3[data3, H(B4)] ... hash값을 이용하여 다음 데이터가 수정이 이루어졌는지 확인 가능하다. (tamper-evident) data3을 수정하면 H(B3)값과 B2의 H()값이 일치하지 않게 된다. B2의 H()값을 수정하면 이번에는 H(B2)와 B1의 H()값이 일치하지 않는다. 연쇄적으로 B2, B1, root까지 수정하면 다시 모든 hash값이 맞아 떨어지게 된다. 가장 최초의 block을 \u0026lsquo;genesis block\u0026rsquo;이라 부른다. hash pointer로 binary tree를 구성할 수도 있다. (Merkle tree) tree의 leaf node에는 data가 들어가고, 이후 root node 포함 모든 node들은 left\u0026amp;right 자식 node들의 hash값을 갖게 된다. 데이터가 변경되면, 부모 node의 hash값이 연쇄적으로 어긋나게 되고, 최종적으로 root node의 hash값 R과 달라지게 된다. (H(root) 값을 기억하면 데이터 변경을 감지할 수 있게 된다.) 데이터 검증을 위해 모든 block들을 사용해야 했던 기존 block chain과 다르게, Merkle tree는 O(log n) 개의 node만으로도 데이터 무결성을 증명할 수 있다. 검증 시간 및 검색, 정렬 시간이 직렬 데이터 구조보다 절감된다. hash pointer는 cycle이 없는 모든 pointer-based data structure에 사용 가능하다. Digital Signature Digital Signature 은 아래와 같은 속성을 지녀야 한다. only you can sign, but anyone can verify : 본인만 사용 가능하며 본인임을 인증할 수 있어야 한다. tied to a particular document : 서명과 인증할 대상이 분리 불가능해야 한다. digital signature의 API는 아래와 같을 것이다. (secret_key, public_key) := generateKeys(size_of_key) : Key를 생성하는 함수. randomize 되어있어야 한다. sig := sign(secret_key, message) : 특정 message에 서명을 하는 함수 마찬가지로 randomize가 잘 되어있어야 한다. message의 길이가 너무 길면 처리하기 힘드므로, Hash function의 collision-free 특성을 이용해 message의 hash 값을 쓰도록 한다. isValid := verify(public_key, message, sig) : public key와 message, sig의 조합으로 알맞은 서명인지 검증하는 함수 Requirements for signature 위 API로 만든 signature의 조건으로는 아래 두가지가 있다. public_key, sig, message로 message가 당신의 것임을 인증 가능 다른 이가 당신의 public_key, sig를 이용해 다른 message′ 에 서명을 할 수 없어야 한다. secret_key 를 공개하지 않고, public key를 타인에게 공개한 후, 수 많은 message [m0, m1, m2, \u0026hellip;] 에 대해 서명을 한 결과 [sign(m0), sign(m1), sign(m2), \u0026hellip;]를 타인에게 주었을 때, 그 사람이 새로운 메시지 m′에 대한 서명 sign(m′)을 만들어 낼 확률은 극히 낮아야 한다. + Hash pointer를 sign하면, hash pointer 뿐만 아니라, pointer가 가리키는 전체 구조를 sign하는 효과를 얻을 수 있다. + bitcin은 ECDSA(Elliptic Curve Digital Signature Algorithm) 표준을 사용한다.\nPublic Keys \u0026amp; Secret Keys public key는 개인을 식별할 수 있는 \u0026lsquo;식별자\u0026rsquo;이다. public key는 모두에게 공개되며, public key로 개개인을 구분할 수 있다. secret key는 public key로 특정 발언을 할 수 있는 \u0026lsquo;권한\u0026rsquo; 이다. public key 와 secret key는 pair로 존재하며, \u0026lsquo;identity\u0026rsquo; (고유함)를 구성한다. identity는 아무 때나, 몇개든 만들 수 있으며, 모든 identity를 관리하기위한 중앙 체제가 필요없다. (decentralized) 다만, 랜덤 요소가 약하다면 다수의 public key와 message를 통해 secret key가 유출될 가능성이 있음에 주의한다. 이러한 속성 덕분에 bitcoin에서도 identity를 \u0026lsquo;address\u0026rsquo; 라는 용어로 사용한다. address 는 탈 중앙화로 동작하지만, 개인이 만든 address는 즉시 identity 속성을 갖지는 못한다. address가 identity 속성을 갖게 하기 위해서는 다른 address들과 엮어야 하는데, observer가 주기적으로 이 동작을 수행하도록 해야한다. address를 추적하면 address 명의로 수행한 행위들을 추출할 수 있는데, 이 내용으로 특정 개인을 추정할 수 있는 취약점이 있다. Cryptocurrency CryptoCurrency(이하 coin)에는 다음과 같은 조건이 필요하다. public key, unique coin id 를 이용해 coin을 만들 수 있어야 한다. A 가 unique coin id 를 인자로 coin을 만들고, 이를 public key로 sign하는 방식으로 coin을 생성한다.([pk_A, createCoin(unique_coin_id)]) coin은 다른 사람에게 전달 가능해야 한다. A 가 B 에게 coin을 전달한다고 할 때, 만들어진 coin을 가리키는 거래내역 block을 생성한다. [pk_A, pay_to(pk_B)] -\u0026gt; [pk_A, createCoin(unique_coin_id)]\npay_to 블럭의 hash pointer가 createCoin 블럭을 가리킨다. 이러면 coin의 소유자가 A에서 B로 넘어간 것이다. 이후 B가 C로 coin을 전달하면 [pk_B, pay_to(pk_C)] -\u0026gt; [pk_A, pay_to(pk_B)] -\u0026gt; [pk_A, createCoin(unique_coin_id)] 형태가 될 것이다.\n모든 chain을 따라가면 coin이 누구의 소유인지 확인 가능하다.\ndouble spending attack coin의 chain은 직렬로 이루어져야 한다. 만약 branch가 생겨나면 소유권이 꼬이게 된다. 아래와 같이 B가 특정 coin을 두번 이상 spend 하는 형태가 발생할 수 있다. [pk_B, pay_to(pk_C)] [pk_B, pay_to(pk_D)]\r↓ ↓\r[pk_A, pay_to(pk_B)]\r↓\r[pk_A, createCoin(unique_coin_id)] 이러한 경우, 이 코인은 secure하지 않기 때문에 cryptoCurrency로서는 좋지 않다.\ndouble spending attack을 해소하려면 history를 관리하면 된다.\nhistory는 위에서 살펴본 block chain(hash pointer를 이용한 linked list) 형태로 구성한다.\n거래내역(transactions) 들을 content로 갖는 block들 생성하고, 이를 hash pointer로 연결한다. (보통 한 block 안에는 다수의 transaction들을 포함한다.) 관리자가 root hash 및 block들을 public key로 인증하여 publish하면, history가 관리되어 안정성이 확보된다. H() -\u0026gt; ... -\u0026gt; [H(), transaction3] -\u0026gt; [H(), transaction2] -\u0026gt; [H(), transaction1] transaction들은 관리자에 의해 publish되어야 한다. (pk로 sign)\ntransaction들은 다음과 같이 구성된다.\ncreate coin value와 recipient를 설정한다. 생성한 coin에 고유 id를 붙인다. (trainsaction Id + index로 조합) pay consume -\u0026gt; create 작업을 수행한다. consume은 coin id를 이용해 coin을 폐기하는 작업이다. create 작업은 create coin과 동일하다. 작업을 수행하기 전 다음 사항들을 validate 하고 수행한다. 1) consume하는 coin이 valid한지 체크 2) consume 하는 coin이 이미 consume되지 않았는지 체크(not double spend) 3) consume 되는 양과 create 되는 양이 같은지 체크 4) consume 되는 coin들은 각 owner에 의해 sign 되어있는지 체크 - 모든 사항이 확인되면 관리자에 의해 publish된다. -\u0026gt; double spending 문제는 해결했지만 centralization 문제가 발생한다. (\u0026lsquo;관리자\u0026rsquo; 가 중앙 체제에 해당)\nDecentralization Crypto currency를 구성하기 위해서는 탈 중앙화가 이루어져야 한다. 앞서 보았듯이 거래 장부(transaction)를 관리하기 위해서는 이를 인증해 줄 주체가 필요했다. 이 주체를 분산시키는 것이 필요하다. (Distributed Consensus) Dsitributed Consensus 분산의 개념은 암호화 회폐 이전에 서버 동작에서도 논제가 되었다. 여러개의 서버가 병렬로 동작할 때, consistency를 유지하기 위해 distributed consensus protocol이 필요했다. 방법중 하나로 distributed key-value store 방식이 있는데, DNS, public key directory, stock trade 등 여러 방면에서 사용되고 있고, altcoin에도 사용되고 있다. public consensus in crypto currency 암호화 화폐에서는 transaction가 모여 block을 이루고, 이를 모아 block chain을 만든다.\nblock chain에 들어간 모든 block들은 consensus된 내용들이어야 한다.\ntransaction 하나를 consensus 해도 괜찮지만, block 단위로 consensus하여 효율을 높인다.\npeer to peer 통신은 완벽하지 않기 때문에 여러개의 각기 다른 block들을 비교해야 한다.\n비교한 block들 중 특정 block을 block chain 에 추가하면, 어떤 transaction은 빠질 수도 있는데, 이는 다음번 consensus때 까지 대기해야 한다.\nNode간 충돌은 consensus protocol이 쉽지 않은 이유중 하나이다. 모든 Node들이 연결되어 있지 않기 때문에 Node간 충돌은 불가피하다. network latency 혹은 fault도 Node간 차이를 발생하는 원인이 된다. Byzantine general problems 는 consensus problem 중 하나이다. Fischer-Lynch-Paterson impossibility result 라는 이름의 증명은 하나의 fault만 존재해도 consensus는 불가능하다는 것을 증명한 내용이다.\n그럼에도 불구하고 대표적인 consensus protocol들이 있다. 그중 하나는 Paxos 프로토콜이다.\nPaxo 프로토콜은 inconsistent 한 상황은 절대 발생시키지 않지만, 특정한 상황이 되면 dead-lock 처럼 로직이 멈춰 더이상 동작하지 않는 상태가 발생할 수 있다. 현실 bitcoin에서는 이론에 비해 consensus가 더 잘 이루어지고 있다. 이론은 아직 실제 현상을 따라잡아 가는 형태이지만, 여전히 이론은 예상치 못한 공격에 대한 대응과 bitcoin 생태계에서의 확신을 주기 위한 존재로서 중요하다.\n현실의 bitcoin에서는 어떤점이 다른가?\nbitcoin에서는 insentive의 개념이 있다. 정직하게 활동한 참여자에게는 insentive를 줌으로써 시스템에 우호적으로 활동할 계기를 준다.\n이는 bitcoin이 currency의 개념이기 때문에 가능하며, 이번의 모든 distributed consensus system 에서는 없었던 개념이다.\ninsentive를 통해 bitcoin은 distributed consensus system를 근본적으로 해결하지 않았지만, 해결책을 찾은 셈이다.\nconsensus system은 즉각적이지 않고, consensus를 수행하는데도 약 1시간 정도가 소요된다. 하지만 시간이 지날수록 transaction이 반영되지 않거나 잘못될 확률은 exponential하게 줄어들게 된다.\nconsensus without identity bitcoin에서는 persistent long term identities 없이 consensus가 이루어진다. 즉, node를 칭할 수 있는 identity가 없다.\nidentity가 있다면 다음과 같은 이점이 있다.\n실용성(pragmatic) : 프로토콜에서 id를 이용한 로직을 사용할 수 있다. 보안(security) : 특정 인물의 malicious한 행동을 tracking 가능하다. 그럼에도 불구하고 bitcoin에서 identity를 사용하지 않는 이유는 p2p system의 한계 때문이다.\np2p는 중앙 체제가 없기 때문에 인정받은 identity를 갖기 어렵다. bitcoin 자체가 현실의 identity를 사용하는 것을 원하지 않는다. (특정 node에서 이루어지는 transaction들은 구분할 수 있지만, 그 node가 현실의 누구 것인지는 알 수 없다.) 이러한 identity가 없는 특징 때문에 p2p network는 Sybil attack에 취약하다. Sybil attack : 한 명이 가상의 node들을 다수로 만들어 마치 여러 사람인 것 처럼 보이게 하는 것. weaker assumption node마다 identity를 부여하고, 이 부여받은 identity를 검증하는 작업은 매우 복잡하다.\nauthenticated 된 identity를 부여하는 것 대신 랜덤한 token을 node에 부여한다.\ntoken으로 특정 node를 구분할 수 있으며, 특정 사용자가 여러 node들을 만드려 할 경우 해당 node들에 동일한 token을 부여하는 방식으로 Sybil attack을 방지할 수도 있다.\nimplicit consensus : 매 round마다 random node가 선택되고, 이 node는 block chain에 들어갈 다음 block을 추천하는 방식.\n이 추천은 일방적이며, consensus 알고리즘이나 투표같은게 없다. 다른 node들은 implicitly 하게 이 block을 수락하거나 거절함으로써 malicious한 node의 행위를 막을 수 있다. implicitly 하다는 뜻은, 직접적으로 투표를 행하지는 않지만, 해당 block을 포함한 block chain을 사용하면 찬성하는 것이고, 그렇지 않다면 반대하는 것이다. block chain에서 특정 block은 마지막 block의 hash를 가지고 있기에 가능하다. bitcoin에서 사용되는 consensus algorithm을 간단하게 살펴보면 아래와 같다.\n신규 transaction은 모든 node들에 broadcast된다. 각 node들은 transaction들을 모아 block을 구성한다. 매 round마다 random node가 선출되고, 그 node에서 생성한 block을 broadcast한다. 다른 node들은 (3)에서 전송된 block을 보고, valid(unspent, valid signature) 하다면 이를 수락한다. Node들은 다음번 만드는 block에다 (3)에서 전송된 block의 hash를 집어넣음으로써 implicit하게 수락을 표현할 수 있다. (그렇지 않으면 거절을 표현한 것) 그렇다면 위 방식에 문제는 없을까?\nsignature 설정 방식이 견고하다면, transaction을 위조할 수 없기 때문에 타인의 coin을 강제로 탈취할 수 없다. 특정 node가 valid 한 데이터를 계속 deny 하더라도, 해당 node가 다음 round에서 선택되지 않으면 transaction들은 정상적으로 올라가게 된다. 약간의 번거로움만 있을 뿐 전체 시스템에 치명적인 문제가 발생하지는 않는다. node가 수행할 수 있는 악의적인 행위로는 \u0026lsquo;double spending attack\u0026rsquo; 이 있다. double spending attack\nblock chain의 block1을 base로 A가 B에게 coin을 넘겨준 transaction [b1 : A -\u0026gt; B] 이 있다고 하자 이때, A가 악의적으로 A가 자신의 또다른 계정 A\u0026rsquo;에게 coin을 넘겨주었다는 거짓 transaction [b1 : A -\u0026gt; A\u0026rsquo;] 를 추가한다면, 정상적으로 수행된 [b1 : A -\u0026gt; B] transaction과 충돌이 발생한다. 즉, merge conflict가 발생하는 2개의 branch가 생성되는 것이다. 이는 moral distinction을 요하기 때문에 기술적으로 어렵다. node들은 대체로 먼저 들어온 block을 수락하고, 더 긴 branch를 정당한 branch로 취급한다. 조작된 transaction [b1: A -\u0026gt; A\u0026rsquo;]이 든 block이 network 지연 등의 이슈로 인해 먼저 broadcast되고, 정당성을 확립하면 실제 transaction[b1 : A -\u0026gt; B] 는 orphan block이 되고, 네트워크에서 사라지게 된다. 0 confirmation transaction\ndouble spending attack을 막기 위해, block chain에 내가 coin을 지불받는 transaction이 정상적으로 들어있는 것을 확인한 후 현실 세게에서 물건을 전달하는 방식 다른 node가 올린 block에서 내 transaction이 정상적으로 적용되었는지 확인할 수 있다. 해당 block 뒤에 더 많은 block이 붙을 수록 \u0026rsquo;long term consensus chain\u0026rsquo; 이 될 확률이 높아진다. double spending attack의 성공 확률은 confirmation의 횟수만큼 exponential 하게 줄어든다. block chain의 형태가 아래와 같을 때,\r[block1] - [block2] - [block3] - [block4] - [block5]\rblock3는 3 confirmation을 받은 상태이다.\rblock4는 2 confirmation을 받은 상태이다. 일반적인 bitcoin에서는 transaction이 정상적으로 이루어진 것을 판단하기 위해서 6 confirmation을 확인한다. 이는 시간과 확률의 trade-off 관계에서 성립된 수치이다. honesty problematic 우리는 탈 중앙화를 위해 랜덤한 node에서 block을 받아 block chain에 적용하기로 했다. 하지만 모든 node가 honest 한지에 대해서는 보장할 수 없다. 각 node들은 현실 정보의 개인정보를 갖고있지 않기 때문에 block chain에 위해를 가하는(double spent 같은 공격) node를 처벌할 수 없다. 대신 올바른 block들을 만들어주는 node들에 대해 보상을 주는 방법은 가능하다. 이는 block chain으로 구성된 내용이 가치를 가지는 crypto currency 이기 때문에 가능하다. Incentive Algorithm bitcoin은 decentralize를 위해 기술적인 부분(distributed consensus)과 incentive aoglrithm 을 사용한다. block reward block chain의 규칙에 따라, block을 생성하는 node는 특수한 coin-creation transaction을 추가할 수 있다. 이를 통해 coin을 생성하고, 그것을 자신의 계좌로 연결하여 수익을 얻을 수 있다. bitcoin에서 현재(14.08) coin 생성 양은 25 코인으로 고정되어 있는데, 이는 매 4년마다 절반으로 줄어든다. 최초에는 50코인이었다. coin-creation transaction은 다른 transaction과 마찬가지로 취급된다. transaction이 consensus chain에 들어가야 효력이 발생한다. 즉, 자신의 coin-creation transaction이 든 block이 consensus chain에 포함되려면, 다른 node들이 agree 할 만한 block을 base로 하여 block을 연결하는게 유리하다. 악의적인 node가 double-spending attack을 위해 길이가 긴 block-chain을 무시하고 임의의 block을 base로 하여 자신의 block을 연결한다면, 다른 node들은 그가 만든 block-chain을 reject 할 것이고, 그가 받는 보상은 무효화 될 것이다. 이러한 방식으로 node들이 honest하게 동작하도록 유도한다. 새로운 bitcoin은 transaction시 발생하는 coin-creation transaction에 의해서만 생성되고, 현재 규칙이 계속 유지될 경우 2140에는 새로운 coin이 생성되지 않고 21 million 에서 수렴할 것이다. transaction fee transaction을 생성하는 자는(거래를 하는 자) output value를 임의로 설정할 수 있다. (단, output value \u0026lt; input value)\n해당 transactio을 최초로 block에 넣는 node는 input-output 의 차액을 가져갈 수 있다.\ntransaction fee는 자발적이고, tip과 같은 느낌이지만, block reward가 점차 감소하는 시점에서 시스템을 유지하기 위해서는 필수적인 요소가 된다.\n이러한 시스템에서도 아직 해결안된 문제는 남아있다.\n어떻게 random 한 node를 선택할 것인가 보상을 위해 과도한 경쟁(free-for-all)을 하는 현상을 어떻게 막을 것인가 Sybil attack 의 방지(2번의 심화 형태) 위 세가지 문제점은 모두 연관되어 있고, 하나의 방법으로 해결 가능하다. Proof of work 직접 random 한 node를 선택하는 대신, resource(computing power) 의 비율로 다음 node가 선택되게 하는 방법이다.\n즉, 각 node들이 각각의 computing power을 이용해 서로 경쟁하도록 하는 것이다.\n이러한 경쟁 방법을 Hash puzzle이라 부른다.\nblock을 [nonce, previous hash, {Tx1, Tx2, \u0026hellip;}] 형태로 구성하도록 한다. nonce를 포함한 전체 block을 hash 로 취했을 때, 결과값 중 target space(일반적으로 1% 이하의 매우 작은 영역)가 특정한 값이 나오도록 해야한다. (target 값보다 작은 값이 되도록) hash function이 충분히 secure 하다면, nonce를 찾으려면 random한 nonce 값을 넣으며 계산을 시도해야 하며, 일반적으로 많은 computing power가 필요할 것이다. 이를 통해 단순히 node의 숫자를 늘려서 다음 block을 선택할 기회를 얻을 확률을 높일 수 없게 되었다.\n또한 누군가가 랜덤한 block을 선출하는 것이 아닌, 경쟁과 확률을 통해 자연적으로 선출될 수 있도록 하였다.\nProof of work의 속성 Difficult to compute hash puzzle을 푸는데는 현재(14.8) 기준 block당 약 10^20 hash를 계산해야 한다. (target space의 크기가 1/10^20 이란 의미) 일반적인 PC로는 감당할 수 없고, 많은 양의 computing power을 사용하여야 하는 작업이다. 이렇게 nonce 값을 찾는 것을 흔히 bitcoin mining이라 하는 과정이다. parameterizable cost target space의 범위를 고정된 %로 취하는 것이 아닌, 가변적인 값으로 설정한다.\np2p 에 연결된 모든 node들은 자동적으로 매 2주마다 target space를 재 설정하도록 동작한다.\ntarget space의 값은 hash puzzle을 푸는데 걸리는 시간이 약 10분이 되도록 하는 것을 목표로 한다.\nblock 간의 간격이 10분이 되는 이유는, 너무 빨리 block이 갱신되면 한 block에 여러 transaction(현재기준 약 수백개)을 담아 효율적으로 운영할 수 없게 된다. latency는 기술적으로는 더 낮게 설정할 수도 있지만, 모두의 동의 하에 하한값을 설정하여 작동한다. 특정 node가 다음 block을 설정하게 될 확률은, 전체 node들의 computing power에서 그 node가 갖고 있는 computing power 의 비율에 비례한다.\n결과적으로, 다량의 computing power을 가지고 mining을 하고 있는 사람들은 대부분이 honest하고, 다음 block 선택을 경쟁적으로 수행하기 때문에 적어도 50% 이상의 확률로 block이 honest node에서 선택되었음을 보장할 수 있다.\nnonce는 확률적으로 밖에 도출될 수 없다. 이는 discrete probability process로, Bernoulii trial 이다.\nnonce를 찾는 과정은 Bernoulii trial을 연속적으로 수행하는 poisson process에 속한다. 전 network에서 누군가가 nonce를 찾는데 걸리는 시간을 확률 밀도함수(probability density)로 표현하면 exponential distribution을 이룬다. (0에 수렴하도록 감소하는 지수 함수) Trivial to verify 특정 node가 hash puzzle을 해결하여 올린 block을 다른 node에서 쉽게 검증할 수 있어야 한다. H(block) \u0026lt; target, block의 모든 값을 hash 계산한 결과가 target 보다 작은지 확인 ","permalink":"https://AswinBlue.github.io/post/cryptocurrency/","summary":"Cryptocurrency Cryptographic Hash function hash function은 아래와 같은 속성을 갖는다. 모든 크기의 String을 input 으로 받는다. 정해진 크기의 output을 생성한다. (bitcoin에서는 256bit) 적당한 시간 안에 계산이 가능하다. (계산 시간이 너무 길지 않다) cryptographic hash function은 아래와 같은 security 속성을 추가로 갖는다.\ncollision-free hiding puzzle-friendly 속성1. collision-free x != y 라면, H(x) = H(y) 인 경우를 찾을 수 없어야 한다. 이 말은 collision 이 존재하지 않는다는 뜻은 아니다. num(possible_input) \u0026gt; num(possible_outputs) 이다.","title":"Cryptocurrency"},{"content":"firebase firebase는 실시간 db로 유명하며, google에 인수되고 폭이 넓어졌다. Amazon의 Amplify가 firebase와 유사하다. 일정 사용량 까지는 무료로 사용 가능하며, 이후에는 요금이 부가된다. 설치 및 사용 온라인으로 콘솔에 접속하여 프로젝트를 생성 및 설정하고, firebase sdk를 로컬에 다운받아 코드에 적용한다. firebase는 다양한 운영체제에 설치 가능하며, 각각의 설치 방법을 따르면 된다. (웹에서는 설치하지 않고 url로 참조해 사용할 수도 있다.) 버전이 올라감에 따라 참조방법, 인터페이스 등 사용법이 바뀌는 경우가 많으니 항상 docs를 잘 살펴보자\nfirebase link: https://firebase.google.com\nfirebase docs : https://firebase.google.com/docs\nfirebase를 코드에 적용하려면 config 데이터를 작성해야 한다.\nfirebase 콘솔에서 앱을 생성하고, 내 소스를 firebase의 내 프로젝트와 연동에 필요한 config 정보들을 복사하여 소스에 적용한다. ex) AppFirebase.js import firebase from \u0026#34;firebase/compat/app\u0026#34;;\rimport \u0026#34;firebase/compat/auth\u0026#34;;\rconst firebaseConfig = {\rapiKey: process.env.REACT_APP_API_KEY,\rauthDomain: process.env.REACT_APP_AUTHDOMAIN,\rprojectId: process.env.REACT_APP_PROJECTID,\rstorageBucket: process.env.REACT_APP_STORAGEBUCKET,\rmessagingSenderId: process.env.REACT_APP_MESSAGINGSENDERID,\rappId: process.env.REACT_APP_APPID\r};\rexport default firebase.initializeApp(firebaseConfig);\rexport const authService = firebase.auth(); 기능 firebase 콘솔에 로그인 하고, 프로젝트를 생성한다. 생성된 프로젝트에 진입하여 원하는 기능을 사용할 수 있다. 인증 (Auth) \u0026lsquo;Authentication\u0026rsquo; 탭을 선택하여 사용 가능하다. email, phone, google account, facebook account 등 다양한 인증 방법을 제공한다. 다만, 주의할 점은 firebase API를 이용해 인증 서비스를 이용하면, 이후 확보된 사용자층을 다른 플랫폼으로 옮길 수 없다는 점이다. 로그인에 사용된 계정들은 콘솔창에서 관리할 수 있으며, 비밀번호 재설정 등을 위한 메일도 커스텀할 수 있도록 환경이 제공된다. React code import { authService } from \u0026#34;../components/AppFirebase\u0026#34;;\rconst data = await authService.createUserWithEmailAndPassword(email, password) // email, passwd로 계정 생성\rconst data = await authService.signInWithEmailAndPassword(email, password) // email, passwd로 로그인 email 인증 Authentication 탭에서 signed-in method를 선택한다. 원하는 \u0026lsquo;로그인 제공업체\u0026rsquo; 를 선택하여 추가한다. ","permalink":"https://AswinBlue.github.io/post/firebase/","summary":"firebase firebase는 실시간 db로 유명하며, google에 인수되고 폭이 넓어졌다. Amazon의 Amplify가 firebase와 유사하다. 일정 사용량 까지는 무료로 사용 가능하며, 이후에는 요금이 부가된다. 설치 및 사용 온라인으로 콘솔에 접속하여 프로젝트를 생성 및 설정하고, firebase sdk를 로컬에 다운받아 코드에 적용한다. firebase는 다양한 운영체제에 설치 가능하며, 각각의 설치 방법을 따르면 된다. (웹에서는 설치하지 않고 url로 참조해 사용할 수도 있다.) 버전이 올라감에 따라 참조방법, 인터페이스 등 사용법이 바뀌는 경우가 많으니 항상 docs를 잘 살펴보자","title":"Firebase"},{"content":"Go 설치 및 프로젝트 생성 구글 검색을 통해 설치파일을 다운받는다. root 디렉터리 설정이 필요하다.(\u0026lsquo;C:\\Go, \u0026lsquo;/usr/local/go/bin/\u0026rsquo;) 이후 생성할 프로젝트는 이 root 디렉터리 하위 경로에 생성된다. 외부 경로에는 프로젝트를 생성할 수 없다. root 디렉터리 안 src 디렉터리에 프로젝트를 생성한다. Go는 npm, pip 와 같이 패키지 매니저가 없다. git 등에서 코드를 받아오면 src 디렉터리 안에 도메인별로 정리해서 관리하는게 정석이다. ","permalink":"https://AswinBlue.github.io/post/golang/","summary":"Go 설치 및 프로젝트 생성 구글 검색을 통해 설치파일을 다운받는다. root 디렉터리 설정이 필요하다.(\u0026lsquo;C:\\Go, \u0026lsquo;/usr/local/go/bin/\u0026rsquo;) 이후 생성할 프로젝트는 이 root 디렉터리 하위 경로에 생성된다. 외부 경로에는 프로젝트를 생성할 수 없다. root 디렉터리 안 src 디렉터리에 프로젝트를 생성한다. Go는 npm, pip 와 같이 패키지 매니저가 없다. git 등에서 코드를 받아오면 src 디렉터리 안에 도메인별로 정리해서 관리하는게 정석이다. ","title":"Golang"},{"content":"#Tensorflow\nTensorFlow는 구글에서 수치연산을 위해 만든 라이브러리이다. 기본 개념 node와 edge로 구성된 graph를 이용해 수치 연산을 수행한다. node들은 특정한 데이터가 들어오면 연산을 수행하거나, 형태를 변경하거나, 결과를 출력하는 역할을 한다.\nedge는 학습데이터가 저장되는 다차원 배열이다.\nedge는 node에서 계산된 데이터를 다음 node로 이동시킨다.\nedge는 방향성이 있으며(directed), tensor라 불린다.\narchive.ics.uci.edu/ml 에서 학습용 데이터를 받아 사용할 수 있다.\n설치 python과 pip를 설치한다. pip install tensorflow 명령을 수행한다. window에서 \u0026lsquo;client_load_reporting_filter.h\u0026rsquo; 파일을 찾지 못해 설치를 못했다면, path 경로가 너무 길어서 발생하는 오류이다. 실행에서 regedit을 실행하고, \u0026lsquo;HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\FileSystem\u0026rsquo; 레지스트리를 찾아 값을 1로 세팅해준다. 연관 모듈 함께 쓰면 효율이 좋은 모듈들 matplotlib numpy data = np.loadtxt(FILE_NAME, delimiter=',') : ,를 기준으로 데이터를 나누는 csv 파일을 읽어들임. 숫자 데이터를 읽을 때 사용 keras (tensorflow 설치시 자동성치된다) y_encoded = to_categorical(y_data) : y_data 를 one-hot-encoding 하는 함수 (tensorflow.keras.utils.to_categorical) pandas df = pd.read_csv(FILE_NAME) : csv 파일을 읽어서 dataframe을 구성한다. 숫자 및 문자열 데이터를 읽을 때 사용 가능 sklearn 데이터 전처리 e = sklearn.preprocessing.LabelEncoder()\re.fit(data) # data 에 들어있는 값 중 unique한 값을 뽑아(중복 제거) 특정 string에 번호를 매기는(indexing) 함수\rdata = e.transform(data) # indexing 된 정보를 바탕으로 실제 data값을 index로 치환 기본 문법 상수 선언\nval = tf.constant(value, dtype=None, shape=None, name='Conts', verify_shape=False) value = 값 dtype : 데이터 타입, ex) \u0026rsquo;tf.float32\u0026rsquo;, \u0026rsquo;tf.float64\u0026rsquo;, \u0026rsquo;tf.int8\u0026rsquo; float(32, 64), int(8, 16, 64),uint(8, 16), string, bool, complex(64, 128 : 복소수) shape : 차원, value 형태에 따라 자동으로 설정 됨, ex) \u0026lsquo;[3,3]\u0026rsquo; name : 상수의 이름 verify_shape : tensor의 shape를 바꿀수 있는지 여부 배열 생성 arr = tf.range(5) output : tf.Tensor : shape(5,), dtype=int32, numpy=([0, 1, 2, 3, 4], dtype=int32)\n\u0026rsquo;tf.zeros([2,3])\u0026rsquo; output : [[0, 0, 0], [0, 0, 0]]\n\u0026rsquo;tf.ones([2,3])' output : [[1, 1, 1], [1, 1, 1]]\n\u0026rsquo;tf.fill([2,3], 5)' output : [[5, 5, 5], [5, 5, 5]]\n연산자 tf.add(x,y) : x + y\ntf.subtract(x,y) : x - y\ntf.multiply(x,y) : x * y\ntf.div(x,y) : x / y\ntf.floordiv(x,y) : x // y\ntf.mod(x,y) : x % y\ntf.pow(x,y) : x ** y\ntf.less(x,y) : x \u0026lt; y\ntf.less_equal(x,y) : x \u0026lt;= y\ntf.greater(x,y) : x \u0026gt; y\ntf.greater_equal(x,y) : x \u0026gt;= y\ntf.logical_and(x,y) : x \u0026amp; y\ntf.logical_or(x,y) : x | y\ntf.logical_xor(x,y) : x ^ y\ntf.maximum(x,y) : max(x,y)\ntf.reduce_sum(a) : 배열 a에서 같은 index 위치의 값을 모두 더한 스칼라 값을 반환\ntf.reduce_mean(a) : 배열 a에서 같은 index 위치의 값을 평균낸 스칼라 값을 반환 x,y가 배열인 경우, 연산자는 같은 index에 위치한 값끼리 연산한다.\nex) tf.add(x,y) = [(x[0] + y[0]), (x[1] + y[1]), (x[2] + y[2]), ...] \u0026lsquo;reduce\u0026rsquo; 가 들어간 연산은 axis 파라미터를 설정하여 어느 축을 기준으로 연산을 수행할지 설정 가능\nex) a = [[1,2,3],[4,5,6]]\rtf.reduce_sum(a, axis=0) = [5, 7, 9]\rtf.reduce_sum(a, axis=1) = [6, 15] 변수 tensorflow에서 변수는 node를 만들고, 그 안의 값을 참조하는 방식이다.\nvar = tf.Variable(value, dtype=type)\nvalue : 변수에 담을 값 dtype : 변수 타입 2.x 버전에서는 위와같이 선언과 동시에 초기화가 가능하다. node를 생성하고 var은 그 node의 주소를 가리킨다.\nvar.assign(value)\nvar이 가리키는 node에 value 값을 적용\nvar.assign_add(value)\nvar이 가리키는 node에 value 값을 더함\nvar.assign_add(value)\nvar이 가리키는 node에 value 값을 뺌\ntf.cast()\n변수를 특정 값, 특정 형태로 치환해주는 함수\n출력\nval.numpy() : \u0026lsquo;val\u0026rsquo; tensor를 numpy 배열 형태로 출력\n비교 tf.equal() : tensorflow 변수를 비교하는 함수\n랜덤 tf.random.set_seed() : 정수를 이용해 랜덤값 시드 설정 tf.random.normal([2, 1], mean=0.0)) : 정규분포에 기반한 랜덤값, 인자로 행렬 shape와 평균이 들어간다.\n심화 내용 tensorflow와 행렬 TensorFlow에서 배열은 행렬로 표현되며, 행렬은 shape라 불린다. 행렬 계산을 위한 함수를 제공한다. tf.matmul(a, b) : 행렬의 내적(곱) tf.linalg.inv(a) : 역행렬 Broadcasting 행렬을 곱셈 혹은 덧셈을 하기 위해서는 shape에 대한 제약조건이 있고, tensorflow에서도 마찬가지다. tensorflow에서는 행렬 연산에서 차원(shape)이 맞지 않을 때 행렬을 자동으로 늘려서(Stretch) 차원을 맞춰주는 Broadcasting기능이 있다. 연산시 shape는 첫번째 피연산자를 기준으로 한다. stretch 시 새로 생성된 공간에는 기존 내용을 복사하여 채워넣는다. 단, 늘릴 수는 있지만, 줄일수는 없다. ex) a[4,3] + b[1,3] : 가능 a[4,3] + b[1,5] : 불가능 (3 \u0026lt; 5 이므로, 5를 3으로 바꾸려면 축소해야함) a[4,1] + b[1,3] : 가능 tensorflow 함수 tensorflow 1.x 버전은 placeholder를 통해 입력을 받는 객체를 생성하고, 실행시 session을 통해 feed 값을 전달한다. 즉 명시적으로 입력 형태를 구성해야 했다. tensorflow는 2.x 버전부터 python 프로그램처럼 라이브러리를 사용할 수 있도록 연산에 함수를 제공하고 있다. 함수를 사용하면 placeholder를 생략하고 사용할 수 있다. tensorflow 함수는 파이썬 함수처럼 정의하여 사용 가능하며, 컴파일시 속도 향상을 원한다면 @tf.function 데코레이터를 적용하면 된다.\nex) @tf.function\rdef t_func(a,b):\rreturn tf.matmul(a,b)\rx = [[4,5,6],[6,7,8]] # tensorflow 변수가 아님\rw = tf.Variable([2,5],[6,5],[17,10])\rprint(t_func(x,w))\r# tensorflow 2.x 이후부터는 변수 x같은 값들도\r# placeholder를 만들고 feed 값을 주는 복잡한 과정 없이\r# tensorflow 함수를 이용해 연산 가능해졌다. tensorflow 미분 gradient 계산에 미분이 많이 사용고, tensorflow는 미분 함수를 제공한다. tape.gradient(y,x) : 텐서 x에 대한 y의 미분값 tape.watch() : 상수형 텐서를 변수형 텐서로 변환 ex)\nx1 = tf.Variable(tf.constant(1.0)) # 변수 선언\rx2 = tf.Variable(tf.constant(2.0)) # 변수 선언\rwith tf.GradientTape() as tape: # 미분을 위해 GradientTape 객체 생성\ry = tf.multiply(x1, x2) # 미분할 함수값을 GradientTape 객체 안에서 정의\rgradients = tape.gradient(y, [x1, x2]) # x1 미분값과 x2 미분값을 각각 반환\r# y = x1 * x2\r# x1 에 대한 미분값 : 2.0\r# x2 에 대한 미분값 : 1.0\r# gradients = [2.0, 1.0]\ra = tf.constant(2.0)\rgradients2 = tape.gradient(y,a)\r# 상수로 미분하면 None 값이 된다.\r# gradients2 = None\r# 상수를 변수로 변환시켜 미분시킬 수 있다.\rwith tf.GradientTape() as tape:\rtape.watch(a)\ry = tf.multiply(x1, a)\rgradients3 = tape.gradient(y,a)\r# gradients3 = 1.0 선형 회귀 \u0026lsquo;딥러닝\u0026rsquo;은 데이터를 통해 관계를 학습하고, 학습된 모델을 통해 데이터가 주어지면 예측값을 도출해 내는 기술이다. \u0026lsquo;딥러닝\u0026rsquo;의 가장 기본적인 계산 원리는 \u0026lsquo;션형 회귀\u0026rsquo;와 \u0026lsquo;로지스틱 회귀\u0026rsquo; 이다. 선형회귀 : 데이터 분포를 통해 데이터들과 가장 근접한 선을 도출해내는 계산법 로지스틱 회귀 : 0과 1 둘 중 하나를 선택하는 계산법 판단의 근거를 마련할 때 사용 sigmoid 함수를 사용하여 확률값으로 사용 선형 회귀 정의 종속변수 y와 한개 이상의 독립변수 x와의 선형 상관관계를 모델링하는 회귀분석 기법\n단순 선형회귀 : 하나의 변수에 기반하여 동작 다중 선형 회귀 : 둘 이상의 변수에 기반하여 동작 선형 예측함수를 통해 회귀식을 모델링하고, 알려지지 않은 파라미터를 데이터로 추정\n회귀식을 선형 모델이라고 한다.\n값을 예측하기 위해 학습 데이터로 적합한 예측 모형을 개발한다.\n종속변수 y와 이에 연관된 독립변수들 x1, x2\u0026hellip; 에 대해 x와 y간의 관계를 정량화 할 수 있다.\n일반적으로 최소제곱을 사용해 선형 회귀 모델을 구할 수 있다. (y = ax + b 형태)\n독립변수(x)가 증가하면 최소 제곱법으로 처리가 불가능하다. 딥러닝에서는 y = wx + b 형태로 표현하는데, w 는 weight, b는 bias 를 뜻한다.\nweight : 가중치, 입력값 x의 영향도를 표현하는 상수 bias : 기준점, 판단의 근거가 되는 식의 기준점을 표현하는 상수 오차방정식 선형 회귀에서 입력값이 여러개일 경우, 첫번째 입력으로 임의의 선을 그린다.\n정답과 임의의 선이 맞는지 확인하고 평가한다 (오차 확인)\n확인된 오차 값을 이용해 임의의 선을 수정한다.\n즉, y = ax + b 에서 (x,y)를 입력으로 받고 a,b를 추론한다. 이러한 계산 식을 오차방정식이라 한다.\n오차의 합 = ∑ (예측값 - 정답)²\nMSE : Mean Squared Error, 평균제곱오차 = (오차의 합) / n\nRMSE : Root Mean Squared Error, 평균 제곱근 오차 = root(편균제곱오차)\n경사 하강법 대표적인 \u0026lsquo;최적화 알고리즘\u0026rsquo;으로, 비용 함수를 최소화하기 위해 반복해서 파라미터를 조정해나가는 방식이다.\ny = a*x 방정식에서 x = [1,2,3] y = [1,2,3] 이라고 한다면 a값은 1이다. 이때 MSE 오차식과 x에 대해 그래프를 그리면 2차원 그래프가 나오게 된다. 이때 기울기가 0인 부분, 즉 꼭짓점의 x 값이 정답이 된다.\n이러한 특성을 이용하여 다음과 같이 정답을 찾는 recursive한 전략을 취할 수 있다.\n임의의 값 x1에서 미분을 구한다. 구해진 기울기의 반대 방향으로 이동하여 그래프와 겹쳐지는 부분의 x좌표를 x2라 한다. 1~2 과정을 반복하면 점차 기울기가 줄어들고, 이를 충분히 수행하면 정답값에 수렴한다. 하지만 오차 그래프의 폭이 좁은 경우, 위 방식을 수행하면 특정 값으로 수렴하지 않고 결과값이 발산한다.\n이를 막기 위해 기울기를 100% 취하지 않고, \u0026lsquo;학습률\u0026rsquo; 이라는 상수를 곱해 일정 양만큼만 전략에 반영될 수 있게 한다.\n학습률은 정해진 값이 아니고, 데이터에 따라 적합한 값이 달라지는 상수이다.\n위 전략을 수정하여 다시 적용하면\n임의의 값 x1에서 미분을 구하고, 학습률을 적용하여 값을 조정한다. 구해진 값을 기울기로하여 이동할 때 그래프와 겹쳐지는 부분의 x좌표를 x2라 한다. 1~2 과정을 반복하면 점차 기울기가 줄어들고, 이를 충분히 수행하면 정답값에 수렴한다. learning_rate = 0.1\rwith tf.GradleTape() as tape:\rhypothesis = W * x_data\rcost = tf.reduce_mean(tf.square) 로지스틱 회귀 선형회귀와 함께 대표적인 딥러닝 알고리즘이다.\n독립변수의 선형 결합을 이용하여 사건 발생의 가능성을 예측하는데 사용되는 \u0026lsquo;통계 기법\u0026rsquo; 이다. (확률 계산)\n로지스틱 회귀는 종속변수와 독립변수 간의 관계를 함수로 나타내어 향후 예측모델에서 사용하므로, 독립변수의 선형 결합으 종속변수를 설명한다는 관점에서 선형 회귀분석과 유사하다.\n하지만, 로지스틱 회귀는 데이터의 결과가 특정 분류로 나뉘어 지기 때문에 classification 기법으로 볼 수 있다.\n이진 분류 문제, 즉 0과 1 중 하나를 판별하는 문제는 로지스틱 회귀를 이용하여 풀 수 있다.\nstep function 혹은 sigmoid를 사용하는데, 보통 0과 1 사이의 확률값을 표현할 수 있는 sigmoid를 사용한다.\n시그모이드 시그모이드 방정식은 아래와 같다.\ny = 1 / (1 + e \u0026lt;sup\u0026gt;-x\u0026lt;/sup\u0026gt;)\ne는 자연상수이며, 자연상수를 사용하였기 때문에 확률값으로 사용 가능하다.\nsigmoid 함수에 선형 회귀 함수를 대입하면 아래와 같이 된다.\ny = 1 / (1 + e \u0026lt;sup\u0026gt;(-wx+b)\u0026lt;/sup\u0026gt;)\n이 함수에 경사하강법을 이용하여 w와 b를 찾아낼 수 있다.\nw값이 증가하면 sigmoid 함수는 step function에 유사하게 경사가 가팔라 진다.\nb값이 증가하면 그래프가 우측 방향으로 이동한다.\n오차함수 로지스틱 회귀는 target이 0 또는 1 두가지라는 점에서 선형 회귀와 다르다.\n때문에 로지스틱 회귀는 오차함수도 두가지가 있다.\n정답이 0일 경우 -log(l-h) 그래프 형태이다. 정답이 1일 경우 -log(h) 그래프 형태이다. 정답값 0 혹은 1을 대입하면 원하는 오차함수가 나오는 식을 binary cross entropy 라 하고, 그 식은 다음과 같다.\nY = -(Y * LOG(H) + (1-Y)*LOG(1-H))\n로지스틱 회귀법을 tensorflow 함수로 구현하면 아래와 같다.\n# 6 by 2 형태의 x 데이터 학습값\rx_train = np.array([[1., 1.],\r[1., 2.],\r[2., 1.],\r[3., 2.],\r[3., 3.],\r[2., 3.]],\rdtype=np.float32)\r# 6 by 1 형태의 y 데이터 학습값\ry_train = np.array([[0.],\r[0.],\r[0.],\r[1.],\r[1.],\r[1.]],\rdtype=np.float32)\r# 이 학습값을 이용해 W와 b를 찾아본다.\r# 랜덤값을 위한 설정\rtf.random.set_seed(12345)\r# W와 b의 초기값을 랜덤하게 설정, x값이 [6, 2] 이므로 W 형태를 [2, 1] 로 해야 y 값인 [6, 1] 에 맞게 matmul이 가능하다.\rW = tf.Variable(tf.random.normal([2, 1], mean=0.0))\rb = tf.Variable(tf.random.normal([1], mean=0.0))\rprint(\u0026#39;weights: \\n\u0026#39;, W.numpy(), \u0026#39;\\n\\nbias: \\n\u0026#39;, b.numpy())\r# x값을 sigmoid 함수에 대입하여 y값을 반환하는 함수\r# x값의 shape가 [,2] 형태이므로 z = -(w1*x1 + w2*x2 + b) 가 된다.\rdef predict(X):\rz = tf.matmul(X, W) + b\rhypothesis = 1 / (1 + tf.exp(-z))\rreturn hypothesis\r# 반복 학습\rfor i in range(2001):\rwith tf.GradientTape() as tape:\rhypothesis = predict(x_train)\r# cost : binary cross entropy 식으로 loss 값을 계산\rcost = tf.reduce_mean(-tf.reduce_sum(y_train*tf.math.log(hypothesis) + (1-y_train)*tf.math.log(1-hypothesis)))\r# w와 b로 편미분하여 오차값 계산\rW_grad, b_grad = tape.gradient(cost, [W, b])\r# 오차값에 learning rate를 적용한 결과값으로 w와 b를 재설정\rW.assign_sub(learning_rate * W_grad)\rb.assign_sub(learning_rate * b_grad)\r# 계산된 w,b를 사용하여 x, y에 대해 정상적으로 예측값이 나오는지 확인\rdef acc(hypo, label):\r# 0.5 이상이면 0, 이하이면 1의 확률이 더 높으므로, 0.5를 기준으로 0 또는 1로 치환해 준다.\rpredicted = tf.cast(hypo \u0026gt; 0.5, dtype=tf.float32)\r# 정확도 = 계산값과 정답을 비교하여 맞으면 1점, 틀리면 0점으로 판단한 후 전체 점수를 평균 낸 값\raccuracy = tf.reduce_mean(tf.cast(tf.equal(predicted, label), dtype=tf.float32))\rreturn accuracy\r# 결과 계산\raccuracy = acc(predict(x_train), y_train).numpy() 퍼셉트론 퍼셉트론은 뉴럴 네트워크의 기본이 되는 개념으로, 인간의 신경망을 본따 프랑크 로젠블라트가 1957년에 고안한 알고리즘이다. 인간의 신경망은 외부 자극을 입력으로 받아 뉴런을 타고 신호가 전달된다. 뉴런과 뉴런 사이의 시냅스에서 신호를 전달하려면 역치값을 넘겨야 신호가 전달된다. 퍼셉트론은 입력을 받아 가중합(w1x1 + w2+x2 + \u0026hellip; + wixi+ b)을 취하고, 활성화 함수(sigmoid)를 거쳐 출력값을 생성한다. 다층 퍼셉트론 한 개의 퍼셉트론은 여러 문제를 해결할수 있다.\n좌표 평면에서 선 하나로 그룹을 구분지을 수 있는 경우에 해당한다. 대표적인 모델로는 AND모델, OR 모델이 있다. 하지만 단일 퍼셉트론으로 풀지 못하는 문제도 존재한다.\nXOR 모델이 대표적이다. 선 하나를 그어서 그룹을 분류할 수 없다. XOR 모델은 OR 퍼셉트론과 NAND 퍼셉트론을 1차적으로 수행하고, 두 수행에 대한 결과를 AND 연산하면 구할 수 있다. 이를 그래프로 표현하면 아래와 같다.\n0층 1층 2층\rx1 → s1 ↘ ↘ ↗ y\r↗ ↘ x2 → s2 ↗ 다중 퍼셉트론은 여러 layer를 두고 연산을 한다는 의미이며, layer가 증가하면 더 많이 분석된다는 뜻. 0층(가장 처음)은 input layer, 2층(가장 마지막)은 output layer, 그 사이의 layer는 hidden layer라 칭한다. hidden layer를 많이 만들면 대체로 데이터를 많이 분석하여 더 좋은 결과를 낼 수 있다고 할 수 있다. 오차 역전파 은닉층에 있는 각각의 w와 b를 구하는 방법이다.\n다층 퍼셉트론을 구성하면 각 layer마다 w와 b값이 구성되는데, 이때 오차를 구하기 위해 미분값을 구하는 것이 쉽지 않다.\n미분 안에 연결된 식이 많기 때문 layer의 개수는 변동될 수 있기 때문에 계산이 복잡하다 이 문제를 해결하기 위해 1980년도 오차 역전파 알고리즘이 발명된다. 이전에도 w와 b를 구할수는 있었지만, 구하는 방법에 대해 규칙성을 찾지는 못했다.\n오차 역전파 개요 최적화의 계산 방향이 output layer 에서 input layer 방향으로 진행된다. 이 떄문에 이 알고리즘을 back propagation 이라 부른다. 퍼셉트론에서 w와 b값을 찾기 위해 오차가 작아지는 방향으로(기울기가 0이 되는 방향으로) 업데이트 해 나갔는데, 다층 퍼셉트론에서는 다음 식으로 가중치를 변화시켜 나간다. W(t+1) = W * t - (∂오차) / (∂w): 새 가중치는 현 가중치에서 가중치에 대한 기울기를 뺀 값 출력층 오차 다층 퍼셉트론의 각 노드는 (1)입력값을 이용해 가중합을 만들고, (2) 가중합을 활성화 함수를 적용해 출력하는 두 단계를 수행한다. 3개 layer를 가지는 형태를 표현하면 아래와 같다. yh1, yh2 : hidden layer의 출력값 y_out1, y_out2 : output layer의 출력값, 예측값 0층 1층 2층\rx1 (w11)→ [가중합1 -\u0026gt; 활성화함수1] → yh1 (w31)→ [가중합3 -\u0026gt; 활성화함수3] → y_out1\r(w21)↘ ↗ (w41)↘ ↗\r(w12)↗ ↘ (w32)↗ ↘\rx2 (w22)→ [가중합2 -\u0026gt; 활성화함수2] → yh2 (w42) → [가중합4 -\u0026gt; 활성화함수4] → y_out2 오차 역전파는 y_out 값에서 반대로 진행하여 가중치 w를 업데이트 한다.\nw31(t+1) = w31 * t - (∂오차 y_out)/(∂w31) : 현재 weight에 미분값을 빼주면 다음 weight가 된다.\n오차 y_out 안에는 여러개의 출력값이 존재할 수 있다. (output layer의 node 개수만큼)\ny_out 안의 각각의 예측값에 대한 오차는 MSE를 이용해 구한다.\noutput layer의 node가 n개라고 하면, k번째 오차는 다음과 같다. 오차_y_out_k = (y_target_k - y_out_k)² / n 오차 역전파로, y_out1 값의 오차로 w31을 업데이트 해 보자.\n오차의 값은 ∂오차y_out / ∂w31 이다.\nchain rule에 의해 ∂오차y_out / ∂w31 = (∂오차y_out / ∂y_out1) * (∂y_out1 / ∂가중합3) * (∂가중합3 / ∂w31) 가 성립한다. 이 식의 우항을 각각 나누어 계산하여 보자. 2-1) (∂오차y_out / ∂y_out1)을 y_out1에 의해 편미분을 하면 y_out1과 관계없는 y_out2는 상수가 되어 사라진다. y_out = y_out1 + y_out2 = (y_target1 - y_out1)² / 2 + (y_target2 - y_out2)² / 2 이기때문에 최종 식은 (∂오차y_out / ∂y_out1) = 1/2 * ∂(y_target1 - y_out1)² / ∂y_out1 = y_out1 - y_target1 가 된다. 2-2) (∂y_out1 / ∂가중합3) 은 \u0026lsquo;활성화함수3\u0026rsquo;을 미분 해 주는것과 같다.\n우리는 활성함수로 시그모이드를 사용했고, 시그모이드의 미분은 ∂σ(x) / ∂x = σ(x) * (1 - σ(x)) 이다.\n따라서 ∂y_out1 / ∂가중합3 = y_out1 * (1 - y_out1) 이 된다. 2-3) 가중합3 = w31 * yh1 + w41 * yh2 + 1(bias) 형태인데, (∂가중합3 / ∂w31) 식에 첫 식을 대입하면 (∂가중합3 / ∂w31 = yh1 이 된다.\n(2)에서 구한 세 식을 합하면 (y_out1 - y_target1) * (y_out1 * (1 - y_out1)) * (yh1) 형태이다. 이때,\ny_out1 - y_target1 은 출력값, y_out1 * (1 - y_out1) 은 활성화함수의 미분 값이다. 이를 활용하여 델타 식으로 표현하면\nw31(t + 1) = w31 * t - δ * y * yh1 이 된다. (δ * y = (y_out1 - y_target1) * (y_out1 * (1 - y_out1)))\n은닉층 오차 위에서 w31을 구했고, 이제 w11을 구해보자\nw31은 y_out1에만 영향을 주고, y_out2에는 영향을 주지 않았다. 하지만 w11은 y_out1과 y_out2에 모두 영향을 주어서 식의 복잡도가 높다.\n점화식을 표현하면 w11(t+1) = w11 * t - (∂오차 y_out) / ∂w11 가 된다.\n(∂오차 y_out) / ∂w11 = (∂오차 y_out) / ∂yh1 * (∂yh1/∂가중합1) * (∂가중합1/∂w11) 형태로 chain rule을 사용할 수 있다. (∂yh1/∂가중합1) 은 activation 함수의 미분값이므로, (∂yh1/∂가중합1) = yh1(1 - yh1) 이 된다. 가중합을 w에 의해 미분하면 입력값이 된다. 따라서 (∂가중합1/∂w11) = x1 (∂오차 y_out) / ∂yh1 = ∂(오차y_out1 + 오차y_out2)/∂yh1 = ∂오차y_out1/∂yh1 + ∂오차y_out2/∂yh1\n5-1) 4 식을 나눠서 계산해보자. 먼저 ∂오차y_out1/∂yh1 = ∂오차y_out1 / ∂가중합3 * ∂가중합3 / ∂yh1' 5-1-1) 이때 ∂가중합3 / ∂yh1 = ∂(w31 * yh1 + w32 * yh2)/∂yh1 = w31 5-1-2)∂오차y_out1 / ∂가중합 = (∂오차y_out1 / ∂y_out1) * (∂y_out1 / ∂가중합3) = ( y_out1 - y_target1) * w31 * (1-y_out1) * y_out1 (∂오차y_out1 / ∂y_out1는 오차를 의미하고,∂y_out1 / ∂가중합3는 활성함수의 미분값을 의미하기 때문) 5-1-3) 최종적으로∂오차y_out1 / ∂yh1 = (y_out1 - y_target1) * w31 * (1 - y_out1) * y_out1 = δy_out1 * w31형태로 델타식을 만들 수 있다. 5-2) 다음∂오차y_out2/∂yh1도 5-1 에서 사용한 방식으로 계산하면 ∂오차y_out2/∂yh1 = δy_out2 * w41형태가 된다. 5-3) 위 값들로 4 에서 봤던 식을 구성하면 (∂오차 y_out) / ∂yh1 = δy_out1 * w31 + δy_out2 * w41` 이 된다. 2, 3, 5-3 에서 나온 값으로 1식을 재구성해보면 (∂오차 y_out) / ∂w11 = (δy_out1 * w31 + δy_out2 * w41) * yh1(1 - yh1) * x1 이다. 출력층의 오차 업데이트 : (y_out1 - y_target1) * y_out1 * (1 - y_out1) * yh1\n(y_out1 - y_target1) : 오차 은닉층의 오차 업데이트 : (y_out1 * w31 + y_out2 * w41) * yh1 * (1-yh1) * x1\n(y_out1 * w31 + y_out2 * w41) : hidden layer를 통해 출력값을 미분한 값 \u0026lsquo;출력층의 오차 업데이트\u0026rsquo;와 \u0026lsquo;은닉층의 오차 업데이트\u0026rsquo;는 공통적으로 y_out(1 - y_out) * x 의 형태(sigmoid function 미분 * 입력값)를 지니고 있다.\n은닉층의 가중치 업데이트를 델타식으로 표현하면 w11(t+1) = w11 * t - δh * x1 이다.\n델타식으로 표현하면 generic 한 형태로 식을 가져갈 수 있어 꼭 필요하다.\n그래디언트 소실(gradient vanishing) 다층 퍼셉트론을 사용할 때, 층이 많을 수록 데이터 분석 능력이 높아지지만, 실제로는 분석 증가량이 미미하다. 이는 활성화 함수 때문이다. 가중치를 수정할 때, 오차 값을 미분한 값을 사용하였다. 각 층의 activation function 으로 sigmoid를 사용했는데, sigmoid 함수는 미분시 최대치가 0.3 밖에 되지 않는다. 층을 지날수록 activation function을 여러번 거치는데, sigmoid의 미분값을 여러번 거치게 되면 미분값이 중간에 0이 되어버리는 현상(vanishing gradient) 문제가 발생한다. 층을 거쳐 갈수록 기울기가 사라져 가중치를 수정할 값이 소실되어 뒤쪽 layer는 더이상 학습이 되어지지 않는다. 그래디언트 소실 문제를 해결하기 위해 sigmoid를 대체할 다른 활성화함수들이 만들어 졌다. 하이퍼볼릭 탄젠트 : 미분 최대값 1, 소실문제를 약화시킬 순 있지만 해결되진 않는다. 렐루 : 0미만은 미분값 0, 0이상은 미분값 1. 많은 층을 사용할 때는 relu를 많이 사용한다. 소프트플러스 xavier와 he 초기화 초기 w와 b 할당시 표준편차가 1이고, 평균이 0인 정규분포를 사용하였다. 이렇게 되면 node를 통과한 결과값이 0과 1에 치중되어 있는 형태를 볼 수 있다. 표준편차를 0.01을 주면 결과값이 0.5로 치중되게 된다. 이렇게 되면 layer를 몇개를 쓰던 layer가 하나인 경우와 동일한 효과가 나온다. 이를 표현력의 제한이라 한다. 이러한 문제점을 xavier 방법을 사용하면 해결할수 있다. 가중치 초기화를 설정하는 방법으로, 결과값의 분포를 더 광범위하게 설정할 수 있게 하는 방법이다. √(2/n_in + n_out) 형태로 최초 사용하는 분포를 만들게 되면 더 광범위한 형태로 만들 수 있다. (n_in : layer의 입력node 개수, n_out : layer의 출력node 개수) 우리는 입력,출력 값이 같은 hidden layer를 사용하므로 √(1/n) 형태를 가진다. 단, xavier 방식은 좌우 대칭인 activation function 에서는 효과적이지만, relu와 같은 좌우 비대칭 형태의 activation function에서는 한쪽으로 치우친 결과값이 얻어진다. 이때는 \u0026lsquo;카밍 히\u0026rsquo;의 이름을 따서 he 초기값을 사용한다. √2/n 의 정규분포 값을 사용한다. (분포 범위를 더 넓게 잡는다) 고속 옵티마이저 옵티마이저란 경사하강법을 뜻한다. 고속 옵티마이저란 경사 하강법을 더 효율적으로 하는 방법이다. 경사 하강법은 대체로 학습 속도와 정확도 문제를 갖고 있다. (learning rate 혹은 data에 의해 발생) 경사 하강법은 업데이트 시마다 전체 데이터에 대해 미분을 계산하여야 하여 속도가 매우 느리다. 학습률이 너무 크면 더이상 최적값으로 수렴하지 못하는 경우가 있다. 경사 하강법은 구현하기 쉽고 단순하다는 장점이 이 있지만, 비등방성 함수에서는 탐색 경로가 비효율적이다. (ex: f(x,y) = 1/20x^2 + y^2 와 같은 타원형 형태) y축은 가파르지만, x축 변동은 거의 없다. 최적값은 (0,0) 이지만 미분으로 기울기 값을 구하면 (0,0) 이 아닌 다른 방향을 가리킬 확률이 매우 높다. 정상적으로 도달하더라도 지그재그 형태로 비효율적인 방식으로 이동하게 된다. 경사 하강법은 무작정 기울어진 방향으로 진행하기 때문에 간단하지만 위와같은 문제점을 야기한다. 경사 하강법의 문제점을 개선해 주는 모델들로는 \u0026lsquo;모멘텀\u0026rsquo;, \u0026lsquo;adagrad\u0026rsquo;, \u0026lsquo;adam\u0026rsquo; 등이 있다. 모멘텀 모멘텀 알고리즘은 물리 현상의 운동량에 착안하여 만들어 졌다. 이전 회차의 미분값 중 일정 비율을 반영하여 현재 weight 값 설정에 영향을 주도록 하여 더 빠르게 최적점을 찾을 수 있도록 하는 방식이다. 기존에는 현재 미분값 * 학습률을 현재 w에 빼주었지만, 모멘텀에서는 (일정 비율) * (이전 미분값) - (학습률) * (현재 미분값) 을 현재 w에 더해준다. 이 값은 V(t) = γ*v(t-1) - η*∂오차/∂w(t) 로 표현한다. 즉, W(t+1) = W(t) + V(t) 와 같은 식이 된다. 이전의 미분값을 일부 적용함으로써 현재 미분값을 상충하는 효과를 얻을 수 있다. 이를 통해 학습 속도를 높일 수 있다. 네스테로프 모멘텀 네스테로프 모멘텀에서는 w를 업데이트 할 때 γ*v(t-1) - η*∂오차/∂w(t) 값 대신 γ*v(t-1) - η*∂오차/∂(w(t) + γ*v(t-1)) 를 사용한다. 모멘텀 방법으로 이동될 방향을 미리 예측하여 해당 방향으로 한단계 미리 이동한 그래디언트 값을 사용함으로써 불필요한 이동을 줄일 수 있다. 속도는 그대로이지만 단계를 절약할 수 있다. 아다그리드 학습률을 조절하여 효율을 높인 모멘텀이다. 아다그라드는 weight값이 업데이트 될 때 마다 점점 최적점을 찾아간다고 가정하고, 학습을 시킬때 마다 일정량의 learning rate를 떨어뜨린다. 학습률을 변화시키기 위해 G(t)값을 G(t) = G(t-1) + [∂오차/∂w(t)]^2 형태로 가져가며, 최종적으로 W(t+1) = W(t) + η * (1/√G(t) + ε) * ∂오차/∂w(t) 형태가 된다. (ε 는 0이 되는것을 방지하기 위해 더해주는 아주 작은 상수값) RMSprop 아다그라드에서 G(t)는 무한히 커지게 되는 문제점이 있다. 이를 해결하기 위해 G(t) = γ * G(t-1) + (1-γ) * [∂오차/∂w(t)]^2 형태를 취한다. \u0026lsquo;γ\u0026rsquo; 값을 이용해 G(t) 값을 조절할 수 있도록 하였다. Adam RMSprop의 정확도, 모멘텀 방식의 속도 장점을 모두 취하는 방식이다.\nRMSprop의 G(t) 값과 모멘텀의 V(t) 값을 유사하게 구하여 사용한다.\nV(t) = γ_1 * G(t) + (1 - γ_1) * ∂오차/∂w(t) G(t) = γ_2 * G(t) + (1 - γ_2) * [∂오차/∂w(t)]^2 V(t)와 G(t) 값을 조절하여 V\u0026rsquo;(t), G\u0026rsquo;(t) 를 만들어 W(t+1) 을 구한다.\nV'(t) = V(t) / (1-r_1^t) G'(t) = G(t) / (1-r_2^t) W(t+1) = W(t) - η * (G'(t) / √(V'(t) + ε)) 이때까지 내용을 모두 분석해 보면 전반적으로 adam 옵티마이저가 좋은 성능을 내기는 한다.\n하지만 항상 adam이 최적의 효율을 내지는 않는다. 이는 데이터 형태가 다르기 때문이다.\n데이터 형태에 따라 취해지는 패턴과 오차 그래프의 모양이 다르기 때문이다.\ngradient descent, momentum, adagrid, adam, RMSprop 중 어느것이 효과가 좋은지 확인이 필요하다.\n다중 분류 입력값을 기준으로 단순 0 또는 1을 판단하는게 아니라, 여러 class 중 하나로 분류하는 모델을 알아보자 출력 node 개수를 분류되는 항목 개수로 설정한다. 활성화 함수를 적용하려면 Y값이 0과 1로 이루어져 있어야 한다. (100% 혹은 0%) 출력 node가 하나라면 Y값은 0 또는 1이면 되지만, 2개 이상이라면 배열이 되어야 한다. 1 =\u0026gt; [1,0,0], 2 =\u0026gt; [0,1,0], 3 =\u0026gt; [0,0,1] 형태로 변형해서 사용해야 한다. 이렇게 Y값을 0 또는 1로만 이루어진 형태로 바꾸어주는 기법을 one-hot-encoding 이라 한다. 텐서플로에서 one_hot() 함수를 지원한다. softMax classification 문제를 풀 때 점수 벡터를 클래스 별 확률로 변환하기 위해 사용하는 함수이다. 각 점수 벡터에 지수를 취한 후 정규화 상수로 나누어 총합이 1이 되도록 계산한다. exponential을 취하는 이유는 값이 클 수록 훨씬 더 높은 점수를 갖게 하기 위함이다. y_k = exp(a_k) / ∑\u0026lt;i=1,n\u0026gt; exp(a_i) softMax는 exponential을 사용하기 때문에 큰 값의 나눗셈을 수행해야 하여 overflow가 발생하기 쉽다. 수식을 개선하여 다음과 같이 사용한다. (keras에서도 개선된 수식을 사용함) y_k = exp(a_k) / ∑\u0026lt;i=1,n\u0026gt; exp(a_i)\r= C * exp(a_k) / C * ∑\u0026lt;i=1,n\u0026gt; exp(a_i)\r= exp(a_k + log C) / ∑\u0026lt;i=1,n\u0026gt; exp(a_i + log C)\r= exp(a_k + C\u0026#39;) / ∑\u0026lt;i=1,n\u0026gt; exp(a_i + C\u0026#39;) Cross Entropy softmax 에서 사용하는 오차방정식 cross entrpoy는 서로 다른 두 값의 확률 차이를 나타낼 수 있다. E = - ∑\u0026lt;k\u0026gt; t_k * log y_k 형태를 가진다. ex) 정답이 [0, 1] 이고, 결과가 [1, 0] 인 경우, E = 0 * log1 + 1 * log0 = ∞ ex) 정답이 [0, 1] 이고, 결과가 [0, 1] 인 경우, E = 1 * log1 + 0 * log0 = 0 오버피팅 훈련 데이터에 지나치게 적응하여 훈련 그 외의 데이터에 대해서는 제대로 평가를 하지 못하는 경우를 일컫는다. 학습 데이터를 통해 경향성만 추출해 내는 것이 가장 바람직한 학습 목표이다. 오버피팅은 모든 데이터를 모으지 못하면 발생할 수 있다. (훈련 데이터가 적을 때) 한쪽으로 편향된 데이터를 학습에 사용하거나, 노이즈를 일으키는 데이터를 사용한 경우에 발생할 수 있다. 은닉층이 너무 많거나 각 층의 노드 수가 많아 변수가 복잡해지면 발생할 수 있다. 테스트 셋과 학습 셋이 중복될 때 생기기도 한다. 데이터 처리 방법 오버피팅을 줄이기 위해서 데이터를 조작하는 방법을 사용할 수 있다. 학습 데이터셋과 테스트 데이터셋을 구분해서 사용한다. 학습 : 테스트 를 7:3 또는 8:2 정도로 사용하는 것이 일반적이다. 학습 데이터를 \u0026lsquo;학습\u0026rsquo; 데이터와 \u0026lsquo;검증\u0026rsquo; 데이터로 나눈다. 학습 데이터를 이용하여 모델을 학습시킨다. 학습을 시키면서 중간중간 검증 데이터를 이용하여 학습된 모델을 검증한다. 데이터를 학습시킬수록 \u0026lsquo;학습\u0026rsquo; 데이터에 대한 오차는 점점 줄어들지만, \u0026lsquo;검증\u0026rsquo; 데이터에 대한 오차는 일정 구간이 되면 증가하게 된다. \u0026lsquo;검증\u0026rsquo; 데이터 오차가 증가하는 시점이 over-fitting이 시작되는 구간이므로 학습을 중단한다. \u0026lsquo;검증\u0026rsquo; 데이터는 학습에 사용되지 않고, 검증에만 사용됨에 주의한다. Dropout 규제 방법 제프리 힌튼이 2012년에 제안한 방법 매 훈련 step에서 일정 node를 훈련에서 무시하는 방법이다. ex) node = {n1, n2, n3, n4} 가 있다면, step 1에서는 n1, n2만 있는 것 처럼 동작하고, step 2에서는 n3, n4만 있는 것 처럼 동작하고 \u0026hellip; 데이터를 증식한다. 관련 데이터를 모두 수집하는것이 최선이지만, 현실적으로 불가능하다. 대신 데이터를 증식하는 방법을 사용한다. 데이터 증식이란, 실제와 같은 훈련 데이터를 생성한다. 데이터 증식은 인공적으로 만든 샘플과 실제 데이터를 구분할 수 없어야 한다. 백색소음(white noise)를 추가하는 것은 도움이 되지 않는다. 의미있는 학습 데이터가 필요하다. 데이터 증식은 이미지 데이터를 처리할 때 매우 유용하다. 이미지는 확대, 축소, 이동, 회전, 반전 등을 통해 하나의 이미지로 여러 데이터를 만들 수 있다. K겹 교차 검증의 이해 데이터 셋을 학습용과 테스트용으로 나누었을 경우, 테스트에 사용되는 데이터는 극히 일부밖에 되지 않는다 데이터 셋을 k등분 하여, 테스트 셋과 학습 셋을 돌려가며 사용하는 방법을 k겹 교차검증이라 한다. 전체 데이터를 5개로 나누었다 가정하고, 나눈 데이터의 덩어리를 각각 d1, d2, d3, d4, d5라 하자 이때 d1을 테스트 데이터로 사용, 나머지를 훈련 데이터로 사용한 경우 결과를 R1이라 하자 d2를 테스트 데이터로 사용, 나머지를 훈련 데이터를 사용한 경우 결과를 R2라 하자 d3, d4, d5도 마찬가지로 하여 R3, R4, R5를 도출해 낸다. R1~R5를 모두 합치면 최종 결과가 나온다. 데이터를 5등분 했으므로, 위 방법은 5겹 교차검증이 된다. from tensorflow.keras.models import Sequential\rfrom tensorflow.keras.layers import Dense\rfrom sklearn.preprocessing import LabelEncoder\rfrom sklearn.model_selection import StratifiedKFold\rimport numpy\rimport pandas as pd\rimport tensorflow as tf\rnumpy.random.seed(777)\rtf.random.set_seed(777)\rdf = pd.read_csv(\u0026#39;sonar.csv\u0026#39;, header=None)\rdataset = df.values\rx_data = dataset[:,0:60].astype(float)\ry_data = dataset[:,60]\r# y_data를 one-hot 으로 처리해 준다.\re = LabelEncoder()\re.fit(y_data)\ry_data = e.transform(y_data)\r# k-fold 알고리즘을 사용할 객체를 형성한다.\r# n_splits : 10등분하여 사용할 것이다.\r# shuffle : 섞어서 사용할 수 있도록 허용\r# random_state : shuffle 사용시 사용할 랜덤한 seed 값\rn_fold = 10\rskf = StratifiedKFold(n_splits=n_fold, shuffle=True, random_state=48)\raccuracy = []\r# skf.split() 함수를 통해 x_data와 y_data를 k-fold 알고리즘에 맞게 분해하여 반환한다.\r# for문을 통해 데이터를 반복하여 학습을 수행한다.\rfor train, test in skf.split(x_data, y_data):\r# 모델을 구성한다.\r# 활성함수로 sigmoid, 오차함수로 binary-crossentropy를 사용할 것이다.\rmodel = Sequential()\rmodel.add(Dense(30, input_dim=60, activation=\u0026#39;relu\u0026#39;))\rmodel.add(Dense(10, activation=\u0026#39;relu\u0026#39;))\rmodel.add(Dense(1, activation=\u0026#39;sigmoid\u0026#39;))\rmodel.compile(loss=\u0026#39;binary_crossentropy\u0026#39;,\roptimizer=\u0026#39;adam\u0026#39;,\rmetrics=[\u0026#39;accuracy\u0026#39;])\rmodel.fit(x_data[train], y_data[train], epochs=100, batch_size=5)\rk_accuracy = \u0026#34;%.3f\u0026#34; % (model.evaluate(x_data[test], y_data[test])[1])\raccuracy.append(k_accuracy)\rprint(\u0026#34;\\n %.f fold accuracy:\u0026#34; % n_fold, accuracy)\r# 결과값은 데이터에 따라 달라질 수 있다. 학습에 사용된 데이터가 편향되어 있는 경우 평가 결과가 떨어지는 모습을 볼 수 있다.\r# k-fold 알고리즘을 사용하면 이러한 경우를 예방할 수 있다. 이미지 데이터 모델링 MNIST 는 대표적인 이미지 모델링 데이터로, 70,000개의 글자 이미지에 각각 0부터 9까지 정답이 포함되어있는 데이터 셋이다.\ntrain data 6만개, test data 1만개로 나누어져 있다. 이미지 크기는 28 by 28 크기로 구성되어 있고, 각 픽셀은 0~255 사이의 밝기 값을 가진다. 이미지 데이터를 학습할 때는 전처리가 필요하다. MNIST를 예로 들어 알아보자.\n이미지 데이터는 2차원 데이터이다. 이를 1차원 데이터로 직렬화 하여야 학습이 가능하다. reshape() 함수를 이용하여 784개의 속성을 가진 1차원 배열로 바꿔준다. 0~255 값은 데이터 폭이 큰 편이다. 데이터 폭이 크면 분산이 커지므로 이를 줄여주는것이 좋다. normalization 을 하거나, scaling을 해 준다. max 값이 정해져 있으면 단순히 값을 max로 나눠주면 0~1 구간으로 scaling이 된다. max 값이 미정인 경우는 min-max scaler를 사용할 수 있다. (요소값 - 최소값) / (최대값 - 최소값) 결과 값이 0~9의 class로 나뉘기 때문에 one-hot encoding을 통해 y 값을 전처리 해준다. CNN 연속하는 layer 상의 모든 node들이 서로 연결되어있는 형태를 \u0026lsquo;fully connected layer\u0026rsquo;(FC layer) 라고 한다. 한 장의 컬러 사진은 3차원 데이터이다. 이를 FC 신경망을 이용하여 학습할 시 제약이 많다. 이러한 다차원 데이터 학습을 손실 없이 사용할 수 있도록 만든 모델이 Neural Network이다. 그 중 Convolution Neural Network를 사용하면 이미지의 공간 정보를 유지한 채로 학습이 가능하다. CNN 과 FCNN 비교 Fully Connected Neural Network는 2차원 그림을 1차원으로 재구성하여 학습시켰다. CNN은 2차원 배열을 특정 그룹(Kernal, filter)으로 나누어 특징을 추출하는 형태로 학습시키기 때문에 입출력 데이터에 대한 형상 유지가 가능하다. 이미지 공간 정보를 유지하기 때문에 인접 이미지에 대한 특징을 효과적으로 인식할 수 있다. 여러개의 filter(kernal)을 사용함으로써 다양한 특징을 추출하여 학습할 수 있다. filter를 공유 파라미터로 사용하기 때문에 FCNN 보다 학습 파라미터가 적다. CNN 이론 CNN 은 이미지의 특징을 추춣해 내는 부분과, 클래스를 분류하는 부분으로 구성된다. CNN을 통해 특성별로 분류를 하면, fully connected neural network로 값을 전달하여 원하는 class 를 판단하도록 한다. 필터, 커널, 윈도우 라고 부르는 m by n lalyer를 정의한다. 필터는 원본 데이터보다 크기가 작아야 한다. 필터도 각 픽셀마다 값을 갖고 있다. 전체 이미지 위에 필터를 겹쳐놓았을 때, 필터와 원본 이미지가 맞닿는 부분을 서로 곱한 다음, 모든 결과물을 합한다. 필터를 한 픽셀씩 움직여 가며, 위 계산을 반복하고, 그 결과물을 m by n 형태로 정렬하면, convolved layer 결과물을 얻을 수 있다. 채널 한 이미지에 대해 여러 겹으로 쌓여져 있는 형태를 채널이라 한다. 컬러를 표현하기 위해서는 R,G,B 세 색깔의 채널을 합하면 된다. 색상이 많을수록 채널은 많아진다. 필터 일반적으로 (3,3), (4,4) 와 같은 정사각형 행렬로 정의된다. CNN에서 학습의 대상은 필터 파라미터이다. (필터 안의 픽셀 값) 필터를 사용해 원본 데이터를 순회하며 채널별로 합성곱을 구하고, 모든 채널의 합성곱을 다시 합해 Feature Map으로 만든다. 입력 데이터가 여러 채널을 가지는 경우, 필터도 채널의 갯수에 맞게 가져야 한다. 각 채널별로 필터를 적용하여 feature map을 구하고, 최종적으로 모든 채널의 feature map을 합산하여 최종 feature map을 도출한다. 스트라이드 (stride) 필터를 순회하는 간격을 stride라 한다. stride는 (1,1) 과 같은 형태로 표현한다. (가로로 1칸씩 이동, 세로로 1칸씩 이동) stride와 필터의 크기로 feature map 크기가 결정된다. padding 원본 데이터의 테두리에 0으로 채운 dummy pixel을 넣어줌으로써 feature map의 크기와 원본의 크기가 같아지도록 하는 것 pooling 필터를 사용해 얻어낸 convolution layer의 모든 값을 더하는게 아닌, 특정 데이터만 뽑아서 feature map을 구성하는 방법이다. 출력 데이터의 크기를 줄이거나 데이터를 강조하는 용도로 사용한다. 방법에 따라 max pooling, average pooling, min pooling 등이 있다. from tensorflow.keras.datasets import mnist\rfrom tensorflow.keras.utils import to_categorical\rfrom tensorflow.keras.models import Sequential\rfrom tensorflow.keras.layers import Dense, Dropout, Flatten, Conv2D, MaxPooling2D\rimport matplotlib.pyplot as plt\rimport numpy as np\rimport tensorflow as tf\rnp.random.seed(3)\rtf.random.set_seed(3)\r(x_train, y_train), (x_test, y_test) = mnist.load_data()\r# 4차원형태 데이터 구성\r# [batch, x size, y size, channel]\rx_train = x_train.reshape(x_train.shape[0], 28, 28, 1).astype(\u0026#39;float32\u0026#39;)/255\rx_test = x_test.reshape(x_test.shape[0], 28, 28, 1).astype(\u0026#39;float32\u0026#39;)/255\ry_train = to_categorical(y_train)\ry_test = to_categorical(y_test)\rmodel = Sequential()\r# CNN 모델 구성\r# 커널을 32개, 크기는 3 by 3\r# 입력층, 28 by 28 크기에 1채널 사용, relu 사용\r# stride 는 설정 하지 않으면 (1,1) 이 기본\r# padding은 설정하지 않으면 없음.\r# padding이 없고 stride가 (1,1) 이기 때문에 결과값은 (26,26) 크기가 될 것\rmodel.add(Conv2D(32, kernel_size=(3, 3), input_shape=(28, 28, 1), activation=\u0026#39;relu\u0026#39;))\r# 커널 62개, 3 by 3\r# relu 사용\rmodel.add(Conv2D(64, (3,3), activation=\u0026#39;relu\u0026#39;))\r# pooling 사용\r# max pooling 방법, pool_size = 2 이므로, stride는 자동으로 (2,2) 가 된다. (pooling은 중복되게 필터를 설정하지 않음)\r# 결과값은 절반의 크기(12,12) 가 될 것\rmodel.add(MaxPooling2D(pool_size=2))\r# dropout layer\rmodel.add(Dropout(0.25))\r# FCNN 모델 구성, 결과값으로 classification\r# 입력값이 (12,12,64) 이다. 이를 직렬화(1차원 배열화) 시켜 준다.\rmodel.add(Flatten())\r# 128 node를 가진 hidden layer\rmodel.add(Dense(128, activation=\u0026#39;relu\u0026#39;))\r# FC에서 over-fitting이 두드러지기 때문에 더 높은 값으로 dropout을 설정하였다.\rmodel.add(Dropout(0.5))\r# MNIST는 10개중 하나를 선택하므로, 출력 layer의 node는 10개로 설정, softmax 사용\rmodel.add(Dense(10, activation=\u0026#39;softmax\u0026#39;))\r# 모델 구조 확인\rmodel.summary()\r# 모델 학습 및 평가\rmodel.compile(loss=\u0026#39;categorical_crossentropy\u0026#39;,\roptimizer=\u0026#39;adam\u0026#39;,\rmetrics=[\u0026#39;accuracy\u0026#39;])\rresult = model.fit(x_train, y_train,\rvalidation_data=(x_test, y_test), # split 대신 직접 평가용 데이터를 지정하는 방법\repochs=30,\rbatch_size=200)\rprint(\u0026#39;loss \u0026amp; accuracy:\u0026#39;,model.evaluate(x_test, y_test))\ry_vloss = result.history[\u0026#39;val_loss\u0026#39;]\ry_loss = result.history[\u0026#39;loss\u0026#39;]\rx_len = np.arange((len(y_loss)))\rplt.plot(x_len, y_vloss, \u0026#39;.\u0026#39;, c=\u0026#39;red\u0026#39;, label=\u0026#39;validation loss\u0026#39;)\rplt.plot(x_len, y_loss, \u0026#39;.\u0026#39;, c=\u0026#39;blue\u0026#39;, label=\u0026#39;train loss\u0026#39;)\rplt.legend(loc=\u0026#39;best\u0026#39;)\rplt.show() FC layer를 사용하여 이미지 학습을 한 것 보다 CNN을 활용하여 학습을 한 것이 over-fitting 및 오차가 더 적음을 확인할 수 있다. CNN으로 이미지를 학습시키는게 더 효율적이다. RNN Recurrent Neural Network 로, 시계열 데이터를 처리하기 위한 모델이다.\n이전 데이터가 아후 데이터에 영향을 주는 데이터를 시계열 데이터라 한다. 데이터가 순서대로 입력되었을 때, 앞서 받은 데이터 처리 결과값을 잠시 기억해 놓는 방법을 사용한다.\n하나의 layer의 node간 연결되는 edge가 생긴다. 한 layer안 node들을 cell이라 칭한다. cell간 연결된 edge에는 \u0026lsquo;hidden_state\u0026rsquo; 데이터가 전달된다. x1 → [A1] → h1\rWhh ↓ h1\rx2 -Wxh→ [A2] → h2\r↓ h2\rx3 → [A3] → h3 RNN 에서 한 layer 내부의 node간 edge에 있는 weight는 hyperbolic tangent를 이용한다. h_t = f(h_t-1, x_t) = tanh(x) = tanh(W_hh * h_t-1 + W_xh * x_t)\nRNN 모델링 RNN 모델은 \u0026lsquo;3 tensor\u0026rsquo;를 사용한다. 3 tensor의 각 요소는 아래와 같다. batch : 데이터 set의 개수 time step : 데이터 한 set에서 데이터의 개수 input dimension : 입력 데이터를 one-hot encoding 했을 때 크기 output, hidden_state = SimpleRnn(3, return_state=True, return_sequences=True)(input) : 결과값으로 크기 3인 데이터를 반환 input으로는 3차원 배열이 필요, batch, time step, input dimension 을 고려한 형태 return_sate가 true이면 output을 반환, 아니면 hidden_state(마지막시점 state)만 반환 return_sequences가 true면 output으로 3차원 값 (각 batch별 학습결과)를 전달, false면 2차원(최종 결과)를 반환 hidden_state 에는 LSTM RNN은 gradient에 의한 vanishing 문제가 크다. 이를 개선하기 위한 모델이 LSTM 이다. Long Short Term Memory, 중요한 데이터는 길게 기억하고 중요하지 않은 데이터는 짧게 기억한다. 데이터를 다음 cell에 넘길지 말지 판단하는 절차를 거친다. LSTM에서는 \u0026lsquo;hidden_state\u0026rsquo;에 더해 \u0026lsquo;cell_state\u0026rsquo; 값을 추가로 전달한다. cell_state 는 과거로부터 전달되는 값들을 유지할 수 있도록 한다. LSTM 에서는 Gate 가 추가된다. 데이터를 얼마나 통과할지 필터링 해주는 역할이다. 총 3개(forget, input, output)의 gate가 있다. 각각 데이터를 얼마나 잊을지, 입출력으로 들어온 데이터 양 조절을 관장한다. Gate Input Gate 최종 cell_state에 현재 cell의 cell_state 값을 얼마나 적용할지 설정 i_t = σ(W_i * [h_t-1, x_t] + b_i) : hidden_state와 입력값에 input gate의 weight, bias를 적용한 후 sigmoid를 취함. Forget Gate sigmoid 함수로 cell_state 값을 얼마나 통과시킬지 설정 forget gate도 weight와 bias가 존재한다. (W_f, b_f) f_t = σ(W_f * [h_t-1, x_t] + b_f) : hidden_state와 입력값에 forget gate의 weight, bias를 적용한 후 sigmoid를 취함. Output Gate 최종 cell_state 값으로 최종 hidden_state 값이 얼마나 출력될지 결정\no_t = σ(W_o * [h_t-1, x_t] + b_o) : hidden_state와 입력값에 output gate의 weight, bias를 적용한 후 sigmoid를 취함.\nC_t = f_t * C_t-1 + i_t * C'_t : 최종 cell_state는 (forget gate를 통과한 이전 cell_state) + (hidden_state와 입력값으로 hidden_state를 계산하고, input gate를 통과시킨 값)이다.\nC'_t = tanh(W_c * [h_t-1, x_t] + b_c) : C\u0026rsquo;_t 값은 입력값과 hidden_state로 현재 cell의 cell_state를 구하는 식이다. 이를 input gate에 통과시키면 i_t * C'_t 값이 된다. C_t-1 은 이전 cell에서 받은 cell_state 이다. 이를 forget gate에 통과시키면 f_t * c_t-1 값이 된다. h_t = o_t * tanh(C_t) : 최종 cell_state 를 hyperbolic tangent 취한 값에 output gate를 적용하면 최종 hidden_state 값이 결정된다.\nLSTM은 기본 RNN보다 복잡하지만 훨씬 더 좋은 성능을 낼 수 있다.\n모델 딥 러닝을 위한 신경망 구조를 모델이라 한다 모델 정의 방법과 최적화 x 데이터는 attribute, y 데이터는 class라 칭한다. 입력층, 은닉층, 출력층 구성 아래 내용들은 일반적인 경우에 해당하는 경우이므로, 실제 모델 정의시에는 직접 확인해볼 필요가 있다. 데이터에 맞게 입력층의 node 개수를 결정한다. 얕은 신경망보다 심층 신경망이 효율적인 파라미터를 구성한다. (하나씩 layer를 늘려가 본다.) 은닉층의 노드 개수를 입력 노드 개수보다 많이 편성한다. (무조건은 아니므로 확인 필요) 결정할 수 있는 데이터를 조금씩 줄여 깔때기 모양으로 은닉층을 설정하는게 좋다. (갈수록 node 개수를 줄여감) 첫 은닉층의 노드 개수는 과대적합(over fitting)이 시작되기 전까지 뉴런 수를 점진적으로 늘리는 것이 좋다. 은닉층이 많아질수록 ReLU 함수를 사용하는것이 좋다.(vanishing 현상 방지) 출력층의 활성화 함수를 결정하고, 출력층의 활성화 함수에 따라 오차함수도 결정한다. 둘중 하나를 선택한다면 sigmoid 함수와 binary_crossentropy 를 사용한다. 다중분류 모델링 데이터의 속성에 맞게 입력 node의 수 구성 문자열로 된 class 값을 indexing 하고, one-hot-encoding으로 값을 변형해준다. class의 개수에 맞게 출력층 node 개수를 설정한다. 활성화 함수 및 오차방정식으로 softMax와 categorical cross-entropy를 적용한다. 생성 방법 tensorflow.keras.Sequential : Sequential 함수를 이용하는 방법 functional approach : 직접 함수를 구성하는 방법 tensorflow.keras.Model : Model 클래스를 상속하고 재정의하여 사용하는 방법 Keras.Sequential keras를 이용해서 sequential 모델을 생성하는 방법 model = Sequential() : sequential 한 layer 형태를 가진 모델을 생성 model.add(Dense(units =2, activation='sigmoid', input_dim = 2)) : layer 추가 node 수가 2개 activation function이 sigmoid 입력값이 2차원 형태 input_dim 인자는 첫번 째 layer에만 사용해 주면 된다. model.compile(loss='binary_crossentropy', optimizer='sgd', metrics=['accuracy']) : model 객체를 어떤 형태로 학습시킬지 정의 binary_crossentropy 를 loss function으로 설정 optimizer로 sgd 설정 실행될 때 마다 loss 값과 accuracy 값을 출력으로 보여줌 result = model.fit(x_train, y_train, epochs=50000, batch_size = 10, validation_split=0.3) : model에 training 실행 x_train, y_train : 학습용 x, y 데이터 epochs : 학습 데이터를 통해 반복 학습시킬 횟수 batch_size : 입력 데이터를 몇 묶음 단위로 전달할지 설정, 하나씩 학습하는 것 보다 학습률 출렁임이 더 안정적이다. validation_split : 데이터중 0.3%는 검증용으로 사용, \u0026lsquo;validation_data\u0026rsquo; 로 직접 데이터를 전달할 수도 있음 result : result.history 에서 \u0026rsquo;loss\u0026rsquo;, \u0026lsquo;val_loss\u0026rsquo;, \u0026lsquo;accuracy\u0026rsquo;, \u0026lsquo;val_accuracy\u0026rsquo; 키워드로 loss, accuracy 값 확인 가능 model.layers[0].get_weights()[0] : model.layers 는 입력 layer을 0번째 index로 하여 특정 layer를 반환 get_weights() 는 해당 layer의 [weight, bias] 를 담고 있는 배열을 반환 model.predict(x_predict) : 학습된 모델에 x_predict 값을 넣을 시 특정 y 값을 추정하여 반환하는 함수 model.evaluate(x_data, y_data) : 학습된 모델에 입력값(x_data)과 정답(y_data) 를 전달받아 [loss, accuracy] 를 반환하는 함수 ","permalink":"https://AswinBlue.github.io/post/tensorflow/","summary":"#Tensorflow\nTensorFlow는 구글에서 수치연산을 위해 만든 라이브러리이다. 기본 개념 node와 edge로 구성된 graph를 이용해 수치 연산을 수행한다. node들은 특정한 데이터가 들어오면 연산을 수행하거나, 형태를 변경하거나, 결과를 출력하는 역할을 한다.\nedge는 학습데이터가 저장되는 다차원 배열이다.\nedge는 node에서 계산된 데이터를 다음 node로 이동시킨다.\nedge는 방향성이 있으며(directed), tensor라 불린다.\narchive.ics.uci.edu/ml 에서 학습용 데이터를 받아 사용할 수 있다.\n설치 python과 pip를 설치한다. pip install tensorflow 명령을 수행한다. window에서 \u0026lsquo;client_load_reporting_filter.h\u0026rsquo; 파일을 찾지 못해 설치를 못했다면, path 경로가 너무 길어서 발생하는 오류이다.","title":"Tensorflow"},{"content":"#kivy\nBasic concepts Widget 어플리케이션을 구성하는 객체 widget은 다른 widget을 tree형태로 포함 가능하며 버튼, 라벨 등상호작용 가능한 객체 또는 Widget의 집합 위치는 좌표로 표현되는데 좌표는 좌측하단이 (0,0)이다. Layout 화면 구성을 설정한 요소 widget 혹은 layout을 포함 가능하다. structure main.py에 python으로 내용을 작성한다. class TheLabApp(App):\rpass\rTheLabApp().run() main.py에서 선언한 class \u0026lsquo;TheLabApp\u0026rsquo; 에서 App을 뺀 TheLab을 따서 main.py와 같은 경로에 \u0026lsquo;TheLab.kv\u0026rsquo;파일을 생성한다. /\r|-main.py\r|-TheLab.kv .py파일에서 원하는 layout class를 상속받아 객체를 구성할 수도 있고, .kv파일에서 바로 작성할 수도 있다. 단, .kv파일에서 객체를 생성하려면 .py파일에 정의된 class를 사용해야 한다. \u0026lt;EXAMPLE@BoxLayout\u0026gt; 와 같이 .py파일의 class 선언을 생략하고 default 객체를 사용하는 방법도 있다. ///////// .py /////////\rclass Box(BoxLayout):\rpass\r///////// .kv /////////\r\u0026lt;Box\u0026gt;: # .py에서 정의된 Box객체를 사용 가능\rGridLayout: # 이후부터는 kivy에서 제공하는 객체들 사용 가능\rlabel:\rtext:\u0026#34;lb\u0026#34;\r\u0026lt;Box2@BoxLayout\u0026gt;: # .py파일에서 아무것도 하지 않는 객체를 선언하기 싫을 때 사용\r/////////////////////// ex) class 안에서 속성 설정 :self.orientation = \u0026quot;vertical\u0026quot; ex) kv파일에서 속성 설정 : orientation: \u0026quot;vertical\u0026quot; \u0026lt;NAME\u0026gt;형태로 선언한 객체는 다른 객체에서 사용할수 있게 된다. \u0026lt;Box\u0026gt;:\r...\r\u0026lt;Box2\u0026gt;:\rButton:\r...\rBox: # 사용자 정의 객체\r... .kv파일은 아래와 같이 구성된다. 화면을 구성하는 내용들의 속성을 정의하고 배치할 수 있다. MainWidget: # 화면에 표기할 객체(widget, layout, \u0026hellip;) : # widget 정의 Button: # widget 내부 항목 선언, kivy에서 지원하는 객체의 종류 text:\u0026ldquo;A\u0026rdquo; Button: text:\u0026ldquo;B\u0026rdquo;\n- .py파일에서도 화면을 구성할 수 있다. class LayoutExample(BoxLayout): # BoxLayout은 기본적으로 가로로 구성된다. def init(self, **kargs):\nsuper().init(**kargs) b1 = Button(text=\u0026ldquo;A\u0026rdquo;) # 객체를 생성 b2 = Button(text=\u0026ldquo;B\u0026rdquo;) self.add_widget(b1) # 객체를 layout에 추가 self.add_widget(b2)\nUsage layout BoxLayout 가로 혹은 세로로 차곡차곡 쌓아가는 레이아웃 AnchorLayout 화면의 각 모서리, 꼭지점, 정중앙 총 9개의 위치를 지정할 수 있는 레이아웃 GridLayout n행m열의 그리드를 나누고, 내용을 채우는 레이아웃 StackLayout n행m열의 표에 좌측상단부터 차곡차곡 쌓아가는 레이아웃. BoxLayout의 2차원형태 ScrollView 상하 또는 좌우로 스크롤이 가능한 화면 PageLayout 디스플레이간 slide를 통해 이동이 가능한 레이아웃 FloatLayout RelativeLayout ScatterLayout Commons size_hint : 레이아웃 내 객체의 비율 설정 layout 안의 객체는 size 조절이 불가능하다. (size: 설정 해도 적용 안됨) size_hint 값이 default로 설정되어있기 때문이다. size_hint값이 적용된 객체는 화면 크기에 따라 객체 크기도 함께 변경된다. size_hint값은 default 1,1로 설정되어있다. size_hint: None, None으로 설정한다면 size: 값을 설정할 수 있다. (화면 크기에 상관없이 고정된 크기를 가질 수 있게 된다.) ex) spacing:\u0026quot;10dp\u0026quot; : layout내부 요소간 간격 설정 BoxLayout orientation: \u0026quot;vertical\u0026quot;: 세로정렬(가로 : \u0026ldquo;horizontal\u0026rdquo;) \u0026lt;BoxLayoutSample\u0026gt;:\rorientation: \u0026#34;vertical\u0026#34;\rButton:\r# 배정받은 크기에 대해 가로비율 50%, 세로비율 60%로 설정.\rtext: \u0026#34;b1\u0026#34;\rsize_hint: .5, .6 AnchorLayout ahcnor_x:\u0026quot;center\u0026quot;: x축 정렬 위치, left, right, center 가능, default center ahcnor_y:\u0026quot;center\u0026quot;: y축 정렬 위치, top, bottom, center 가능, default center 객체를 순서대로 쌓는것이 아니라 지정한 자리에 그대로 넣는것이므로, 이전 객체는 이후에 나오는 객체에 덮어씌워질 수 있음 \u0026lt;AnchorExample\u0026gt;:\rButton:\rtext:\u0026#34;btn\u0026#34;\rsize_hint: .2, .2\rpos_hint:{\u0026#34;X\u0026#34;:.1, \u0026#34;Y\u0026#34;: .1}\rButton:\rtext:\u0026#34;btn2\u0026#34;\rsize_hint: .1, .1\rpos_hint:{\u0026#34;X\u0026#34;:.5, \u0026#34;Y\u0026#34;: .5} GridLayout rows: Grid의 행 개수를 선언한다. default 1 cols: Grid의 열 개수를 선언한다. default 1 size_hint로 내부 요소의 비율을 조절하고 싶을 때, 같은 행/열에 속한 값들도 모두 같은 값으로 설정해야 적용이 된다. 설정한 Grid를 초과하는 객체를 선언하면 Widget에서 객체를 생성한것으로 취급된다. \u0026lt;GridExample@GridLayout\u0026gt;:\rrows: 2\rcols: 3\rButton: # 0,0\rtext: \u0026#34;btn\u0026#34;\rsize_hint: .5, 1 # 비율 조정\rButton: # 0,1\rtext: \u0026#34;btn\u0026#34;\rsize_hint: None, 1\rwidth:\u0026#34;100dp\u0026#34; # 고정된 크기\rButton: # 0,2\rtext: \u0026#34;btn\u0026#34;\rButton: # 1,0\rtext: \u0026#34;btn\u0026#34;\rsize_hint: .5, 1\rButton: # 1,1\rtext: \u0026#34;btn\u0026#34;\rsize_hint: None, 1\rwidth:\u0026#34;100dp\u0026#34; # 고정된 크기\rButton: # 1,2\rtext: \u0026#34;btn\u0026#34;\rButton: # out of bound\rtext: \u0026#34;btn\u0026#34;\rpos:100, 200 StackLayout 내부 객체들을 가로 한줄로 나열한다. 한 줄에 있는 객체들의 비율이 100%를 넘어가면 다음줄부터 객체를 채워넣는다. 가로 혹은 세로는 가장 큰 크기의 객체에 맞춰져 grid형식으로 정렬된다. \u0026lt;StackExample\u0026gt;:\rButton:\rtext:\u0026#34;btn\u0026#34;\rsize_hint: .3, .3\rButton:\rtext:\u0026#34;btn\u0026#34;\rsize_hint: .3, .4\rButton:\rtext:\u0026#34;btn\u0026#34;\rsize_hint: .3, .5\rButton: # 가로비율이 1을 넘어가기때문에 줄바뀜됨\rtext:\u0026#34;btn\u0026#34;\rsize_hint: .3, .5\rButton:\rtext:\u0026#34;btn\u0026#34;\rsize_hint: .4, .5\rButton:\rtext:\u0026#34;btn\u0026#34;\rsize_hint: .3, .5\rButton: # 세로 비율상으로 1을 넘어가기 때문에 화면 밖으로 나가서 보이지 않음\rtext:\u0026#34;btn\u0026#34;\rsize_hint: .3, .5 고정된 크기로 wiwdget을 추가하면 화면 크기가 변함에 따라 widget의 행,열이 변경된다. class로 설정을 할 수도 있다. 이때 class의 __init__에 설정한 내용이 .kv파일에서 설정한 내용보다 우선하여 적용된다. class StackExample(StackLayout):\rdef __init__(self, **kwargs):\rsuper().__init__(**kwargs)\rfor i in range(0, 10):\rsize = dp(100) # dp로 크기 선언법\rb = Button(text=str(i + 1), size_hint=(None, None), size=(size, size)) # 버튼 세팅\rself.add_widget(b) # layout에 widget 추가 Widgets 기본크기 100 X 100, 기본위치 (0,0) 이다. Commons pos_hint: 정렬 위치 size_hint등으로 비율을 조절하면 기본적으로 좌측 상단으로 정렬이 된다. 이때, 다른 방향으로 정렬을 하려면 pos_hint:{\u0026quot;x\u0026quot;:.5, \u0026quot;y\u0026quot;:.5}와 같이 설정 가능하다. pos_hint: 다음에는 dictionary가 와야하며, 두 개의 항목이 들어간다. 첫번째 인자는 \u0026ldquo;x\u0026rdquo;, \u0026ldquo;center_x\u0026rdquo;, \u0026ldquo;right\u0026rdquo; 중 하나를 사용하며, 두번째 인자는 \u0026ldquo;y\u0026rdquo;, \u0026ldquo;center_y\u0026rdquo;, \u0026ldquo;top\u0026rdquo; 중 하나를 사용한다. pos_hint:{\u0026#34;x\u0026#34;:.5} # 좌측부분을 50%위치로 설정\rpos_hint:{\u0026#34;center_x\u0026#34;:.5} # 중앙을 50%위치로 설정\rpos_hint:{\u0026#34;right\u0026#34;:.5} # 우측부분을 50%위치로 설정 Button 텍스트, 크기, 위치를 지정한 버튼 아래쪽에 있는 내용이 나중에 그려져 이전 내용을 덮어씌운다. MainWidget:\r\u0026lt;MainWidget\u0026gt;:\r# 고정 크기를 가진 버튼\rButton:\rtext: \u0026#34;Hello\u0026#34;\rsize: 400, 200\rpos: 100, 200\r# 기기 화면 크기에 따른 크기와 위치를 가진 버튼\rButton:\rtext: \u0026#34;hello2\u0026#34;\rsize: \u0026#34;400dp\u0026#34;, \u0026#34;200dp\u0026#34;\rpos: \u0026#34;100dp\u0026#34;, \u0026#34;200dp\u0026#34; lalbel 텍스트, 크기, 위치, 글자색을 지정한 레이블 MainWidget:\r\u0026lt;MainWidget\u0026gt;:\rLabel:\rtext: \u0026#34;Hello\u0026#34;\rsize: \u0026#34;100dp\u0026#34;, \u0026#34;80dp\u0026#34;\rpos: \u0026#34;100dp\u0026#34;\rcolor: 1, 2, 3, 1 # r, g, b, a 기타 .kv파일에서 동일한 이름의 객체를 여러개 정의하면, 하나의 정의로 보고 내용을 이어붙인다. \u0026lt;BoxLayoutSample\u0026gt; # layout 정의\rButton:\rtext:\u0026#34;A\u0026#34;\rsize_hint: \u0026#34;.1\u0026#34;\r...\r\u0026lt;BoxLayoutSample\u0026gt; # 동일한 이름의 layout 정의\rButton:\rtext:\u0026#34;B\u0026#34; #버튼 B는 버튼 A 다음에 생성됨\rsize_hint: \u0026#34;.1\u0026#34; .py 에서 class를 선언하고, .kv파일에서 해당 class를 사용한다면, .py의 init() 함수가 먼저 호출된 후 .kv파일에서 세팅한 내용이 적용된다. 참조 유튜브 강의 import:\nfrom kivy.app import App\rfrom kivy.uix.button import Button\rfrom kivy.uix.boxlayout import BoxLayout\rfrom kivy.uix.widget import Widget ","permalink":"https://AswinBlue.github.io/post/kivy/","summary":"#kivy\nBasic concepts Widget 어플리케이션을 구성하는 객체 widget은 다른 widget을 tree형태로 포함 가능하며 버튼, 라벨 등상호작용 가능한 객체 또는 Widget의 집합 위치는 좌표로 표현되는데 좌표는 좌측하단이 (0,0)이다. Layout 화면 구성을 설정한 요소 widget 혹은 layout을 포함 가능하다. structure main.py에 python으로 내용을 작성한다. class TheLabApp(App):\rpass\rTheLabApp().run() main.py에서 선언한 class \u0026lsquo;TheLabApp\u0026rsquo; 에서 App을 뺀 TheLab을 따서 main.py와 같은 경로에 \u0026lsquo;TheLab.kv\u0026rsquo;파일을 생성한다. /\r|-main.py\r|-TheLab.kv .py파일에서 원하는 layout class를 상속받아 객체를 구성할 수도 있고, .","title":"Kivy"},{"content":"Python 기본 내장 함수 입력 한줄 받기 : a = input()\n받은 값은 string 형태이다.\n받은 단어 끊어서 해석 : a, b = input().split() split() 함수 안의 인자에 따라 구분자 설정 가능. 빈칸이면 공백을 기준으로 끊어줌\n받은 단어 끊고 숫자로 변환 : a, b = map(int, input().split()) int 외 다른 형태도 사용 가능 출력 print()\n함수 함수 인자로 배열 형태를 표현할 때 *를 붙인다.\ndef func1(*arg)\rprint(*arg)\rfunc1(1, 2, 3) # 출력: [1, 2, 3] 숫자 읽기쉬운 숫자 표기: x = 10000 vs x = 10_000\n숫자 정의할 때 _를 중간에 넣어도 python은 숫자만 골라서 해석한다. 배열 오름차순 정렬: list.sort()\n튜플 두번째 인자 기준 오름차순 정렬: list.sort(key=lambda x:x[1])\n내림차순 정렬 : list.sort(reverse=True)\n라이브러리 numpy 기본 구문\nwhere(조건, 값1, 값2): 조건문이 참이면 값1, 거짓이면 값2를 반환. 3항연산자와 동일 bisect 오름차순으로 정렬된 배열에서 lower-bound, upper-bound 를 찾는 함수 bisect_left(list, x, key) : lower bound (x보다 같거나 큰 수들 중 최좌측 값의 위치)\nbisect_right(list, x, key) : upper bound (x보다 같거나 작은 수들 중 최우측 값의 위치)\n또는 lower bound (lower bound 를 찾았는데 동일 값이 존재할 경우 최우측 값의 위치)\nbisect(list, x, key) : bisect_right와 동일 tueple 적용 방법 : bisect(list_of_tuples, (3, None)) 형태로 사용하면 된다. 두 번째 인자에 튜플 형태를 넣어주면 됨. https://stackoverflow.com/questions/20908047/using-bisect-in-a-list-of-tuples\n","permalink":"https://AswinBlue.github.io/post/python/","summary":"Python 기본 내장 함수 입력 한줄 받기 : a = input()\n받은 값은 string 형태이다.\n받은 단어 끊어서 해석 : a, b = input().split() split() 함수 안의 인자에 따라 구분자 설정 가능. 빈칸이면 공백을 기준으로 끊어줌\n받은 단어 끊고 숫자로 변환 : a, b = map(int, input().split()) int 외 다른 형태도 사용 가능 출력 print()\n함수 함수 인자로 배열 형태를 표현할 때 *를 붙인다.\ndef func1(*arg)\rprint(*arg)\rfunc1(1, 2, 3) # 출력: [1, 2, 3] 숫자 읽기쉬운 숫자 표기: x = 10000 vs x = 10_000","title":"Python"},{"content":"Angular Angular JS와 Angular는 다르다. Angular JS는 초창기 Angular를 의미하고, 그냥 Angular는 Angular2 이상의 버전을 의미한다. javascript기반의 textscript를 사용한다. 확장자가 ts로 끝난다. 개발환경 세팅 nodejs 설치 $ sudo apt install npm :nodejs와 npm 동시에 설치 angular client 설치 $ npm install -g @angular/cli 명령어를 이용하여 설치 workspace 생성 client 설치가 완료되었으면 workspace를 생성하고 application을 생성한다.\n$ ng new \u0026lt;application_name\u0026gt; 명령어를 이용하여 설치한다.\nnodejs 버전이 낮다고 한다. github에서 받아서 빌드하여 써 보자.\n공식 사이트는 https://github.com/nodejs 이다.\n소스코드를 받아 빌드하는 내용은 없고, 바로 바이너리를 다운받기를 권장하는 듯 하다.\nhttps://nodejs.org/en/download/ 로 가서 리눅스용 바이너리를 받아보자.\n.xz 형태의 파일이다. $ tar -xvf \u0026lt;file_name\u0026gt; 로 압축을 푼다.\n압축을 푸니 안의 내용들이 /usr/lib/ 경로에 어울릴 것 같다. mv 명령으로 옮겨준다.\nbin 폴더 안의 내용은 링크로 /usr/local/lib/ 에 넣어준다.\nln -s /usr/lib/\u0026lt;file\u0026gt;/bin/\u0026lt;binary\u0026gt; /usr/local/lib/bin/\u0026lt;binary\u0026gt;\n다시 돌아와서 명령어를 수행하여 application을 생성한다. stylesheet format을 선택하라고 하는데, 가장 위에있는 CSS로 선택해 본다.\napplication 실행 application을 생성하면 현재 경로에 \u0026lt;application_name\u0026gt;에 해당하는 폴더가 생성된다. 테스트용으로 application을 실행해 보자. $ng serve --open 4200 포트로 서버 접속이 가능함을 알 수 있다. 방화벽 설정 방화벽이 아직 열려있지 않은 것 같다. 방화벽을 열어보자. iptables -I INPUT 1 -p tcp \u0026ndash;dport 12345 -j ACCEPT $sudo ufw allow 4200/tcp 프로젝트 구조 WORKSPACE src app : 화면을 구성하는 요소들의 root component, WORKSPACE와 같은 이름 \u0026lt;COMPONENT\u0026gt; : root component의 일부를 구성하는 component, 원하는만큼 추가 가능, [css, html, ts] 항목들이 기본 세트로 생성됨 COMPONENT.component.css : 기본적으로 비어있다. COMPONENT.component.html COMPONENT.component.ts : type script로 짜여진 코드, class들이 정의되어 있다. app.component.css app.component.html app.component.ts app.module.ts component view라는 단위의 화면을 구성하는 모듈 ng generate component COMPONENT_NAME 명령으로 workspace에 component 생성 가능 component를 생성하면 css, html, ts파일을 기본적으로 갖는다. component는 다른 component를 가질 수 있다. 최상위 component를 root component라고 한다. ts 파일 angular에서 제공하는 모듈을 import할 수 있다. class를 선언하고, component에서 사용할 기능(함수)을 구현한 후 export한다. component가 생성될 때 상위 component로 부터 input을 받을 수 있다. ts파일 문법 Component : Component를 사용하기 위한 기본 모듈 OnInit : Component 시작시 동작 정의, constructor 와 유사한 동작을 하지만 OnInit은 angular가 관할하고, constructor은 js가 관할하여 초기화하는 차이가 있다. Input : Component 생성시 상위 Component로 부터 받을 변수를 선언, 상위 Component에서는 해당 변수로 값을 집어넣어 줄 수 있다. Output : 상위 Component에서 사용할 수 있는 변수를 정의, Component에서 변수를 선언하면 상위 Component에서 해당 변수를 사용할 수 있다. @component 로 다음 class가 컴퍼넌트임을 표시한다. selector : 해당 component가 view에서 어떤 이름으로 표시될지 명명한다. (Tag 이름이 된다.) templateUrl : html 파일의 이름을 지정한다 styleUrls : css파일의 리스트를 나열한다. @Input() product; // product라는 변수로 input을 받겠다는 선언\r@Output() notify = new EventEmitter(); // notify 라는 변수를 상위 Component에서 사용 가능하게 하겠다고 선언\r// 한 component에서 다른 component를 호출할 때에는 ts 파일에서 정의한 이름을 태그로 생성한다.\r\u0026lt;app-product-alerts // 태그 이름이 곧 component 이름(selector에 정의한)이다.\r[product]=\u0026#34;product\u0026#34; // product라는 변수에 \u0026#34;product\u0026#34;라는 내용을 을 넣을 때 사용한다.\r(notify)=\u0026#34;onNotify()\u0026#34;\u0026gt; // notify라는 변수에서 이벤트가 들어오면 onNotify() 함수를 실행, (onNotify() 함수는 class 안에 정의되어 있어야 함)\r\u0026lt;/app-product-alerts\u0026gt; Routing app.modules.ts(main component의 ts파일) 파일에서 routing 설정이 가능하다. import { RouterModule } from \u0026#39;@angular/router\u0026#39;; // Routing을 위해 필요한 모듈\rimport { ProductListComponent } from \u0026#39;./product-list/product-list.component\u0026#39;;` // ProductListComponent라는 변수에 \u0026#39;./product-list/product-list.component파일을 대응\rimport { ProudctDetailsComponent } from \u0026#39;./product-detail/product-detail.component\u0026#39;;\r@NgModule({\rimports: [\rBrowserModule,\rReactiveFormsModule,\rRouterModule.forRoot([ // Router 모듈로 Routing 세팅\r{ path: \u0026#39;\u0026#39;, component: ProductListComponent }, // root 경로 \u0026#39;/\u0026#39; 에 위에서 ProductListComponent 변수에 대응시킨 파일을 매칭\r{ path: \u0026#39;products/:productId\u0026#39;, component: ProductDetailsComponent }, // 마찬가지로 \u0026#39;/products/{productId}\u0026#39; 에 ProudctDetailsComponent를 매칭\r])\r], ./product-detail/product-detail.component.ts 에서 아래와 같은 설정을 추가로 해주어야 한다. import { ActivatedRoute } from \u0026#39;@angular/router\u0026#39;; // routing을 당하는 곳에서 필요한 모듈\rexport class ProductDetailsComponent implements OnInit { // component 를 정의할 class 선언\rproduct; -\u0026gt; product 변수 선언\rconstructor(private route: ActivatedRoute,) // 라우팅 관련 정보를 route라는 변수에 받았다.\r{ } -\u0026gt; constructor 뒤에 붙여주는 형식, 비어있는 채로 둔다.\r}\rngOnInit() { // view 생성시 동작을 정의\rthis.route.paramMap.subscribe(params =\u0026gt; { // constructor에서 정의한 route를 참조하여\rthis.product = products[+params.get(\u0026#39;productId\u0026#39;)]; // this.product는 products[index] 값을 가진다. 이때 index는 app.modules.ts에서 설정한 값이다. (url 경로에서 \u0026#39;products/\u0026#39; 다음에 들어간 숫자값)\r});\r} ./product-detail/product-detail.component.html 에서 아래와 같이 설정한다. \u0026lt;h2\u0026gt;Product Details\u0026lt;/h2\u0026gt;\r\u0026lt;div *ngIf=\u0026#34;product\u0026#34;\u0026gt; // product에 값이 들어가 있다면 아래 수행. 즉, ts파일에서 대입시킨 products[idx] 값이 존재하면 아래 동작 수행\r\u0026lt;h3\u0026gt;{{ product.name }}\u0026lt;/h3\u0026gt; // json 형태의 값을 참조해 대입한다.\r\u0026lt;h4\u0026gt;{{ product.price | currency }}\u0026lt;/h4\u0026gt;\r\u0026lt;p\u0026gt;{{ product.description }}\u0026lt;/p\u0026gt;\r\u0026lt;/div\u0026gt; 문법 반복, 출력, 링크 \u0026lt;div *ngFor=\u0026#34;let product of products; index as productId\u0026#34;\u0026gt;\r/*\r*ngFor 은 반복을 뜻하는 예약어다. products 안의 원소를 하나씩 꺼내서 product 라 칭한다. 마치 java나 python의 ``for item in array`` 와 같다.\r\u0026#39;;\u0026#39; 로 구문을 구분할 수 있다.\rproductId 변수에 index를 대입한다.\r*/\r\u0026lt;a [title]=\u0026#34;product.name + \u0026#39; details\u0026#39;\u0026#34; [routerLink]=\u0026#34;[\u0026#39;/products\u0026#39;, productId]\u0026#34;\u0026gt;\r/*\r[title] 은 마우스를 올릴 때 나오는 텍스트를 뜻한다.\rrouterLink는 클릭시 넘어갈 링크이다. 링크를 []로 설정하면 []안의 내용을 appepnd 한 값을 의미한다. 즉 \u0026#34;/product/:productId\u0026#34; 의 주소를 나타낸다.\r\u0026#34;\u0026#34;안의 내용은 ts문법이고, 단순 텍스트는 \u0026#39;\u0026#39; 사이에 집어넣으면 된다.\r*/\r\u0026lt;h3\u0026gt;\r{{ product.name }} // product 객체의 name 필드를 출력한다.\r\u0026lt;/h3\u0026gt;\r\u0026lt;/a\u0026gt;\r\u0026lt;/div\u0026gt; 조건 \u0026lt;p *ngIf=\u0026#34;product.description\u0026#34;\u0026gt; // *ngIf는 조건문을 뜻하는 예약어다. product 객체에 description 필드가 존재하면 아래를 실행한다.\rDescription: {{ product.description }}\r\u0026lt;/p\u0026gt; 버튼 \u0026lt;button (click)=\u0026quot;share()\u0026quot;\u0026gt; (click)은 클릭 event 발생시 실행할 내용을 적는다. share()라는 함수를 실행하도록 연결한다.\n-\u0026gt; 요점 *ngFor *ngIf Interpolation {{ }} Property binding [ ] Event binding ( )\n","permalink":"https://AswinBlue.github.io/post/angular/","summary":"Angular Angular JS와 Angular는 다르다. Angular JS는 초창기 Angular를 의미하고, 그냥 Angular는 Angular2 이상의 버전을 의미한다. javascript기반의 textscript를 사용한다. 확장자가 ts로 끝난다. 개발환경 세팅 nodejs 설치 $ sudo apt install npm :nodejs와 npm 동시에 설치 angular client 설치 $ npm install -g @angular/cli 명령어를 이용하여 설치 workspace 생성 client 설치가 완료되었으면 workspace를 생성하고 application을 생성한다.\n$ ng new \u0026lt;application_name\u0026gt; 명령어를 이용하여 설치한다.\nnodejs 버전이 낮다고 한다. github에서 받아서 빌드하여 써 보자.","title":"Angular"},{"content":"Spring basic 설치 spring CLI를 설치한다. 직접 다운받아서 원하는 곳에 압축을 푼 후 PATH설정을 해 주는게 빠르다.\n참조 프로젝트 생성 CLI로 프로젝트를 생성해 보자. spring init --build=gradle -d=web -a=myApp -g=com.aswin.blue [location] --build=gradle 기본으로 maven을 사용하지만 gradle로 설정 가능하다. -d=web dependency를 web으로 설정 -a=myApp artifactId, 즉 project명을 설정한다. -g=com.aswin.blue 그룹 명을 설정한다. [location] 생성할 폴더를 지정한다. 없으면 새로 생성한다. 지정하지 않으면 zip 형태로 압축해서 생성한다. 설정 maven으로 프로젝트를 생성하면 pom.xml을 설정해야 한다. 각종 라이브러리를 플러그인 형태로 사용하려면 dependency와 repository 설정을해 줘야 한다. \u0026ldquo;https://mvnrepository.com/\u0026quot; 주소처럼 maven repository를 정리해 놓은 사이트에서 원하는 repository를 찾아서 dependency를 작성한다. repository 추가시 compile dependency를 확인하고 추가로 pom.xml을 작성한다. maven 사이트보다는 github의 readme를 더 신용하자, maven 사이트 업데이트가 안돼서 잘 동작하지 않는 것도 있다. 실행 maven 프로젝트의 실행에도 maven이 사용된다. mvn -X clean install exec:java -Dexec.args=\u0026quot;\u0026quot; 로 실행이 가능하다. -X 는 디버깅 로그 출력을 의미한다. -Dexec.args= 는 main 함수의 argv를 설정한다.\nspring 프로젝트는 mvn spring-boot:run 으로 실행시킬 수 있다. ","permalink":"https://AswinBlue.github.io/post/spring/","summary":"Spring basic 설치 spring CLI를 설치한다. 직접 다운받아서 원하는 곳에 압축을 푼 후 PATH설정을 해 주는게 빠르다.\n참조 프로젝트 생성 CLI로 프로젝트를 생성해 보자. spring init --build=gradle -d=web -a=myApp -g=com.aswin.blue [location] --build=gradle 기본으로 maven을 사용하지만 gradle로 설정 가능하다. -d=web dependency를 web으로 설정 -a=myApp artifactId, 즉 project명을 설정한다. -g=com.aswin.blue 그룹 명을 설정한다. [location] 생성할 폴더를 지정한다. 없으면 새로 생성한다. 지정하지 않으면 zip 형태로 압축해서 생성한다. 설정 maven으로 프로젝트를 생성하면 pom.xml을 설정해야 한다.","title":"Spring basic"},{"content":"Jython Java 환경에서 python을 실행하게 하는 방법 중 하나 역으로 Jython 환경에서 java를 실행 가능하기도 하다. spring에서 jython을 사용하는 방법에 대해 묘사하겠다. 설치 pom.xml에 의존성을 작성한다. pom을 사용하면 jython을 설치하지 않고 일부 동작이 실행되게 할 수 있지만, 외부 모듈 사용에는 제한적인 부분이 있기에 설치가 필요하면 설치를 해야한다. \u0026lt;!-- https://mvnrepository.com/artifact/org.python/jython --\u0026gt;\r\u0026lt;dependency\u0026gt;\r\u0026lt;groupId\u0026gt;org.python\u0026lt;/groupId\u0026gt;\r\u0026lt;artifactId\u0026gt;jython\u0026lt;/artifactId\u0026gt;\r\u0026lt;version\u0026gt;2.7.0\u0026lt;/version\u0026gt;\r\u0026lt;/dependency\u0026gt; 실행 PythonInterpreter 을 선언한다. 이후 execfile, exec 함수를 이용하여 python 문법을 사용 가능하다. PythonInterpreter jython;\rjython.execfile(PYTHON);\rjython.exec(\u0026#34;print(1+1)\u0026#34;); execfile로 특정 함수를 정의하였다면 그 아래에 있는 exec함수에서 함수를 호출할 수도 있다. ","permalink":"https://AswinBlue.github.io/post/jython/","summary":"Jython Java 환경에서 python을 실행하게 하는 방법 중 하나 역으로 Jython 환경에서 java를 실행 가능하기도 하다. spring에서 jython을 사용하는 방법에 대해 묘사하겠다. 설치 pom.xml에 의존성을 작성한다. pom을 사용하면 jython을 설치하지 않고 일부 동작이 실행되게 할 수 있지만, 외부 모듈 사용에는 제한적인 부분이 있기에 설치가 필요하면 설치를 해야한다. \u0026lt;!-- https://mvnrepository.com/artifact/org.python/jython --\u0026gt;\r\u0026lt;dependency\u0026gt;\r\u0026lt;groupId\u0026gt;org.python\u0026lt;/groupId\u0026gt;\r\u0026lt;artifactId\u0026gt;jython\u0026lt;/artifactId\u0026gt;\r\u0026lt;version\u0026gt;2.7.0\u0026lt;/version\u0026gt;\r\u0026lt;/dependency\u0026gt; 실행 PythonInterpreter 을 선언한다. 이후 execfile, exec 함수를 이용하여 python 문법을 사용 가능하다. PythonInterpreter jython;\rjython.","title":"Jython"},{"content":"Web Scrapping x-path /a/b/c/d/e/f/g/... 와 같이 특정 경로를 가진 개체를 가리키는 방법이다. //*[@id=\u0026quot;abcd\u0026quot;] // 는 모든 경로에서 찾겠다는 의미 는 모든 태그에 대해 찾겠다는 의미. *대신 TAG를 넣으면 \u0026lsquo;TAG\u0026rsquo; 라는 이름의 태그를 가진 항목에서만 검색함 @id=\u0026ldquo;abcd\u0026rdquo; 는 id라는 속성이 abcd 인 항목을 찾겠다는 의미 브라우저에서 자동으로 해줒기 때문에 보통은 걱정할 필요가 없다. 정규식 . : 하나의 문자 ^ : 문자열의 시작 $ : 문자열의 끝 * : 모든 문자 # : 하나의 숫자 정규식 참조 link\nUseragent 특정 페이지에서는 request 헤더를 확인하여 매크로 접속을 막는 경우가 있다. 서버에서는 useragent 정보를 확인하여 접속하는 웹 브라우저, 기기 등의 정보를 확인할 수 있다. 참조 https://www.youtube.com/watch?v=yQ20jZwDjTE https://www.w3schools.com/python/python_regex.asp\n","permalink":"https://AswinBlue.github.io/post/web_scrapping/","summary":"Web Scrapping x-path /a/b/c/d/e/f/g/... 와 같이 특정 경로를 가진 개체를 가리키는 방법이다. //*[@id=\u0026quot;abcd\u0026quot;] // 는 모든 경로에서 찾겠다는 의미 는 모든 태그에 대해 찾겠다는 의미. *대신 TAG를 넣으면 \u0026lsquo;TAG\u0026rsquo; 라는 이름의 태그를 가진 항목에서만 검색함 @id=\u0026ldquo;abcd\u0026rdquo; 는 id라는 속성이 abcd 인 항목을 찾겠다는 의미 브라우저에서 자동으로 해줒기 때문에 보통은 걱정할 필요가 없다. 정규식 . : 하나의 문자 ^ : 문자열의 시작 $ : 문자열의 끝 * : 모든 문자 # : 하나의 숫자 정규식 참조 link","title":"Web_scrapping"},{"content":"GDB 컴파일 컴파일 옵션에 -g 를 붙여야 디버깅이 가능 시작 gdb [파일이름] gdb 실행 후 file [파일이름] 디버깅 중 명령어 ▷breakpoint\nb [라인] : 해당 라인에 breakpoint 설정 b [함수명] : 해당 함수 시작점에 breakpoint 설정 b [파일명]:[라인] : 특정 파일 해당 라인에 breakpoin (ex : b test.cpp:10) tb : 임시 중단점 설정, 일회성 info b : breakpoint 확인 delete : 모든 brekapoint 삭제 delete [index] : 특정 breakpoint 삭제 cl [라인] : 해당 라인의 brekapoint 삭제 cl [함수] : 해당 함수의 breakpoint 삭제 cl : 모든 breakpoint 삭제 enable [index] : 해당 brekapoint 활성화 disable [index] : 해당 breakpoint 비활성화 condition [index] [조건] : 해당 breakpoint는 조건을 만족할 때에만 동작 (ex : condition 2 var_a == 0) ▷ 실행\nrun 지정된 파일을 실행 c : continue, 다음 breakpoint로 진행 n [숫자]: next, 해당 숫자만큼 다음 라인으로 진행. 숫자 생략가능 s [숫자]: step, 다음 라인이 함수라면 함수 내부로 이동. 해당 숫자만큼 진행. 숫자 생략 가능 k : 실행중인 프로그램 종료 ▷ 확인\nl : main을 기점으로 소스 출력 l [라인] : 해당 라인을 기점으로 소스 출력 l [함수] : 해당 함수를 기점으로 수스 출력 info locals : 지역변수들 확인 info variables : 전역변수 확인 p [변수] : 변수 값 확인 p *[배열]@[숫자] : 해당 숫자만큼 배열의 값 출력 p [구조체] : 구조체 주소 확인 p *[구조체] : 구조체 값 확인 p/t var : var 변수를 2진수로 출력 p/o var : var 변수를 8진수로 출력 p/d var : var 변수를 부호가 있는 10진수로 출력 (int) p/u var : var 변수를 부호가 없는 10진수로 출력 (unsigned int) p/x var : var 변수를 16진수로 출력 p/c var : var 변수를 최초 1바이트 값을 문자형으로 출력 p/f var : var 변수를 부동 소수점 값 형식으로 출력 p/a addr : addr주소와 가장 가까운 심볼의 오프셋을 출력 info registers : 레지스트 값 모두 확인 display [변수명] : 변수 값을 매번 화면에 디스플레이 display/[출력형식] [변수명] : 변수 값을 출력 형식으로 디스플레이 undisplay [디스플레이번호] : 디스플레이 설정을 없앤다 disable display [디스플레이번호] : 디스플레이를 일시 중단한다. enable display [디스플레이번호] : 디스플레이를 다시 활성화한다. 기타 q : 종료 ","permalink":"https://AswinBlue.github.io/post/gdb/","summary":"GDB 컴파일 컴파일 옵션에 -g 를 붙여야 디버깅이 가능 시작 gdb [파일이름] gdb 실행 후 file [파일이름] 디버깅 중 명령어 ▷breakpoint\nb [라인] : 해당 라인에 breakpoint 설정 b [함수명] : 해당 함수 시작점에 breakpoint 설정 b [파일명]:[라인] : 특정 파일 해당 라인에 breakpoin (ex : b test.cpp:10) tb : 임시 중단점 설정, 일회성 info b : breakpoint 확인 delete : 모든 brekapoint 삭제 delete [index] : 특정 breakpoint 삭제 cl [라인] : 해당 라인의 brekapoint 삭제 cl [함수] : 해당 함수의 breakpoint 삭제 cl : 모든 breakpoint 삭제 enable [index] : 해당 brekapoint 활성화 disable [index] : 해당 breakpoint 비활성화 condition [index] [조건] : 해당 breakpoint는 조건을 만족할 때에만 동작 (ex : condition 2 var_a == 0) ▷ 실행","title":"GDB"},{"content":"React basic 개발환경 설치 및 실행 node.js 로 만들어진 create-react-app 툴을 이용하면 손쉽게 react 앱을 생성할 수 있다. npm을 설치하고 아래 명령어를 수행하여 create-react-app을 설치한다. npm install -g create-react-app 원하는 경로에 들어가 프로젝트를 생성한다. create-react-app \u0026lt;NAME\u0026gt; : NAME 경로에 프로젝트 생성 주의 : 프로젝트가 생성되는 폴더명은 대문자를 사용할 수 없다. 실행 npm run start 를 수행하면 localhost:3000에서 웹페이지를 퍼블리싱한다. 기본 설정 실행 포트 package.json 파일에서 \u0026quot;proxy\u0026quot;: \u0026quot;http://localhost:3000/\u0026quot; 과 같이 입력하면 실행시 포트를 3000으로 설정할 수 있다. 기본 구조 /public/index.html 에서 기본 화면 구성 \u0026lsquo;root\u0026rsquo; 이름으로 된 division이 있는데, 이 division에 대한 설정은 javascript로 정의되어있다. src 경로에 javascript파일들 구성 \u0026lsquo;index.js\u0026rsquo; 에 메인 화면에 사용된 객체가 정의되어 있다. 아래 내용은 id가 \u0026lsquo;root\u0026rsquo; 인 division에 \u0026lsquo;App\u0026rsquo;을 적용하겠다는 의미이다.\nReactDOM.render(\r\u0026lt;React.StrictMode\u0026gt;\r\u0026lt;App /\u0026gt;\r\u0026lt;/React.StrictMode\u0026gt;,\rdocument.getElementById(\u0026#39;root\u0026#39;)\r); \u0026lsquo;index.js\u0026rsquo;에서 \u0026lt;App/\u0026gt; 라 되어있는 사용자 정의 태그를 생성했는데, App은 \u0026lsquo;App.js\u0026rsquo;에 정의되어 있고, \u0026lsquo;index.js\u0026rsquo;에서 \u0026lsquo;App.js\u0026rsquo;를 참조한다.\n\u0026lsquo;App.js\u0026rsquo;에서 선언된 \u0026lsquo;App\u0026rsquo; 이라는 이름의 함수가 반환하는 값이 \u0026lsquo;App\u0026rsquo;태그에 치환된다고 보면 된다.\n\u0026lsquo;App\u0026rsquo;이 함수가 아니라 class로 정의되어 있다면 \u0026lsquo;App\u0026rsquo; class의 \u0026lsquo;render()\u0026rsquo; 함수의 리턴값이 \u0026lsquo;App\u0026rsquo;태그로 치환된다.\n리턴값은 무조건 특정 태그 안에 들어가 있어야 한다. 태그로 감싸주도록 한다.\nsrc경로에 css파일 구성 index.css에서 css설정 구성 디렉터리 src 하위에 디렉터리를 만들 수 있고, 각 디렉터리에는 index.jsx 파일을 넣을 수 있다.\nindex.js 파일은 아래와 같이 디렉터리 안의 파일들에서 export 된 내용들을 export한다.\n// src/component/index.js\rexport { default as Navbar } from \u0026#39;./Navbar\u0026#39;; // src/component/Navbar.jsx에서 Navbar을 default로 export한 경우\rexport { Footer } from \u0026#39;./Footer\u0026#39;; // src/component/Footer.jsx에서 Footer을 export한 경우 이렇게 export 된 내용들을 다른 폴더에서는 디렉터리만 import 하고 해당 모듈을 사용할 수 있다.\n// src/App.js\rimport { Navbar Footer } from component ❗ 단, index.js에 의해 세팅이 되는 시점이 App.js가 랜더 되는 시점보다 느리다는점에 주의한다. 아래는 이 문제로 발생할 수 있는 오류.\n// component/index.js\rexport { default as Button } from \u0026#39;./Button\u0026#39;\r// App.js\rimport Navbar from \u0026#39;./component/Navbar\u0026#39; // navbar을 import하는 라인이 먼저 호출됨\r// component/Navbar.js\rimport { Button } from \u0026#39;.\u0026#39; // button을 import하기 전에 App.js에서 Navbar을 호출했기 때문에 오류 발생, App.js를 구성하지 못해 빈 화면이 보여짐 모듈 import / export 특정 모듈을 export하고, 이를 다른 파일에서 import하여 사용할 수 있다. export 방법으로는 default 방법과, 일반 방법이 있습니다. default 방법\n// A.jsx\rexport default A; // import A from \u0026#39;./A\u0026#39;\r// 혹은 import B from \u0026#39;./A\u0026#39;도 가능\rexport {default as A}; // import {A} from \u0026#39;./A\u0026#39; 일반 방법\n// A.jsx\rexport { A }; // inport { A } from \u0026#39;./A\u0026#39; 위 두가지 예시를 보면 알겠지만, default로 export를 하면 다른 파일에서 import를 할 때 중괄호 없이 import가 가능하며, 그 이름도 아무렇게나 정할 수 있다.\ndefault 없이 export를 하면 중괄호 안에서 받아야 하며, 변수 명도 동일해야 한다.\nimport나 export에는 wildcard * 을 사용할 수 있다. export * from \u0026#39;./A\u0026#39; // 보통 index.jsx에서 사용\rimport * as A from \u0026#39;./A\u0026#39; // A.jsx에서 export한 것들을 모두 받아와 A로 사용.\r// 받아온 컴포넌트는 A.name, A.number 와 같이 사용하게 됨 배포 npm run start로 \u0026lsquo;create-react-app\u0026rsquo;으로 만든 앱을 실행시킬 수는 있지만, 이는 개발자용 실행 방식이다. 웹 브라우저에서 페이지에 접속하고 다운로드받은 용량을 확인해보면 아무 기능이 없어도 MB단위가 다운받아짐을 확인할 수 있다. 이러한 상태로 배포를 하면 효율 및 보안 관점에서 적합하지 않다. npm run build 명령어를 수행하면 \u0026lsquo;build\u0026rsquo;라는 새로운 디렉터리와 데이터들이 생성된다. \u0026lsquo;build\u0026rsquo; 안에 있는 파일들은 공백 등을 제거하여 용량 및 보안에 최적화된 상태로 제공된다. 배포시에는 \u0026lsquo;build\u0026rsquo;디렉터리 안의 내용을 사용하면 된다. 웹서버의 최상위 디렉터리를 \u0026lsquo;build\u0026rsquo;로 설정하면 된다. npm install serve 명령어로 serve 툴을 설치한다. serve는 웹서버를 실행시키는 도구이다. serve -s build 명령어로 \u0026lsquo;build\u0026rsquo; 디렉터리를 root 디렉터리로 웹서버를 실행한다. 보통은 이렇게 일일이 작업을 수행하지 않고, npm run deploy 명령으로 package.json 파일에 기록된 설정대로 배포 작업을 자동화시킨다. github에 배포 create-react-app으로 프로젝트 생성 : create-react-app \u0026lt;NAME\u0026gt; gh-pages 설치(이미 설치시 생략가능) : npm install -g gh-pages git hub에서 원하는 이름으로 repository 생성( 이후 {repo-name} 로 지칭) 생성된 git repository와 react 폴더 연동한다. git init git remote add origin {your-repository-url} package.json파일 수정 ({username}은 github 계정 이름) \u0026ldquo;homepage\u0026rdquo; : \u0026ldquo;http://{username}.github.io/{repo-name}\u0026rdquo; \u0026ldquo;scripts\u0026rdquo;: {\u0026ldquo;predeploy\u0026rdquo;: \u0026ldquo;npm run build\u0026rdquo;, \u0026ldquo;deploy\u0026rdquo;: \u0026ldquo;gh-pages -d build\u0026rdquo;} 배포를 실행한다. npm run deploy gh-pages 라는 branch를 자동으로 생성하고, package.json에 설정한 \u0026lsquo;homepage\u0026rsquo; 주소에 react 페이지가 업로드된 것을 볼 수 있다. 문법 주석 React 는 react code(typescript)와 JSX(xml) 코드가 있다. typescript에서는 \u0026lsquo;//\u0026rsquo; 혹은 \u0026lsquo;/* */\u0026rsquo; 로 주석을 사용한다. JSX에서는 \u0026lsquo;{/* */}\u0026rsquo; 로 주석을 사용한다. 함수 일반 함수 javascript와 동일하게 선언 가능하다.\nfunction Subject() {\rreturn (\r\u0026lt;div\u0026gt;\r\u0026lt;a href=\u0026#34;/\u0026#34; onClick={ function(e) {\re.preventDefault();\rthis.props.onChangePage(); // 상위 컴퍼넌트로 부터 받은 함수 실행\r}\r\u0026lt;/div\u0026gt;\r); arrow 함수 FUNCTION_NAME = (VARIABLES) =\u0026gt; { BODY } 형태로 이루어져 있다.\nVARIABLES는 \u0026lsquo;,\u0026lsquo;로 나누어져 두개 이상의 인자를 선언할 수 있고, BODY에서 사용될 수 있다.\n위 함수를 호출하려면 FUNCTION_NAME(VARIABLES) 형태로 호출 가능하다.\nhighlightSquares = i =\u0026gt; {\rif (this.props.winningSquares.length \u0026gt; 0) {\rif (this.props.winningSquares.indexOf(i) \u0026gt; -1) {\rreturn \u0026#34;square winningSquares\u0026#34;;\r} else {\rreturn \u0026#34;square\u0026#34;;\r}\r} else {\rreturn \u0026#34;square\u0026#34;;\r}\r}; arrow 함수는 javascript를 반환할 수도 있고, html을 반환할 수도 있다. 방법은 아래와 같이 구분된다.\nconst js = () =\u0026gt; { // 함수 내용 }\rconst html = () =\u0026gt; ( // html ) 변수 hoisting : javascript에서는 변수를 scope(함수 혹은 블록)의 가장 위로 끌어올려서, 먼저 선언된것처럼 인식하는 기능이 있다. var var는 function-scoped 변수이다. 함수가 끝나기까지 해당 변수는 유지된다. (hoisting)\nvar를 block-scoped로 낮추기 위해서는 IIFE, \u0026lsquo;use strict\u0026rsquo; 등의 방법을 사용할 수도 있지만 let으로 선언하는게 빠르다.\nfunction TEST() {\rfor (var i = 0; i \u0026lt; 10; i++) {\rconsole.log(\u0026#39;i: \u0026#39;, i); // 정상출력\r}\rconsole.log(\u0026#39;i: \u0026#39;, i); // 정상출력\r}\rconsole.log(\u0026#39;i: \u0026#39;, i); // 오류 동일한 이름의 변수를 재선언할 수 있고, hoisting에 의해 나중에 선언한 변수를 먼저 사용할수도 있다. (오류를 일으키기 좋은 허용이다)\nvar A = 1\rvar A = 2 // 가능\rstr=\u0026#39;abcd\u0026#39; // 가능\rvar str let es2015에서 추가된 문법\n재선언 불가능\nhoisting 동작 안함\nlet A = 1\rlet A = 2 // 불가능\rA = 3 // 가능\rstr=\u0026#39;abcd\u0026#39; // 불가능\rlet str const es2015에서 추가\n선언과 동시에 값 할당 필요, 재정의 불가능\nhoisting 동작 안함\nconst A = 1\rconst A = 2 // 불가능\rA = 3 // 불가능\rstr=\u0026#39;abcd\u0026#39; // 불가능\rconst str // 불가능 선언없이 정의 아무 타입을 붙이지 않고 선언하면 전역변수로 선언된다.\nstr=\u0026#39;12345\u0026#39;\rA=5 string 문자열을 담는 변수로, 아래와 같은 함수들을 지원한다. contains(str) : 문자열 내에 주어진 문자열(str)이 포함되었는지 확인, 결과를 반환 배열 배열은 arr=[1, 2, 3] 과 같은 형태로 선언한다. arr=[,,,]과 같이 크기3(쉼표개수)의 배열 선언도 가능하지만, 배열의 요소는 undefined로 정의된다. arr = new Array(1,2,3)로 선언도 가능하다. 배열의 길이는 arr.length 로 추출 가능하다. 좌항에 배열 형태를 두어 배열의 요소를 각각 정의할 수 있다. [a, b, c] = [1, 2, 3] 이때, 일부 값을 무시할 수 있다. [a, , c] = [1, 2, 3] 전개 연산자(\u0026rsquo;\u0026hellip;\u0026rsquo;)을 이용하여 나머지 개체들을 통틀어 지정할 수 있다. [a, b, ...c] = [1, 2, 3, 4, 5] // a = 1, b = 2, c = [3, 4, 5] 전개 연산자 이후 다른 변수가 오면 오류가 난다. [a, b, ...c, d] = [1,2,3,4,5] // 오류 선언된 변수를 전개연산자로 다른 변수에 넣을수도 있다. ARRAY.indexOf(ITEM) : ARRAY 배열안의 ITEM의 index를 반환한다. var A = [1, 2, 3, 4, 5]\rvar B = [...A] // B = [1, 2, 3, 4, 5] 반복(순회) 배열 내용을 순회하는 방법은 다음과 같다. map 함수 var A = [1,2,3]\rA.map((a) =\u0026gt; {\r// 원하는 동작을 입력하면 된다.\r})\rA.map(Math.sqrt) // lambda함수 외 일반함수를 넣어도 된다. for-of var A = [1,2,3]\rfor (var a of A) {\r// java의 for( : ) 와 같다\r} 객체의 배열도 동일한 방법으로 순회가 가능하다. 다만 비구조화(destructing)가 포함된다. var B = [{a:1, b:2, c:3}, {a:4, b:5, c:6}]\rB.map({a,b,c} =\u0026gt; {\r// 원하는 동작 수행\r})\rfor (var {a:aa, b:bb, c:cc} of B) {\r// key가 마음에들지 않으면 재정의도 가능하다.\r} foreach map과 유사하게 동작한다. 하지만 map은 callback함수에서 조작한 내용으로 새로운 배열을 구성하고, foreach는 단순 반복만 수행한다. const lists = [\u0026#39;1\u0026#39;, \u0026#39;2\u0026#39;, \u0026#39;3\u0026#39;]\rreturn(\r// map\r{lists.map(element =\u0026gt; {\rconsole.log(\u0026#39;name\u0026#39;, element);\rreturn \u0026lt;div\u0026gt; {element} \u0026lt;/div\u0026gt;\r})} // -\u0026gt; \u0026lt;div\u0026gt;1\u0026lt;/div\u0026gt;, \u0026lt;div\u0026gt;2\u0026lt;/div\u0026gt;, \u0026lt;div\u0026gt;3\u0026lt;/div\u0026gt; 이 화면에 출력되고, 로그가 출력된다. // foreach\r{lists.foreach(element =\u0026gt; {\rconsole.log(\u0026#39;name\u0026#39;, element);\rreturn \u0026lt;div\u0026gt; {element} \u0026lt;/div\u0026gt;\r})} // -\u0026gt; 화면에는 아무것도 나오지 않고 로그만 출력된다.\r) 비교 filter 함수를 이용하여 조건에 맞는 요소만 선택 가능하다. var a = [1,2,3,4,5,6,7]\rvar b = a.filter(i =\u0026gt; i \u0026lt; 4); // b = [1,2,3] 객체 Json형태로 이루어져 있다. var obj = {'a':10, b:20} key값은 \u0026lsquo;\u0026lsquo;를 붙여도 되고 안붙여도 된다. value를 변수로 추출할때는 다음과 같이 수행한다. 이를 비구조화라 한다. var {a,b,c} = {a:1, b:2, c:3} // a==1, b==2, c==3 비구조화시 기본값을 설정할 수도 있다. var {a=1,b=2} = {a:10} // a==10, b==2. b=2를 설정하지 않으면 b==undefined 다른 key를 사용하고싶다면 다음과 같이 수행한다. var {a:one, b:two} = {a:10, b:20, c:30} // one==10, two==20, c==30 key값으로 사용불가능한 값이 올 경우 다음과 같이 비구조화 한다. var {'a-b-c':a_b_c, [key]:A_B_C} = {'a-b-c':10, 'A B C':20} // a_b_c = 10, A_B_C = 20 재구조화시 전개 연산자를 사용할 수 있지만, 전개연산자를 재정의 할 수는 없다. {a:A, ...rest} = {a:10, b:20, c:30} // rest:B 는 불가능 unpack 전개 연산자 ... 을 사용하여 객체 내용을 나열할 있다. ex)\nconst obj = () =\u0026gt; {\rvar value = \u0026#34;value\u0026#34;;\rvar onChange = () =\u0026gt; {console.log(\u0026#34;onchange\u0026#34;)}\rreturn {value, onChange};\r}\r...\r// 아래 두 줄은 같은 효과를 가진다.\r\u0026lt;input placeholder=\u0026#34;\u0026#34; {...obj}\u0026gt;\u0026lt;input/\u0026gt;\r\u0026lt;input placeholder=\u0026#34;\u0026#34; value = {obj.value} onchange={obj.onChange}\u0026gt;\u0026lt;input/\u0026gt; 복사 배열 var a = [1,2,3]\rvar b = [...a] // 깊은복사\rvar [...c] = a // 깊은복사\rvar d = a // 얕은복사 객체 var A = {one:1, two:2, three:3}\rvar B = {...A} // 깊은복사 : one==1, two==2, three==3\rvar C = {...A, three:30} // 깊은복사+값 할당 : one==1, two==2, three==30 조건 특정 조건을 만족할 때에만 내용이 출력되도록 한다.\n{CONDITION \u0026amp;\u0026amp; \u0026lt;div\u0026gt; ! \u0026lt;/div\u0026gt;} // CONDITION 이 true일 때만 '!'를 표시한다. 3항 연산자 : C, java의 3항 연산자와 동일\n\u0026lt;span\u0026gt;{A ? \u0026quot;True\u0026quot; : \u0026quot;False\u0026quot;}\u0026lt;/span\u0026gt; \u0026amp;\u0026amp; : 앞의 내용이 참이면 뒤의 내용 수행\n\u0026lt;span\u0026gt;{A \u0026amp;\u0026amp; \u0026quot;True\u0026quot;}\u0026lt;/span\u0026gt; promise 비동기 처리시 사용하는 객체 promise 객체는 async와 wait를 이용한다. async function f1() {} : async 함수 선언, f1 함수는 비동기로 동작하고, 내부에 await 구문을 사용할 수 있다. const var = await f1() : async 함수가 완료될 때 까지 대기하도록 await로 명시 Component React는 js파일에서 정의한 컴포넌트를 html로 컴파일 한다. ex) \u0026lsquo;Subject\u0026rsquo;라는 이름의 component를 생성해 본다. 생성된 \u0026lsquo;Subject\u0026rsquo;는 custom tag가 된다. HTML에서 tag를 호출하듯 사용 가능하다. class형태로 만들기 class Subject extends Component {\rrender() {\rreturn (\r\u0026lt;header\u0026gt;\r\u0026lt;h1\u0026gt;Hello\u0026lt;/h1\u0026gt;\r\u0026lt;/header\u0026gt;\r);\r}\r} 함수 형태로 만들기 function Subject() {\rreturn (\r\u0026lt;div\u0026gt;\r\u0026lt;h1\u0026gt;Hello\u0026lt;/h1\u0026gt;\r\u0026lt;/div\u0026gt;\r);\r} -\u0026gt; 함수형은 자원을 덜 사용하고, 선언하기 쉬운 장점이 있다.\n\u0026lsquo;index.js\u0026rsquo;가 default라 가정하고, \u0026lsquo;App.js\u0026rsquo;에서 App 객체 안에 \u0026lt;Subject\u0026gt;\u0026lt;/Subject\u0026gt; 와 같이 태그를 생성한다. (다른 파일에 선언했다면 해당 파일을 \u0026lsquo;App.js\u0026rsquo;에서 참조 필요)\n※ \u0026lsquo;App.js\u0026rsquo; 파일은 확장자가 js이지만 코드 문법은 javascript가 아니다. props props를 활용하여 js파일에서 컴포넌트 태그 생성시 속성을 설정 가능하다.\n\u0026lt;Subject title=\u0026quot;TITLE\u0026quot;, content=\u0026quot;CONTENT\u0026quot;\u0026gt; : title 값으로 \u0026ldquo;TITLE\u0026rdquo;, content 값으로 \u0026ldquo;CONTENT\u0026rdquo; 설정\nSubject 객체 생성시 {this.prop.title}, {this.prop.content}와 같이 참조하여 사용한다.\nfunction Subject() {\rreturn (\r\u0026lt;div\u0026gt;\r\u0026lt;h1\u0026gt;{this.prop.title}\u0026lt;/h1\u0026gt;\r\u0026lt;h2\u0026gt;{this.prop.content}\u0026lt;/h2\u0026gt;\r\u0026lt;/div\u0026gt;\r);\r} 응용하여 아래와 같은 활용도 가능하다.\nfunction Subject() {\r{title, content} = {this.prop}\rreturn (\r\u0026lt;div\u0026gt;\r\u0026lt;h1\u0026gt;{title}\u0026lt;/h1\u0026gt;\r\u0026lt;h2\u0026gt;{content}\u0026lt;/h2\u0026gt;\r\u0026lt;/div\u0026gt;\r);\r} state props는 부모 컴퍼넌트가 자식에게 설정해 주는 값이라면, state는 컴퍼넌트가 자기 자신을 위해 사용하는 값이다. state는 함수형에서는 사용 불가능하고 클래스형에서 사용 가능하다. 대신 함수형에서는 \u0026lsquo;훅\u0026rsquo; 이라는 기능을 이용해 state와 유사한 효과를 낼 수 있다. state 세팅 constructor : 컴퍼넌트가 생성되었을 때 최초로 실행되는 함수. 초기화를 담당한다.\nclass App extends Component {\rconstructor(props) {\rsuper(props); // constructor 함수 기본\rthis.state : { // state 초기화\rsubject:{title:\u0026#34;TITLE\u0026#34;, content: \u0026#34;CONTENT\u0026#34;}\r}\r}\rrender() {\rreturn (\r\u0026lt;div ClassName = \u0026#34;APP\u0026#34;\u0026gt;\r\u0026lt;Subject title={this.state.subject.title} content={this.state.subject.content}\u0026gt;\u0026lt;/Subject\u0026gt; // html형태의 return값 안에서 javascript문법을 사용하려면 \u0026#39;{}\u0026#39;로 묶어준다.\r\u0026lt;/div\u0026gt;\r);\r}\r} -\u0026gt; App 컴퍼넌트가 생성되면 초기 설정된 state 값으로 Subject 컴퍼넌트를 생성한다.\nindex.js -\u0026gt; App.js -\u0026gt; Subject.js 순으로 호출이 이루어지는데, index.js에서는 App.js의 상태값을 알지 못한다. 즉, 부모에게 자신의 정보를 노출하지 않고 은닉한다. state로 배열 사용\nclass App extends Component {\rconstructor(props) {\rsuper(props); // constructor 함수 기본\rthis.state = { // state 초기화\rsubject:{title:\u0026#34;TITLE\u0026#34;, content: \u0026#34;CONTENT\u0026#34;},\rcontents:[\r{id:1, title:\u0026#39;title1\u0026#39;, desc:\u0026#39;desc1\u0026#39;},\r{id:2, title:\u0026#39;title2\u0026#39;, desc:\u0026#39;desc2\u0026#39;},\r{id:3, title:\u0026#39;title3\u0026#39;, desc:\u0026#39;desc3\u0026#39;},\r]\r}\r}\rrender() {\rreturn (\r\u0026lt;div ClassName = \u0026#34;APP\u0026#34;\u0026gt;\r\u0026lt;TOC data={this.state.contents}\u0026gt;\u0026lt;/TOC\u0026gt;\r\u0026lt;/div\u0026gt;\r);\r}\r}\rclass TOC extends Component {\rrender() {\rvar lists = [];\rvar data = this.props.data;\rvar i = 0;\rwhile (i \u0026lt; data.length) {\rlists.push(\u0026lt;li key={i}\u0026gt;\u0026lt;a href={\u0026#34;/content/\u0026#34; + data[i].id}\u0026gt;{data[i].title}\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt;)\r/*\r* 반복문을 통해 여러 객체를 만들 때, react에서는 \u0026#39;key\u0026#39;라는 유니크한 속성을 요구한다.\r*\r*/\ri = i + 1;\r}\rreturn (\r\u0026lt;nav\u0026gt;\r\u0026lt;ul\u0026gt;\r{lists} // lists에 \u0026lt;li\u0026gt;태그들을 넣어놓은 것들이 그대로 출력된다.\r\u0026lt;/ul\u0026gt;\r\u0026lt;/nav\u0026gt;\r);\r}\r} ※ react에서는 props나 state가 바뀌면, 이를 사용하는 하위 컴퍼넌트들의 render() 함수가 모두 다시 호출된다. 즉, 화면이 재구성된다.\nrender component 안의 render() 함수는 실제로 랜더링할 때 사용할 로직 및 html 형태를 반환한다. render() 함수 안에서 javascript로 로직 구현이 가능하다.\nex) 조건문 class App extends Component {\rconstructor(props) {\rsuper(props); // constructor 함수 기본\rthis.state = { // state 초기화\rmode: \u0026#39;read\u0026#39;\r}\rrender() {\rvar _mode = state.mode;\rif (_mode == \u0026#39;read\u0026#39;) { // 조건문\r} else if (_mode == \u0026#39;write\u0026#39;) {\r}\rreturn (\r\u0026lt;div ClassName = \u0026#34;APP\u0026#34;\u0026gt;\r\u0026lt;TOC data={this.state.contents}\u0026gt;\u0026lt;/TOC\u0026gt;\r\u0026lt;/div\u0026gt;\r);\r}\r} return render() 함수의 return 값은 html 형태가 되어야 한다. 하지만 return 안에서도 {} 구문 안에서 간단한 문법은 사용 가능하다. 조건문 3항 연산자 : C, java의 3항 연산자와 동일\n\u0026lt;span\u0026gt;{A ? \u0026quot;True\u0026quot; : \u0026quot;False\u0026quot;}\u0026lt;/span\u0026gt; \u0026amp;\u0026amp; : 앞의 내용이 참이면 뒤의 내용 수행\n\u0026lt;span\u0026gt;{A \u0026amp;\u0026amp; \u0026quot;True\u0026quot;}\u0026lt;/span\u0026gt; {``} : 문자열 편집, 문자열 안에 연산을 추가할 수 있다.\n\u0026lt;div className={`bg-white' ${flag ? 'flex' : 'flex-2'}\\`}\u0026gt; 이벤트 버튼 클릭, 내용 변경 등 사건이 발생했을 때, 이벤트 함수가 호출된다.\nonClick html에서 onclick은 \u0026lsquo;C\u0026rsquo;가 소문자이지만, react에서는 대문자이다.\nonClick은 인자로 함수를 받는다.\n인자로 들어가는 함수는 \u0026rsquo;event\u0026rsquo; 객체를 인자로 받는다. 이 함수를 이벤트 함수라 한다. class App extends Component {\rconstructor(props) {\rsuper(props); this.state = {}\r}\rrender() {\rreturn (\r\u0026lt;div\u0026gt;\r\u0026lt;a href=\u0026#34;/\u0026#34; onClick={function(e) {\rconsole.log(e); // 로그 찍는 방법\re.preventDefault(); // 해당 태그의 기본 클릭동작을 수행하지 않도록 한다.\r// \u0026#39;a\u0026#39; 태그의 경우 링크로 접속하는 동작을 막는다.\r}\r}\u0026gt;Click_here\u0026lt;/a\u0026gt; \u0026lt;/div\u0026gt;\r);\r}\r} 이벤트 함수 안에서 this.state.mode='write'와 같이 state를 변경하면 react가 변경 여부를 확인하지 못해 render()함수를 다시 호출하지 않아 화면이 갱신되지 않는다.\nthis.setState({mode:'write'});와 같이 state를 수정하도록 하자.\nonChange \u0026lsquo;input\u0026rsquo; 등 항목에서 내용이 변경되었을 경우\n아래와 같이 사용 가능\nconst onChange = (event) =\u0026gt; {\r// console.log(event.target.name);\rconst {target: {name, value}} = event; // get some values from \u0026#39;event\u0026#39;\r... +) bind\n이벤트 함수는 기본적으로 \u0026rsquo;this\u0026rsquo;를 가지지 않는다. 이때 강제로 this를 주입시키는 함수가 bind이다.\n이벤트 함수 안에서는 기본적으로 \u0026rsquo;this\u0026rsquo;를 호출해도 아무것도 bind되어있지 않다.\nonClick={function(e) { ... }.bind(this)} 와 같이 this를 bind해주면 this를 사용할 수 있게된다.\nvar obj = {name:\u0026#39;obj\u0026#39;};\rfunctiotn bindTest() {\rconsole.log(this.name);\r}\rbindTest(); // 아무 반응이 없다.\rbindTest.bind(obj); // obj가 bindTest의 this가 된다. +) custom event\n함수를 하위 컴퍼넌트에 전달해 준다.\nclass App extends Component {\rrender() {\rreturn (\r\u0026lt;div ClassName = \u0026#34;APP\u0026#34;\u0026gt;\r\u0026lt;Subject\rtitle={this.state.subject.title}\rcontent={this.state.subject.content}\ronChangePage={\rfunction(){\ralert(\u0026#34;page chaged\u0026#34;); // 경고창 출력\r}.bind(this);\r}\r\u0026gt;\r\u0026lt;/Subject\u0026gt;\r\u0026lt;/div\u0026gt;\r);\r}\r}\rfunction Subject() {\rreturn (\r\u0026lt;div\u0026gt;\r\u0026lt;a href=\u0026#34;/\u0026#34; onClick={ function(e) {\re.preventDefault();\rthis.props.onChangePage(); // 상위 컴퍼넌트로 부터 받은 함수 실행\r}\r\u0026lt;/div\u0026gt;\r);\r} 하위 컴퍼넌트를 수정하지 않고 하위 컴퍼넌트의 태그 클릭시 수행할 작업을 변경할 수 있다.\n하위 컴퍼넌트에서 상위 컴퍼넌트의 state를 변경할 수 있게 된다.\n라이프사이클 컴퍼넌트는 \u0026lsquo;마운트 -\u0026gt; 업데이트 -\u0026gt; 언마운트\u0026rsquo; 생명주기를 갖는다. 마운트 마운트 단계 메서드로는 다음이 존재한다. constructor : 생성시 호출되는 메서드 (생성자) getDerivedStateFromProps : props 값을 state에 넣는 메서드 render : UI를 렌더링 하는 메서드(화면 재구성) componentDidMount : 컴퍼넌트 랜더링 완료 후 호출되는 메서드 업데이트 컴퍼넌트가 업데이트 되는 경우는 아래의 경우들이 속한다.\nsetProps를 이용한 props변경시 setState를 이용한 state변경시 부모 컴퍼넌트가 리렌더링 될 시 this.forceUpdate로 강제 렌더링시 업데이트 단계의 메서드로는 다음이 존재한다.\ngetDerivedStateFromProps : props의 값을 state에 입력 shouldComponentUpdate : 컴퍼넌트의 변화를 인지하고, 랜더링 필요 여부를 판단. true: 랜더링 필요, false: 랜더링 불필요. render : 컴퍼넌트 리렌더링 getSnapshotBeforeUpdate : 컴퍼넌트 변화를 DOM에 반영하기 바로 직전에 호출되 메서드 componentDidUpdate : 컴퍼넌트 업데이트 작업이 끝난 후 호출되 메서드 언마운트 언마운트 단계의 메서드로는 다음이 존재한다. componentWillUnmount : 컴퍼넌트가 브라우저상에서 사라지기 직전 호출되는 메서드 this javascript 문법의 this와 동일하게 동작한다.\nclass 안에서는 this를 호출하면 class(컴퍼넌트)에 소속된 요소들에 접근할 수 있다.\n일반 function 안에서 this를 호출하면 자신이 종속된 객체에 접근한다.\narrow function 안에서 this를 호출하면 자신이 종속된 인스턴스(컴퍼넌트)에 접근한다.\nfunction func1() {\rthis.name = \u0026#34;func1\u0026#34;\rreturn {\rname : \u0026#34;return\u0026#34;\rarrow : () =\u0026gt; {\rconsole.log(this.name) // \u0026#39;func1\u0026#39; 출력\r}\rnormal : function() {\rconsole.log(this.name) // \u0026#39;return\u0026#39; 출력\r}\r}\r} hook class component에는 this.state가 있지만 function component 에서는 this.state가 없다. 대신 hook을 사용하여 동일한 기능을 수행한다. React에서는 built-in hook을 지원하고, 사용자가 직접 정의해서 사용할 수도 있다. hook의 조건 hook은 React 함수에서만 호출해야 한다. 일반 javascript 함수에서 호출하면 안된다. hook은 반복문, 조건문, nested function에서 호출되면 안된다. 위 두 조건을 이해하려면 hook의 동작 원리를 이해해야한다.\nReact는 컴퍼넌트를 처리할때 hook 함수들을 호출된 순서대로 관리한다.\n만약 컴퍼넌트를 업데이트할 때 hook 함수들의 순서가 변경된다면 React는 이를 정상적으로 처리하지 못한다.\n이때문에 hook은 항상 컴퍼넌트의 최상단에서 호출되어야 한다.\nhook의 종류 State Hooks import { useState } from 'react' 로 참조한다. [state, updateState] = useState( VALUE ): 컴퍼넌트에 VALUE값을 저장하고, 배열을 반환한다. \u0026lsquo;state\u0026rsquo; 는 VALUE 와 동일한 값이며, \u0026lsquo;updateState\u0026rsquo; 는 state값을 업데이트할 수 있는 함수 페어를 반환한다. \u0026lsquo;updateState\u0026rsquo; 는 this.setState와 유사한 효과를 가진다. VALUE값으로는 숫자, 문자열, 객체 모두 수용 가능하다. Effect Hooks import React, { useEffect } from 'react';로 참조한다.\ncomponentDidMount, componentWillUnmount 혹은 componentDidUpdate 와 유사한 효과를 발생시키며, 한 함수에서 여러번 선언 가능하다.\nuseEffect의 첫번째 인자로 함수가 들어가는데, 이 함수는 componentDidMount와 같은 시점에 동작된다.\nuseEffect의 첫번째 인자로 들어간 함수는 return값으로 함수를 반환하는데, 이 반환된 함수는 componentWillUnmount와 같은 시점에 동작된다.\nuseEffect의 두번째 인자로는 배열이 들어가고, 빈 배열을 넣을수도 있고, 값을 넣을수도 있다.\n이 배열 요소의 값이 바뀔경우 useEffect의 첫번째 인자로 들어간 함수를 실행시킨다. (componentDidUpdate와 유사하게 특정 변수가 변할때 rerendering을 할 수 있다.)\n또한, 이 배열 요소의 값이 바뀌기 직전, 첫번째 인자로 들어간 함수의 return 값이 실행된다.\n// return 없는 함수만 오는 경우\ruseEffect( () =\u0026gt; {\rconsole.log(\u0026#34;componentDidUpdate\u0026#34;);\r}\r// return 이 포함된 함수가 오는 경우\ruseEffect( () =\u0026gt; {\rconsole.log(\u0026#34;componentDidMount\u0026#34;);\rreturn (\r() =\u0026gt; { console.log(\u0026#34;componentWillUnmount\u0026#34;) }\r)\r})\r// 두번쨰 인자가 들어간 경우\ruseEffect( () =\u0026gt; {\rconsole.log(\u0026#34;\u0026#39;value\u0026#39; changed\u0026#34;);\rreturn (\r() =\u0026gt; { console.log(\u0026#34;value will be change\u0026#34;)}\r)\r}, [value]) class 의 componentdidMount와 같은 함수에 비해 간단하고 직관적으로 사용할 수 있다.\nContext Hooks useContext Reducer Hooks useReducer Custom Hooks hook을 담고 있는 사용자 정의 함수를 custom hook이라 칭한다. 반복되는 hook 호출 + 일련의 처리 과정을 하나의 함수로 묶어서 사용할 수 있다. 통념적으로 \u0026lsquo;use\u0026rsquo;로 시작하는 이름을 붙여준다. 호출된 custom hook도 일반 hook과 마찬가지로 중복해서 사용이 가능하며 각 hook들 끼리는 독립적이다. 6.Reference hook\nuseRef() 함수가 속한다. import { useRef } from 'react' 구문으로 참조 가능 랜더링과 독립적으로 변하지 않는 데이터를 저장한다. useRef는 변경될 시 페이지를 재 랜더링 하지 않는다. ref = useRef(null) 형태로 선언하며, reference object를 생성한다. null대신 저장하고싶은 데이터를 넣어도 된다. ref.current 로 저장한 데이터를 참조한다. ex) if (ref.current == null) useContext와 함께 사용하여 다른 component들에서 이 값을 참조하도록 할 수 있다. 객체 생성 후 값을 대입하려면 ref.current = data 형태로도 가능하다. \u0026lt;textarea ref={textareaRef}/\u0026gt; 형태로도 대입이 가능하다. textarea 객체 자체를 reference 하는 형태가 된다. \u0026lsquo;ref\u0026rsquo; 는 변수 명이 아니고 고정 속성값임에 주의 각종 모듈 package.json에 dependency를 기록해놓은 경우, npm install --legacy-peer-deps 명령으로 모든 dependency를 한번에 다운받을 수 있다. package.json에 기록되지 않는 모듈은 지워버리니 주의. Router SPA (Single Page Application) 에서 사용하지 않는 리소스를 로딩하느라 시간이 오래걸리는 것을 방지하기 위해, 소스를 분할처리하여 사용시에만 받을수 있게 하는 모듈\n설치 : npm install react-router-dom\n사용 :\nimport { HashRouter, Route, Routes, BrowserRouter} from \u0026#34;react-router-dom\u0026#34;;\rconst sample = () =\u0026gt; {\rreturn (\r\u0026lt;HashRouter\u0026gt;\r/* can add any components you want */\r\u0026lt;Routes\u0026gt;\r/* can only put \u0026#39;Route\u0026#39; components in \u0026#39;Routes\u0026#39; */\r\u0026lt;Route path=\u0026#34;/\u0026#34; element={\u0026lt;Home/\u0026gt;} /\u0026gt; // \u0026#39;/\u0026#39; 주소 호출시 Home component를 호출\r\u0026lt;Route path=\u0026#34;/about/*\u0026#34; element={\u0026lt;About/\u0026gt;} /\u0026gt; // \u0026#39;about\u0026#39; 및 \u0026#39;about/...\u0026#39; 형태의 주소 호출시 About component 호출\r/* add as you wish */\r\u0026lt;/Routes\u0026gt;\r\u0026lt;/HashRouter\u0026gt;\r);\r}; Route는 위에서부터 순차적으로 적용된다. if-else if 구문으로 생각하면 편하다.\n정규식 wild card *을 사용할 수 있다. (v5에서 exact 옵션 삭제되고 \u0026lsquo;*\u0026lsquo;로대체)\nroute 하는 대상에 props을 전달하고 싶다면,\nLink 특정 페이지로 경로를 전환해 주는 기능을 한다.\nreact-router-dom 모듈 안에 포함되어있다.\n\u0026lt;a\u0026gt; 태그와 동일한 역할을 하지만, React에서는 \u0026lt;a\u0026gt;를 사용하면 페이지를 새로 호출하여 React가 지니고 있던 상태들이 모두 초기화되기 때문에 \u0026lt;a\u0026gt; 태그 대신 link를 사용하는것이 맞다.\nlink는 페이지의 개념이고, button은 operation의 개념이다. 모두 event를 발생시킬 수 있지만 구분을 하는게 좋다.\n설치 : npm install react-router-dom\n사용 :\nimport { Link } from \u0026#34;react-router-dom\u0026#34;;\r...\r\u0026lt;Link to=\u0026#34;/\u0026#34;\u0026gt;Root\u0026lt;/Link\u0026gt; // 클릭하면 \u0026#39;/\u0026#39; 경로로 redirect 되는 Link 생성 Redirect react-router-dom에서 redirect를 지원하는 방법은 여러가지가 있다. Navigate 모듈 사용 :\nimport { HashRouter, Routes, Route, Navigate } from \u0026#34;react-router-dom\u0026#34;;\r...\r\u0026lt;HashRouter\u0026gt;\r\u0026lt;Routes\u0026gt;\r\u0026lt;Route path=\u0026#34;/\u0026#34; element={\u0026lt;Home/\u0026gt;}\r\u0026lt;Route path=\u0026#34;/about\u0026#34; element={\u0026lt;About/\u0026gt;}\r/* add as you wish */\r\u0026lt;Route path=\u0026#34;/index\u0026#34; element={\u0026lt;Navigate replace to=\u0026#34;/\u0026#34; /\u0026gt;} /\u0026gt; // \u0026#39;index\u0026#39; 페이지를 \u0026#39;/\u0026#39; 경로로 redirect\r\u0026lt;Route path=\u0026#34;*\u0026#34; element={\u0026lt;Navigate to=\u0026#34;/\u0026#34; /\u0026gt;} /\u0026gt; // 위에서 설정되지 않은 경로에 대해서는 모두 \u0026#39;/\u0026#39;로 redirect\r\u0026lt;/Routes\u0026gt;\r\u0026lt;/HashRouter\u0026gt; useHistory 사용 :\nconst history = useHistory();\rhistory.push(\u0026#34;/\u0026#34;); // \u0026#39;/\u0026#39; 경로로 redirect useNavigation 사용 :\nconst navigation = useNavigation()\rnavigation(\u0026#34;/\u0026#34;); // \u0026#39;/\u0026#39; 경로로 redirect cross-env 운영체제마다 환경변수 제공 방식이 달라 절대경로 표시가 어려웠던 점을 해결해주는 모듈 설치 : npm install cross-env --dev typeof react에서 기본적으로 제공하는 함수이다. ex)\nvar x = 1;\rif (typeof(x) === \u0026#39;number\u0026#39;) {\r...\r} 반환하는 결과값은 다음과 같다.\nundefined, object, number, boolean, bigint, string, symbol, function\n정의되는 값 참조\nDOM JSX에서 DOM을 조작하는 내용을 살펴보자 script 참조 javascript에서 아래와 같이 script를 추가할 수 있다.\n\u0026lt;script async defer src=\u0026quot;https://apis.google.com/js/api.js\u0026quot; onload=\u0026quot;gapiLoaded()\u0026quot;\u0026gt;\u0026lt;/script\u0026gt;\nreact에서는 위 방식 대신, hook과 document 인자를 사용하여 아래와 같이 작성한다.\nconst [calendarApiLoaded, setCalendarApiLoaded] = useState(false);\ruseEffect( ()=\u0026gt; {\r// check api is loaded\rconst existingCheck = document.getElementById(\u0026#39;gapi\u0026#39;);\r// if not loaded, load\rif (!existingCheck) {\rconst gapiScript = document.createElement(\u0026#39;script\u0026#39;);\rgapiScript.src = \u0026#34;https://apis.google.com/js/api.js\u0026#34;\rconst gisScrpit = document.createElement(\u0026#39;script\u0026#39;);\rgisScrpit.src = \u0026#34;https://accounts.google.com/gsi/client\u0026#34;\r// merge two scripts\rgapiScript.append(gisScrpit);\rgapiScript.id = \u0026#39;gapi\u0026#39;;\r// append to body\rdocument.body.appendChild(gapiScript);\r// change state\rsetCalendarApiLoaded(true);\r}\r}); window 변수 window는 전역번수를 attach된 모든 script에서 접근할 수 있는 변수이며, react에서도 마찬가지로 window.value 혹은 window['value'] 형태로 접근이 가능하다. 기타 함수형, 클래스형 react는 함수형 방식과 클래스형 방식으로 작성할 수 있다. 최근에는 함수형 방식을 선호하는 추세이다. 함수형이 클래스형보다 메모리를 덜 사용한다. 다른 파일 참조 react에서 다른 파일을 참조할 때에는 \u0026lsquo;import\u0026rsquo;를 사용하며, 확장자가 없으면 \u0026lsquo;.js\u0026rsquo;가 생략된 것으로 본다.\nimport React, { Component } from \u0026quot;react\u0026quot;는 기본으로 필요하다. html에서 예약어로 사용하는 태그들은 \u0026lsquo;synamtic tag\u0026rsquo;라 한다. \u0026lsquo;h1\u0026rsquo;, \u0026lsquo;header\u0026rsquo;, \u0026rsquo;nav\u0026rsquo;, \u0026lsquo;article\u0026rsquo; 등이 있다. export : 특정 객체를 다른 파일에서 import할 수 있도록 한다.\nex) export App debugger라는 예약어는, chrome에서 실행할 때 break point역할을 한다. 개발시 코드로 break point를 설정할 수 있다. 추가 활용 이미지 첨부 이미지는 /resources 파일에 첨부하고, import로 가져와 사용할 수 있다.\n확장자가 없으면 js파일로 취급하니 확장자도 꼭 적어주도록 한다.\nimport screen_img from \u0026#39;../resources/screen_img.webp\u0026#39;\r...\r// INFO: React JSX에서 style 설정\rvar _style = {\r\u0026#39;top\u0026#39;: 0 //- scrollPos\r}\rvar _style_img = {\r\u0026#39;background-image\u0026#39;: \u0026#34;url(\u0026#34; + screen_img + \u0026#34;)\u0026#34;,\r\u0026#39;top\u0026#39;: -694 - scrollPos * 4/5\r}; key 숨기기 API key 등 사용자에게 드러내지 않고싶은 정보들을 react가 아닌 다른 곳에 저장해야 한다. react app에 저장하게 되면 개발 도구를 사용해 Client에서 어떻게든 내용을 확인할 수 있다. 다만, .env 파일에 따로 저장하게 되면 git에서는 나타나지 않게 설정할 수 있다. .env 파일 사용법 root 경로에 .env파일을 생성한다. .gitignore에 .env파일을 예외처리 한다. 정의하고 싶은 내용을 REACT_APP_ 뒤에 이어붙여 정의한다. (ex: REACT_APP_API_KEY) 정의한 내용은 react JSX에서 process.env.REACT_APP_API_KEY 형태로 사용 가능하다. Custom Tag Custom tag \u0026lsquo;CAT\u0026rsquo; 를 새로 만든다고 할때, \u0026lt;CAT name={name}/\u0026gt; 과 같이 생성하였다. Custom tag 안에 다른 내용을 집어넣고 싶으면, \u0026lt;CAT name={name}\u0026gt; {props.children} \u0026lt;/CAT\u0026gt; 형태로 사용하면 된다. Custom tag를 정의할 때, tag 사이에 든 child를 포함하여 아래와 같이 구조를 정의할 수 있다. const CAT ({child}) =\u0026gt; {\r\u0026lt;div\u0026gt;start\u0026lt;/div\u0026gt;\r{child}\r\u0026lt;div\u0026gt;end\u0026lt;/div\u0026gt;\r}; 참조 자바스크립트 문법 문법 Document React LifeCycle What \u0026amp; Why Hook\n","permalink":"https://AswinBlue.github.io/post/react_basic/","summary":"React basic 개발환경 설치 및 실행 node.js 로 만들어진 create-react-app 툴을 이용하면 손쉽게 react 앱을 생성할 수 있다. npm을 설치하고 아래 명령어를 수행하여 create-react-app을 설치한다. npm install -g create-react-app 원하는 경로에 들어가 프로젝트를 생성한다. create-react-app \u0026lt;NAME\u0026gt; : NAME 경로에 프로젝트 생성 주의 : 프로젝트가 생성되는 폴더명은 대문자를 사용할 수 없다. 실행 npm run start 를 수행하면 localhost:3000에서 웹페이지를 퍼블리싱한다. 기본 설정 실행 포트 package.json 파일에서 \u0026quot;proxy\u0026quot;: \u0026quot;http://localhost:3000/\u0026quot; 과 같이 입력하면 실행시 포트를 3000으로 설정할 수 있다.","title":"React basic"},{"content":"C++ basics 매크로 #define MACRO 1 : MACRO 값으로 1을 지정 #undef MACRO : MACRO값에 지정된 내용 해제 여러줄의 매크로 값 지정 : #define PRINT(X) printf(\u0026#34;%d\u0026#34;, X);\\\rprintf(\u0026#34;%d\u0026#34;, (X) + 1);\\\rprintf(\u0026#34;%d\u0026#34;, (X) + 2); 매크로 합성 : #define A 1\r#define B 1\r#define C A##B // A##B = 12 함수형태 매크로 작성 : // 일반함수에는 \u0026#39;;\u0026#39; 를 붙이지만 매크로 함수에는 \u0026#39;;\u0026#39;를 붙일 필요가 없다.\r// 일관성을 갖기 위해 do-while문 안에 작성하면 매크로 함수에도 \u0026#39;;\u0026#39;를 붙이도록 할 수 있다.\r#define FUNC(a, b) do { \\\ra = b * 2;\\\r} while (0) 연산자 우선순 : // 매크로 함수는 계산 전 치환을 먼저 수행한다. 연산자 우선순위에 주의한다.\r#define ADD1(a,b) a+b\r#define ADD2(a,b) (a+b)\r#define MULT(a,b) a*b\r#define MULT2(a,b) (a)*(b)\r...\rprintf(\u0026#34;%d\u0026#34;,ADD1(3,4) * 2) // 예상값 (3 + 4) * 2 = 14\r// 3 + 4 * 2 로 치환하여 계산되어 실제 결과는 11\r// ADD2 처럼 계산 결과를 괄호로 묶어야 안전하다.\rprintf(\u0026#34;%d\u0026#34;,MULT(2+2,3+3)) // 예상값 (4 * 6) * 2 = 26\r// (2 + 2 * 3 + 3) 로 치환하여 계산되어 실제 결과는 11\r// MULT2 처럼 각 변수를 괄호로 묶어야 안전하다.\r// ADD1, MULT2 경우를 종합하여 아래와 같이 사용하자\r#define ADD3(a,b) ((a) + (b))\r#define MULT3(a,b) ((a) * (b)) 조건부 컴파일 if-elif-else 사용 가능 조건에 !, \u0026amp;\u0026amp; || 논리연산 가능 #define MACRO\r#define DEBUG 1\r#ifdef MACRO // 정의가 되어있으면 수행\r#endif\r#if DEBUG // DEBUG가 나타내는 값 또는 식이 참이면 수행\r#endif 파일 포함 #include \u0026lt;FILE_NAME\u0026gt; // 표준라이브러리에서 파일 참조\r#include \u0026#34;FILE_NAME\u0026#34; // 현재 경로 기준 파일 참조 → [활용]: 헤더파일 중복 참조 방지법\n#ifndef 사용 #ifndef __FILE_NAME_H__\r#define __FILE_NAME_H__\r// 헤더파일 내용\r#endif pragma once 사용 #pragma once // 일부 컴파일러에서만 지원 입출력 redirection 입력 재설정 freopen(\u0026quot;in.txt\u0026quot;, \u0026quot;r\u0026quot;, stdin); : \u0026lsquo;in.txt\u0026rsquo; 파일을 표준입력 대신 사용 cin cout 속도 향상 cin, cout을 사용하면 printf, scanf보다 속도가 느리다. 아래 코드로 세팅을 해 주면 출력 속도가 빨라진다. 하지만 printf, scanf와 함께 사용하면 순서가 섞이게 되니 설정 후에는 cin, cout만 사용하여야 한다. ios_base :: sync_with_stdio(false);\rcin.tie(NULL);\rcout.tie(NULL); ","permalink":"https://AswinBlue.github.io/post/c++/","summary":"C++ basics 매크로 #define MACRO 1 : MACRO 값으로 1을 지정 #undef MACRO : MACRO값에 지정된 내용 해제 여러줄의 매크로 값 지정 : #define PRINT(X) printf(\u0026#34;%d\u0026#34;, X);\\\rprintf(\u0026#34;%d\u0026#34;, (X) + 1);\\\rprintf(\u0026#34;%d\u0026#34;, (X) + 2); 매크로 합성 : #define A 1\r#define B 1\r#define C A##B // A##B = 12 함수형태 매크로 작성 : // 일반함수에는 \u0026#39;;\u0026#39; 를 붙이지만 매크로 함수에는 \u0026#39;;\u0026#39;를 붙일 필요가 없다.\r// 일관성을 갖기 위해 do-while문 안에 작성하면 매크로 함수에도 \u0026#39;;\u0026#39;를 붙이도록 할 수 있다.","title":"C++ basic"},{"content":"CMake Cmake란 : C,C++ 언어 컴파일시 make 툴을 이용할 때, 규모가 큰 프로젝트에서 컴파일 의존성 관리를 쉽게 하기 위한 도구\n명령어 cmake CMakeList.txt : CMakeList.txt파일 안의 내용을 수행한다.\ncmake . : 파일 경로를 입력하면 해당 경로에서 CMakeList.txt파일을 찾아서 수행.\nmake : cmake를 이용해 생성한 파일들을 이용해 make로 컴파일\ncmake 명령 후 make를 이용해 컴파일을 수행하면 부산물들이 많이 생성된다. 이를 방지하기 위해 보통 새로운 폴더를 만들어 넣어서 사용한다. 1. mkdir build\r2. vi CMakeList.txt 후 내용 작성\r3. cd build\r4. cmake ..\r5. make CmakeLists.txt 작성은 쉘 프로그래밍과 유사하다. cmake 문법을 사용하여 작성해 주면 된다. 미리 지정된 변수들도 있는데, 해당 변수들에 주의하며 작성한다. 문법 ADD_EXECUTABLE : 실행파일 생성 ex) ADD_EXECUTABLE(main.exe main.cpp function.cpp) : main.cpp와 function.cpp를 사용해 main.exe를 생성한다. 헤더 파일은 자동으로 적용된다.\nTARGET : 목표 생성물, 생성할 실행 파일을 의미한다. add_executable(), add_library(), add_custom_target() 등의 함수로 수정 가능하다.\nadd_subdirectory : 하위 디렉터리를 빌드 환경에 추가한다.\nadd_subdirectory를 사용한 경우 find_package를 사용하지 않는다.\nadd_dependencies : subdirectory 이름을 사용하지 않고, add_library 혹은 add_executable로 생성한 이름을 첫번째 인자로 사용해야 한다.\nex) add_dependencies(\u0026lt;생성한 객체이름\u0026gt; \u0026lt;모듈1\u0026gt; \u0026lt;모듈2\u0026gt; ...)\n참조 https://nowonbun.tistory.com/712\nmake 명령어 make install : 해당 경로의 소스를 컴파일하여 /usr/local/lib, /usr/local/bin 폴더로 .so파일과 .bin파일 복사 ","permalink":"https://AswinBlue.github.io/post/cmake/","summary":"CMake Cmake란 : C,C++ 언어 컴파일시 make 툴을 이용할 때, 규모가 큰 프로젝트에서 컴파일 의존성 관리를 쉽게 하기 위한 도구\n명령어 cmake CMakeList.txt : CMakeList.txt파일 안의 내용을 수행한다.\ncmake . : 파일 경로를 입력하면 해당 경로에서 CMakeList.txt파일을 찾아서 수행.\nmake : cmake를 이용해 생성한 파일들을 이용해 make로 컴파일\ncmake 명령 후 make를 이용해 컴파일을 수행하면 부산물들이 많이 생성된다. 이를 방지하기 위해 보통 새로운 폴더를 만들어 넣어서 사용한다. 1. mkdir build\r2.","title":"CMake"},{"content":"Json library in C++ Rapid Json 커뮤니티 오픈소스로 다양한 예제코드를 찾을 수 있다. parsing 속도 다른 Json 파싱 라이브러리와 비교시 상위권에 위치 라이브러리 헤더 온리 사용이 가능 참조 https://joycecoder.tistory.com/9 https://github.com/Tencent/rapidjson/ ","permalink":"https://AswinBlue.github.io/post/json_c++/","summary":"Json library in C++ Rapid Json 커뮤니티 오픈소스로 다양한 예제코드를 찾을 수 있다. parsing 속도 다른 Json 파싱 라이브러리와 비교시 상위권에 위치 라이브러리 헤더 온리 사용이 가능 참조 https://joycecoder.tistory.com/9 https://github.com/Tencent/rapidjson/ ","title":"Json in C++"},{"content":"sed 기본적인 기능은 ed에서 따 왔으며, 이 기능들은 모두 sed에 적용이 된다. ed는 대화형 편집기이며, sed는 스트리밍 편집기 \\n 을 개행문자로 사용하는 스트리밍 에디터 sed [-e script][-f script-file][file...]\n찾기/출력 sed -n '/abd/p' list.txt : list.txt : 파일을 한줄씩 읽으면서(-n : 읽은 것을 출력하지 않음) abd 문자를 찾으면 그 줄을 출력(p)한다. 치환 sed 's/addrass/address/' list.txt : list.txt파일에서 addrass를 address로 바꾼다. 단, 원본파일을 바꾸지 않고 출력을 바꿔서 한다. sed 's/□□*/□/' list.txt : ( *표시: □ 는 공백 문자를 표시한다. ) 위의 구문은 한개이상의 공백문자열을 하나의 공백으로 바꾼다. 삭제 sed '/TD/d' list.txt : TD 문자가 포함된 줄을 삭제하여 출력한다. sed '/Src/!d' list.txt : Src 문자가 있는 줄만 지우지 않는다. sed '1,2d' list.txt : 처음 1줄, 2줄을 지운다. sed '/^$/d list.txt : 공백라인을 삭제하는 명령이다 참조 http://m.egloos.zum.com/slog2/v/3689816\n","permalink":"https://AswinBlue.github.io/post/linux_command/","summary":"sed 기본적인 기능은 ed에서 따 왔으며, 이 기능들은 모두 sed에 적용이 된다. ed는 대화형 편집기이며, sed는 스트리밍 편집기 \\n 을 개행문자로 사용하는 스트리밍 에디터 sed [-e script][-f script-file][file...]\n찾기/출력 sed -n '/abd/p' list.txt : list.txt : 파일을 한줄씩 읽으면서(-n : 읽은 것을 출력하지 않음) abd 문자를 찾으면 그 줄을 출력(p)한다. 치환 sed 's/addrass/address/' list.txt : list.txt파일에서 addrass를 address로 바꾼다. 단, 원본파일을 바꾸지 않고 출력을 바꿔서 한다. sed 's/□□*/□/' list.txt : ( *표시: □ 는 공백 문자를 표시한다.","title":"Linux commands"},{"content":"spdlog C++ 프로젝트에서 로그를 세팅할 수 있는 라이브러리 fast, header only, no dependency, .. 등 장점 참조 https://isocpp.org/blog/2014/11/spdlog https://github.com/gabime/spdlog\n","permalink":"https://AswinBlue.github.io/post/log_c++/","summary":"spdlog C++ 프로젝트에서 로그를 세팅할 수 있는 라이브러리 fast, header only, no dependency, .. 등 장점 참조 https://isocpp.org/blog/2014/11/spdlog https://github.com/gabime/spdlog","title":"spdlog C++"},{"content":"Node.js 기본 명령 npm init : 패키지 생성 npm install : 라이브러리 설치 -P : package.json에 저장, 기본옵션 -O : optionalDependencies에 저장 -D, --no-save : 기록없이 다운로드 -g : 글로벌 설치, 모든 프로젝트에 적용 MODULE_NAME@VERSION : 버전 설정, latest는 가장 최근 버전을 의미 node main.js : 실행(main.js) npx \u0026lt;package_name\u0026gt; : 설치하지 않고 일회만 실행 node main.js : 패키지 실행 (main.js파일) 구조 main.js : nodejs 실행시 실행할 메인 파일 package.json : root 경로에 존재하며, npm 프로젝트를 관리하는 파일 package.json nodejs 설정을 담고있는 파일로, 참조할 내용이 많아 아래에 따로 정리한다.\n\u0026quot;//\u0026quot; : \u0026quot;comment\u0026quot; : 주석을 넣는 방법, json key를 //로 하고, value에 comment를 작성한다.\nscripts : npm run SCRIPT(SCRIPT는 원하는 명령) 명령으로 특정 command를 수행하게 할 수 있음\nscript 명령은 os별로 명령이 상이할 수 있다. 이때는 다음과 같이 설정하여 각 os별로 다르게 동작할 수 있도록 한다. (npm run test 명령시 자동으로 수행해주는것 같지는 않음) os에 따라 명령어가 다를 수 있으므로, cross-env 모듈을 설치해서 사용하면 문제를 간단히 해결할 수 있다. ex) cross-env NODE_ENV=production \u0026#34;scripts\u0026#34;: {\r\u0026#34;test\u0026#34;: \u0026#34;run-script-os\u0026#34;,\r\u0026#34;test:darwin:linux\u0026#34;: \u0026#34;export NODE_ENV=test \u0026amp;\u0026amp; mocha\u0026#34;,\r\u0026#34;test:win32\u0026#34;: \u0026#34;SET NODE_ENV=test\u0026amp;\u0026amp; mocha\u0026#34;\r} devDependencies : 내부에 필요한 모듈들. npm install -D 명령어로 dependency를 추가 가능하다.\n{\r\u0026#34;name\u0026#34;: \u0026#34;rankingserver\u0026#34;,\r\u0026#34;version\u0026#34;: \u0026#34;1.0.0\u0026#34;,\r\u0026#34;description\u0026#34;: \u0026#34;\u0026#34;,\r\u0026#34;main\u0026#34;: \u0026#34;index.js\u0026#34;,\r\u0026#34;scripts\u0026#34;: {\r\u0026#34;//\u0026#34; : \u0026#34;this line is a comment\u0026#34;,\r\u0026#34;test\u0026#34;: \u0026#34;echo \\\u0026#34;Error: no test specified\\\u0026#34; \u0026amp;\u0026amp; exit 1\u0026#34;,\r\u0026#34;build:postcss\u0026#34;: \u0026#34;NODE_ENV=production postcss src/main/resources/static/css/tailwind.css -o target/classes/static/css/tailwind.css\u0026#34;,\r\u0026#34;watch:postcss\u0026#34;: \u0026#34;NODE_ENV=development postcss src/main/resources/static/css/tailwind.css -o src/main/resources/static/css/tailwind.css -w\u0026#34;\r},\r\u0026#34;repository\u0026#34;: {\r\u0026#34;type\u0026#34;: \u0026#34;git\u0026#34;,\r\u0026#34;url\u0026#34;: \u0026#34;git+https://github.com/AswinBlue/RankServer.git\u0026#34;\r},\r\u0026#34;keywords\u0026#34;: [],\r\u0026#34;author\u0026#34;: \u0026#34;\u0026#34;,\r\u0026#34;license\u0026#34;: \u0026#34;ISC\u0026#34;,\r\u0026#34;bugs\u0026#34;: {\r\u0026#34;url\u0026#34;: \u0026#34;https://github.com/AswinBlue/RankServer/issues\u0026#34;\r},\r\u0026#34;homepage\u0026#34;: \u0026#34;https://github.com/AswinBlue/RankServer#readme\u0026#34;,\r\u0026#34;devDependencies\u0026#34;: {\r\u0026#34;autoprefixer\u0026#34;: \u0026#34;^10.4.7\u0026#34;,\r\u0026#34;postcss\u0026#34;: \u0026#34;^8.4.14\u0026#34;,\r\u0026#34;postcss-cli\u0026#34;: \u0026#34;^9.1.0\u0026#34;,\r\u0026#34;tailwindcss\u0026#34;: \u0026#34;^3.0.24\u0026#34;\r}\r} 모듈 사용 var express = require('express');\nvar session = require('express-session');\nvar bodyParser = require('body-parser');\nvar app = express();\nstatic 설정 app.use('/static', express.static(__dirname + '/static'));\n\u0026lsquo;/static\u0026rsquo; 이라는 경로로 \u0026lsquo;현재경로/static\u0026rsquo; 폴더를 연결시킴, 즉 \u0026lsquo;/static/file\u0026rsquo; 을 호출하면 \u0026lsquo;현재경로/static/file\u0026rsquo; 이 호출됨 session 설정 app.use(session({ -\u0026gt; session 사용 설정\nsecret:\u0026quot;SECRET_CODE\u0026quot;, -\u0026gt; 세션을 암호화 할 시드 설정\nresave:false,\nsaveUninitialized:true\n}));\nbody parser app.use(bodyParser.urlencoded({extended: false}));\nhtml의 body의 내용을 express의 js파일에서 불러와 사용할 수 있도록 하는 모듈 routing r_edit = require('./route/edit.js'); -\u0026gt; \u0026lsquo;/edit\u0026rsquo; 경로로 요청이 오면 \u0026lsquo;./route/edit.js\u0026rsquo; 파일로 연결, 라우팅 처리함\napp.use('/edit', r_edit);\nr_login = require('./route/login.js');\napp.use('/login', r_login);\nr_default = require('./route/default.js');\napp.use('/', r_default);\nejs app.set('views', './views'); -\u0026gt; \u0026lsquo;./view\u0026rsquo; 경로를 view로 사용, view 폴더 안에는 html파일들을 넣으면 됨\napp.set('view engine', 'html'); -\u0026gt; view 를 html로 구성함\napp.engine('.html', require('ejs').renderFile);\nServer var server = app.listen(80, function() { -\u0026gt; 80번 포트로 서버 오픈\nvar host = server.address().address -\u0026gt; 호스팅한 서버의 주소\nvar port = server.address().port -\u0026gt; 호스팅한 서버의 포트\nconsole.log(\u0026quot;App listening at http://%s:%s\u0026quot;, host, port) -\u0026gt; 로그\n});\nedit.js main 파일에서 라우팅을 위해 r_edit 변수에 연결시켜 사용하는 파일, ./route 폴더에 정리되어 있다. var express = require('express'); -\u0026gt; express 모듈 사용\nvar router = express.Router(); -\u0026gt; express의 routing 모듈 사용\n함수 사용 function stringToInt(x, base) { -\u0026gt; js 파일 안에서도 함수 정의, 사용 가능\nconst parsed = parseInt(x, base); -\u0026gt; string을 int로 변환\nif (isNaN(parsed)) { return 0; } -\u0026gt; string이 \u0026rsquo;\u0026rsquo; 인 경우, NAN을 반환하는데, NAN을 0으로 치환\nreturn parsed; -\u0026gt; 치환한 결과를 반환\n}\nrouting 설정 router.post('/:category/:product', function(req, res, next) {\npost 명령으로 / \u0026hellip; / \u0026hellip; 주소로 명령이 내려올 경우 function을 수행한다. main.js에서 r_edit을 \u0026lsquo;SERVER_ADDRESS/edit\u0026rsquo; 주소로 왔을 때 실행하도록 매핑해 놓았으므로, \u0026lsquo;SERVER_ADDRESS/edit/AAA/BBB\u0026rsquo; 주소로 명령이 내려오면 해당 함수가 동작한다. AAA 자리에 들어가는 값은 req.params.category 로 참조 가능하며, BBB는 req.params.product로 참조 가능하다. router.get('/:TLV', function(req, res, next) { -\u0026gt; get 명령은 router.get으로 설정 가능하다.\nmodule.exports = router; -\u0026gt; 마지막에 router를 exports 해야 적용이 된다.\nsession 설정 if (req.session.user) {\nmain.js에서 session을 사용하였으므로 req.session으로 session에 담긴 변수들을 참조 가능하다. req.session.user 값이 있으면 아래 내용을 수행한다는 코드이다. 값을 집어넣을 때에도 req.session.val = 1 과 같이 사용 가능하다. DB 사용 var mysql = require('mysql'); -\u0026gt; mysql 모듈을 사용한다.\nvar db_config = require('../config/db_config.json'); -\u0026gt; config 폴더 안에 db 접속에 필요한 내용을 저장해 놓았다. js 파일과 해당 내용을 분리하여 보안을 강화시킬 수 있다. db_config.json파일은 json 데이터를 담고 있다.\nvar connection = mysql.createConnection({ -\u0026gt; mysql 연결 설정\nhost : db_config.host, -\u0026gt; db_config_json 파일의 key를 참조하여 value를 대입한다.\nuser : db_config.user,\npassword : db_config.password,\ndatabase : db_config.database -\u0026gt; 사용할 DB 이름\nconnection.connect(); -\u0026gt; 연결을 수행한다.\n});\nconnection.query('UPDATE mytable SET name = ?, description = ?, price = ? where number = ?',[inputs.name, inputs.description, inputs.price, req.params.category], function (error, results, fields) { -\u0026gt; 연결된 DB에 query를 날린다. error는 오류정보, results는 DB 결과(row)를 array형태로 반환한다.\nquery 안에 query를 넣으면 오류가 난다. 완료 후 다음 query를 진행하도록 하자. console.log(this.sql); -\u0026gt; 함수 안에서 this.sql을 호출하면 query 내용을 참조할 수 있다.\nif (error) { -\u0026gt; 에러가 발생한 경우\nconsole.log(error);\nres.status(500).json({\u0026quot;Error\u0026quot;: \u0026quot;DB Error\u0026quot;}); -\u0026gt; 결과 response에 status 500을 주고, json 메시지를 함께 던진다.(화면에는 Json 메시지가 출력 됨)\n}\n});\nconnection.end();-\u0026gt; DB 사용을 끝내고 연결을 해제한다.\nconnection.query(\u0026quot;SELECT * FROM user WHERE User=? AND authentication_string=PASSWORD(?)\u0026quot;, [id, pswd], function (error, results, fields) {\nPASSWORD() 함수는 mysql의 user DB에서 사용자의 비밀번호를 인코딩하여 authentication_string 컬럼에 해당하는 값으로 만드는 함수이다. 비밀번호를 넣으면 authentication_string값을 반환한다. html 페이지 연결 routing 함수에서 받은 요청에 대해 redirect를 할 수도 있고, render로 파일을 열 수도 있다. res.redirect('/edit/' + req.params.TLV); -\u0026gt; 설정한 주소로 페이지를 리다이렉트 한다.\nres.render('login.html', {url: target}); -\u0026gt; url이란 키로 target 이라는 변수에 담긴 data를 login.html에 전달한다. html 파일에서는 url 이란 변수로 target값을 사용 가능하다.\nhtml 페이지 연동 html 페이지에서 form에 넣어서 보낸 내용은 bodyParser 모듈로 파싱하면 \u0026lsquo;req.body.변수이름\u0026rsquo; 으로 참조 가능하다. var inputs = { -\u0026gt; 내용을 받아 json 형태로 저장\n\u0026quot;relation\u0026quot;: req.body.relation, -\u0026gt; html파일의 form 태그의 input 태그중 name=\u0026ldquo;relation\u0026quot;인 태그의 value 값을 참조\n\u0026quot;number\u0026quot;: req.body.name}\nindex.html ejs모듈을 사용하여 설정한 대로 view 폴더 내에 생성한다. static 설정을 마쳤기 때문에 js 파일이나 css 파일들은 미리 설정해둔 \u0026lsquo;/static\u0026rsquo; 폴더 내에서 참조 가능하다. \u0026lt;script type=\u0026quot;text/javascript\u0026quot; src=\u0026quot;/static/edit_func.js\u0026quot;\u0026gt;\u0026lt;/script\u0026gt; -\u0026gt; static 파일 호출 방법\nhtml 안에서 nodejs 문법을 사용하려면 \u0026lt;% %\u0026gt; 안에서 사용하면 된다. 변수 값을 바로 반환하려면 \u0026lt;%= %\u0026gt; 를 사용한다. \u0026lt;% var ptr = 10 %\u0026gt; -\u0026gt; 변수 ptr 선언\n\u0026lt;% dataList.forEach(function(item, index) { %\u0026gt;-\u0026gt; dataList의 항목들에 대해 수행, dataList는 routing function(route/index.js 안의 routing 함수)에서 res.render('index.html', {dataList: data}); 로 전해준 데이터이다.\n\u0026lt;% if (dataList[ptr].number != item.number) { %\u0026gt; -\u0026gt; if 함수 사용 가능, if문이 false라면 아래 내용은 출력되지 않음\n\u0026lt;tr id=\u0026quot;lineTr\u0026quot;\u0026gt;\n\u0026lt;td\u0026gt;\u0026lt;a href=\u0026quot;edit/\u0026lt;%=item.number%\u0026gt;\u0026quot;\u0026gt;\u0026lt;%= item.number %\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/td\u0026gt;\n\u0026lt;td\u0026gt;\u0026lt;%= item.name %\u0026gt;\u0026lt;/td\u0026gt;\n\u0026lt;td\u0026gt;\u0026lt;%= item.description %\u0026gt;\u0026lt;/td\u0026gt;\n\u0026lt;td\u0026gt;\u0026lt;%= item.superSet %\u0026gt;\u0026lt;/td\u0026gt;\n\u0026lt;% ptr = index %\u0026gt;\n\u0026lt;% } else { %\u0026gt;\n\u0026lt;tr\u0026gt;\n\u0026lt;td\u0026gt;\u0026lt;/td\u0026gt;\n\u0026lt;td\u0026gt;\u0026lt;/td\u0026gt;\n\u0026lt;td\u0026gt;\u0026lt;/td\u0026gt;\n\u0026lt;td\u0026gt;\u0026lt;/td\u0026gt;\n\u0026lt;% } %\u0026gt;\n\u0026lt;td\u0026gt;\u0026lt;%= item.relation %\u0026gt;\u0026lt;/td\u0026gt; -\u0026gt; item.relation의 값을 반환, 즉 해당 값의 내용이 안에 출력된다.\n\u0026lt;td\u0026gt;\u0026lt;%= item.etc %\u0026gt;\u0026lt;/td\u0026gt;\n\u0026lt;td\u0026gt;\u0026lt;%= item.bit %\u0026gt;\u0026lt;/td\u0026gt;\n\u0026lt;td\u0026gt;\u0026lt;%= item.byte %\u0026gt;\u0026lt;/td\u0026gt;\n\u0026lt;td\u0026gt;\u0026lt;%= item.value %\u0026gt;\u0026lt;/td\u0026gt;\n\u0026lt;td\u0026gt;\u0026lt;%= item.meaning %\u0026gt;\u0026lt;/td\u0026gt;\n\u0026lt;td\u0026gt;\u0026lt;%= item.history %\u0026gt;\u0026lt;/td\u0026gt;\n\u0026lt;/tr\u0026gt;\n\u0026lt;% }); %\u0026gt;\n","permalink":"https://AswinBlue.github.io/post/nodejs/","summary":"Node.js 기본 명령 npm init : 패키지 생성 npm install : 라이브러리 설치 -P : package.json에 저장, 기본옵션 -O : optionalDependencies에 저장 -D, --no-save : 기록없이 다운로드 -g : 글로벌 설치, 모든 프로젝트에 적용 MODULE_NAME@VERSION : 버전 설정, latest는 가장 최근 버전을 의미 node main.js : 실행(main.js) npx \u0026lt;package_name\u0026gt; : 설치하지 않고 일회만 실행 node main.js : 패키지 실행 (main.js파일) 구조 main.js : nodejs 실행시 실행할 메인 파일 package.json : root 경로에 존재하며, npm 프로젝트를 관리하는 파일 package.","title":"Nodejs"},{"content":"mysql 명령어 문법 참조 : http://tcpschool.com/mysql/mysql_basic_syntax\n명령어에서 대소문자는 상관없다. mysql에서 주석은 \u0026lsquo;#\u0026lsquo;을 사용한다. 실행 및 로그인 mysql mysql 실행, 기본으로 설정된 user로 로그인됨 mysql -u 아이디 -p -u: 특정 아이디로 로그인 -p: 로그인시 비밀번호 입력하도록 데이터베이스 관리 DB 생성 UTF8 로 문자열 저장하기 CREATE DATABASE 데이터베이스_이름 default CHARACTER SET UTF8 DB 목록확인 show databases DB 선택 use DB_NAME 종료 EXIT 로그인 \u0026amp; 데이터베이스 선택 $ mysql -p DB_NAME -u USER_NAME 사용자 이름과 USER_NAME으로 DB_NAME 데이터베이스 실행 USER_NAME이 비어있으면 현재 로그인한 계정과 동일한 이름으로 로그인 시도 -u DB_NAME 옵션은 로그인 후 $use DB_NAME 과 같은 효과 테이블 생성 및 관리 TABLE_NAME 테이블의 스키마 확인 desc TABLE_NAME\nCREATE : 테이블 생성\nCREATE TABLE 테이블이름 (\rid INT NOT NULL AUTO_INCREMENT,\r항목1 VARCHAR(255) NOT NULL DEFAULT \u0026#39;FOO\u0026#39;,\r항목2 DATE NOT NULL,\r항목3 DECIMAL(10 , 2 ) NULL,\rPRIMARY KEY (id)\r) ENGINE-; NOT NULL: 필수항목 AUTO_INCREMENT: 수동으로 설정 가능하지만, 따로 설정하지 않으면 테이블 내 해당 컬럼에서 가장 큰 값에 1을 증가하여 자동으로 설정됨. VARCHAR(#): 캐릭터형 #bit DEFAULT : 기본값, 따로 설정안할시 기본값은 NULL이 됨. ENGINE: 데이터 저장 구조 MyISAM row level locking이 아닌 table level locking을 사용하기에, 한 테이블에 많은 접근이 이루어지면 속도가 느려짐 select count(*) from TABLE 속도가 빠름 InnoDB 풀 텍스트 인덱스를 지원하지 않고 속도가 약간 느림 트랜잭션을 지원함 참조 DESC: 테이블 구조 확인 DESC 테이블 DESCRIBE 테이블\nSELECT : 테이블 검색 SELECT 필드 [,필드2 ...] FROM 테이블 [WHERE 조건] [ORDER BY 필드]\n필드를 \u0026lsquo;,\u0026lsquo;로 다중 선택 WHERE 문으로 특정 조건에 해당하는 레코드만 추출 LIKE : 뒤에 와일드 카드 사용 _ : 와일드카드로, \u0026lsquo;한 자리의 어떤 문자\u0026rsquo;를 의미한다. % : 와일드카드로, 정규식의 *과 같은 의미이다. NOT : 부정의 의미, !과 동일 \u0026lt;\u0026gt; : !=와 같은 의미 ORDER BY 문으로 검색 결과를 필드에 맞게 정렬 DELETE : 데이터 삭제 DELETE FROM 테이블 [WHERE 조건]\n조건을 생략하면 테이블의 모든 데이터 삭제 ALTER: 테이블 변경 참조 컬럼 추가 ALTER TABLE 테이블이름 ADD COLUMN 컬럼이름 데이터형 컬럼 타입 변경 ALTER TABLE 테이블이름 MODIFY COLUMN 컬럼이름 데이터형 컬럼 이름 변경 ALTER TABLE 테이블이름 CHANGE COLUMN 기존이름 새이름 데이터형 컬럼 삭제 ALTER TABLE 테이블이름 DROP COLUMN 컬럼이름 Primary Key 설정 ALTER TABLE 테이블이름 ADD PRIMARY KEY (설정할컬럼1, 설정할컬럼2, ...) Primary key 삭제 ALTER TABLE 테이블이름 DROP PRIMARY KEY 테이블명 변경 ALTER TABLE 테이블이름 RENAME 새테이블이름 DB구조 변경 ALTER TABLE 테이블 engine=InnoDB; DROP : 테이블 삭제 DROP DATABASE 데이터베이스 DROP TABLE 테이블\nINSERT : 행 추가\n원하는 필드만 설정, 설정 안한부분은 default값이 들어감 INSERT INTO 테이블(필드1, 필드2, ... ) VALUES (데이터1, 데이터2, ... ) 모든 필드를 설정할땐 컬럼 이름을 생략 가능 INSERT INTO 테이블 VALUES (데이터1, 데이터2, ... ) JOIN : 테이블 융합 내부Join\nSELECT 테이블1.*, 테이블2.* FROM 테이블1, 테이블2 WHERE 조건 SELECT 테이블1.*, 테이블2.* FROM 테이블1 INNER JOIN 테이블2 ON 조건 외부Join\nLEFT Join SELECT * FROM 테이블1 LEFT JOIN 테이블2 ON 조건 조건이 맞지 않으면 테이블2의 필드 값이 모두 null 상태로 표시된다. RIGHT Join SELECT * FROM 테이블1 LEFT JOIN 테이블2 ON 조건 조건이 맞지 않으면 테이블1의 필드값이 모두 null 상태로 표시된다. 유저 관리 GRANT : 데이터베이스에 권한 부여 GRANT ALL PRIVILEGES ON my_db.* TO new_user@localhost IDENTIFIED BY 'pswd'; ALL PRIVILEGES : 모든 권한 my_db.* : my_db의 모든 테이블 new_user : 사용권한을 받을 유저(없을시 자동생성), @localhost : 로컬환경에서만 접속 가능 IDENTIFIED BY 'pswd' : new_user의 비밀번호를 pswd로 설정 flush privileges 권한 즉시 적용 기타 명령어 현재 사용자 정보 확인 select user()\n현재 DB 정보 확인 select databases()\nCSV파일 DB에 적용 LOAD DATA LOCAL INFILE 'FILE_NAME' INTO TABLE TABLE_NAME FIELDS TERMINATED BY ',' OPTIONALLY ENCLOSED BY '\u0026quot;' LINES TERMINATED BY '\\n'; - FILE_NAME 파일을 TABLE_NAME 테이블에 넣는다. 필드는 \u0026lsquo;,\u0026lsquo;로 구분되어 있고, 줄바꿈은 \u0026lsquo;\\n\u0026rsquo;로 구분되어 있고, \u0026lsquo;\u0026quot;\u0026lsquo;로 싸인 내용은 한 덩어리로 인식한다.\n경고문 확인 SHOW WARNINGS\\G\n데이터 타입 문자형 데이터타입 데이터 타입 설명 CHAR(n) 고정 길이 데이터 타입(최대 255byte)- 지정된 길이보다 짦은 데이터 입력될 시 나머지 공간 공백으로 채워진다. VARCHAR(n) 가변 길이 데이터 타입(최대 65535byte)- 지정된 길이보다 짦은 데이터 입력될 시 나머지 공간은 채우지 않는다. TINYTEXT(n) 문자열 데이터 타입(최대 255byte) TEXT(n) 문자열 데이터 타입(최대 65535byte) MEDIUMTEXT(n) 문자열 데이터 타입(최대 16777215byte) LONGTEXT(n) 문자열 데이터 타입(최대 4294967295byte) 숫자형 데이터 타입 데이터 타입 설명 TINYINT(n) 정수형 데이터 타입(1byte) -128 ~ +127 또는 0 ~ 255수 표현 가능하다. SMALLINT(n) 정수형 데이터 타입(2byte) -32768 ~ 32767 또는 0 ~ 65536수 표현 가능하다. MEDIUMINT(n) 정수형 데이터 타입(3byte) -8388608 ~ +8388607 또는 0 ~ 16777215수 표현 가능하다. INT(n) 정수형 데이터 타입(4byte) -2147483648 ~ +2147483647 또는 0 ~ 4294967295수 표현 가능하다. BIGINT(n) 정수형 데이터 타입(8byte) - 무제한 수 표현 가능하다. FLOAT(길이,소수) 부동 소수형 데이터 타입(4byte) -고정 소수점을 사용 형태이다. DECIMAL(길이,소수) 고정 소수형 데이터 타입고정(길이+1byte) -소수점을 사용 형태이다. DOUBLE(길이,소수) 부동 소수형 데이터 타입(8byte) -DOUBLE을 문자열로 저장한다. 날짜형 데이터 타입 데이터 타입 설명 DATE 날짜(년도, 월, 일) 형태의 기간 표현 데이터 타입(3byte) TIME 시간(시, 분, 초) 형태의 기간 표현 데이터 타입(3byte) DATETIME 날짜와 시간 형태의 기간 표현 데이터 타입(8byte) TIMESTAMP 날짜와 시간 형태의 기간 표현 데이터 타입(4byte) -시스템 변경 시 자동으로 그 날짜와 시간이 저장된다. YEAR 년도 표현 데이터 타입(1byte) 이진 데이터 타입 데이터 타입 설명 BINARY(n) \u0026amp; BYTE(n) CHAR의 형태의 이진 데이터 타입 (최대 255byte) VARBINARY(n) VARCHAR의 형태의 이진 데이터 타입 (최대 65535byte) TINYBLOB(n) 이진 데이터 타입 (최대 255byte) BLOB(n) 이진 데이터 타입 (최대 65535byte) MEDIUMBLOB(n) 이진 데이터 타입 (최대 16777215byte) LONGBLOB(n) 이진 데이터 타입 (최대 4294967295byte) C++연동 SDK mysql cpp connector 라 불리는, C++ 코드로 mysql을 사용할 수 있는 SDK가 제공된다. mysql과 mysqlx가 있는데, 전자는 RDB, 후자는 NoSQL이다. 표준 docmument https://dev.mysql.com/doc/connector-cpp/8.0/en/connector-cpp-installation-source-distribution.html guthub https://github.com/mysql/mysql-connector-cpp 참조 데이터베이스 정규화 1NF, 2NF, 3NF, BCNF :: Deep Play\n[MySQL] csv 파일을 직접 MySQL 테이블로 Import 하는 방법 (대용량 파일 import 팁) 주경야근\nImport CSV File Into MySQL Table\nDB - 데이터 타입/MYSQL\n[MySQL] Warnings 발생 했을 때 경고 내용 보기 - Blog Goooood.net\nHow to import CSV into mysql if values contains comma - Stack Overflow\n[SQL] 테이블 합치기 (JOIN / UNION) : 네이버 블로그\nMySQL 계정 생성 관리 및 권한설정 :: 비실이의 개발공간\n[MySQL] ERROR 1044 (42000.. : 네이버블로그\nphp - How can I make a key pair primary? - Stack Overflow\nMySQL 계정 변경 및 간단한 사용법 : 네이버 블로그\nMySQL 소개 및 기본 사용법 - 생활코딩\n(MySQL) 1장 시작하기. (DB 생성, 테이블 생성, SELECT) - 미래학자\n","permalink":"https://AswinBlue.github.io/post/mysql/","summary":"mysql 명령어 문법 참조 : http://tcpschool.com/mysql/mysql_basic_syntax\n명령어에서 대소문자는 상관없다. mysql에서 주석은 \u0026lsquo;#\u0026lsquo;을 사용한다. 실행 및 로그인 mysql mysql 실행, 기본으로 설정된 user로 로그인됨 mysql -u 아이디 -p -u: 특정 아이디로 로그인 -p: 로그인시 비밀번호 입력하도록 데이터베이스 관리 DB 생성 UTF8 로 문자열 저장하기 CREATE DATABASE 데이터베이스_이름 default CHARACTER SET UTF8 DB 목록확인 show databases DB 선택 use DB_NAME 종료 EXIT 로그인 \u0026amp; 데이터베이스 선택 $ mysql -p DB_NAME -u USER_NAME 사용자 이름과 USER_NAME으로 DB_NAME 데이터베이스 실행 USER_NAME이 비어있으면 현재 로그인한 계정과 동일한 이름으로 로그인 시도 -u DB_NAME 옵션은 로그인 후 $use DB_NAME 과 같은 효과 테이블 생성 및 관리 TABLE_NAME 테이블의 스키마 확인 desc TABLE_NAME","title":"Mysql"},{"content":"python CGI CGI는 Common Gateway Interface의 약자다. web application을 만들 수 있는 언어는 ruby, java, php 등 다양하지만 모두 CGI 규약을 따라 web server와 통신한다. web server는 사용자의 요청을 받으면 약속된 이름의 데이터를 환경변수로 web application에 전달하여 서로 교류한다. apache에서 python을 이용해 web application을 만들어 web server와 통신해 보자. $ a2enmod CGI 명령으로 apache의 CGI를 켜 주고, sudo service apache2 restart 로 설정 적용 /var/log/apache2/error.log 안에 apache 실행시 발생한 에러 로그가 담겨있다. 웹 브라우저가 웹 서버에 요청할 때 웹 서버는 응답으로 웹 페이지의 데이터 타입(헤더)와 함께 웹 페이지를 전송한다. python CGI로는 print(\u0026quot;content-type:text/html; charset=UTF-8\\n\u0026quot;) 와 같이 헤더를 표기낸다. 헤더를 출력한 다음 부터는 body 부분이 출력된다. 특정 주소로 Redirection을 할 때에는 print(\u0026quot;location : index.py?id=title\u0026quot;)을 이용한다. ( \u0026lsquo;:\u0026rsquo; 이후 부터 \u0026lsquo;\u0026quot;\u0026rsquo; 까지는 원하는대로 작성) formatting string에서 특정 문자열을 다른 문자로 치환하는 기능 ex) '{} {}'.format('one','tow') ex) '{a} {b}'.format(a='hello', b='world') python 파일에서 문자열과 format 함수를 이용하여 동적 html을 구현 가능하다. CGI 모듈 import cgi 로 모듈을 로드해 사용한다. form = cgi.FieldStorage() form은 jQuery와 같은 역할을 한다. ex) pageId = form['id'].value : page의 id를 가져온다. HTML 연동 input 태그의 name 속성 : input 태그를 특정 이름으로 CGI에 전달함 ex)\n\u0026lt;p\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; name=\u0026#34;title\u0026#34; placeholder=\u0026#34;title\u0026#34;\u0026gt; \u0026lt;/p\u0026gt;\r\u0026lt;p\u0026gt; \u0026lt;textarea rows=\u0026#34;4\u0026#34; name=\u0026#34;description\u0026#34;\u0026gt;\u0026lt;/textarea\u0026gt;\u0026lt;/p\u0026gt;\r\u0026lt;p\u0026gt; \u0026lt;input type=\u0026#34;submit\u0026#34;\u0026gt;\u0026lt;/p\u0026gt; form 태그 : 특정 파일로 form 태그 안의 태그들을 전송\naction 속성 : form 안의 내용을 처리할 파일(목적지)를 설정한다. ex)\n\u0026lt;form action=\u0026#34;create.py\u0026#34;\u0026gt;\r\u0026lt;p\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; name=\u0026#34;title\u0026#34; placeholder=\u0026#34;title\u0026#34;\u0026gt; \u0026lt;/p\u0026gt;\r\u0026lt;p\u0026gt; \u0026lt;textarea rows=\u0026#34;4\u0026#34; name=\u0026#34;description\u0026#34;\u0026gt;\u0026lt;/textarea\u0026gt;\u0026lt;/p\u0026gt;\r\u0026lt;p\u0026gt; \u0026lt;input type=\u0026#34;submit\u0026#34;\u0026gt;\u0026lt;/p\u0026gt;\r\u0026lt;/form\u0026gt; url 쿼리 스트링 생성자 역할을 한다.\nurl 쿼리 스트링은 form 안의 input 태그의 name 속성들과 목적지(처리할 파일)를 포함하고 있다.\nget 방식은 쿼리 스트링을 url에 넣어서 사용하는 것이 맞다. 하지만 post 방식은 url이 아닌 다른 곳에 내용을 담아 전송하게 된다.\nmethod 속성은 get과 post 방식을 설정할 수 있다. ex)\n\u0026lt;form action=\u0026#34;create.py\u0026#34; method=\u0026#34;post\u0026#34;\u0026gt;\r\u0026lt;p\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; name=\u0026#34;title\u0026#34; placeholder=\u0026#34;title\u0026#34;\u0026gt; \u0026lt;/p\u0026gt;\r\u0026lt;p\u0026gt; \u0026lt;textarea rows=\u0026#34;4\u0026#34; name=\u0026#34;description\u0026#34;\u0026gt;\u0026lt;/textarea\u0026gt;\u0026lt;/p\u0026gt;\r\u0026lt;p\u0026gt; \u0026lt;input type=\u0026#34;submit\u0026#34;\u0026gt;\u0026lt;/p\u0026gt;\r\u0026lt;/form\u0026gt; action 속성으로 연결한 python 파일에서 form 안의 내용들을 사용하려면 cgi.FieldStorage()을 사용한다. ex)\nimport cgi\rform = cgi.FieldStorage()\rtitle = form[\u0026#34;title\u0026#34;].value\rdescription = form[\u0026#34;description\u0026#34;].value form 안의 내용 중 사용자에게 노출이필요 없는 input 태그는 type=\u0026ldquo;hidden\u0026rdquo; 속성을 주어 숨긴다. ex) \u0026lt;input type=\u0026quot;hidden\u0026quot; name=\u0026quot;pageId\u0026quot; value={}\u0026gt; 이벤트를 이용하여 form 안의 내용들을 특정 python 파일로 전송시키면 python 파일에서 내용을 처리하고 다른 html로 redirection 시키는 방식으로 웹 구성이 가능하다.\ncross site scripting (xss) 웹 페이지의 script란을 임의로 작성하여 의도되지 않은 동작을 하도록 하는 행위\n컴퓨터가 html 파일을 해석할 때, \u0026lt;script\u0026gt;를 만나면 출력 대상이 아닌, javascript로 처리해야 할 태그로 인식한다. xml 문법에 사용되는 특수문자를 대체하여 이를 막을 수 있다.\n'\u0026lt;' : \u0026amp;lt; '\u0026gt;' : \u0026amp;gt; ex) ''.replace('\u0026lt;','\u0026amp;lt;') \u0026ldquo;python html sanitizer\u0026rdquo; 로 검색하면 관련 패키지 검색이 가능하다.\n정리 python package Index (PyPI): python 패키지들의 목록이 저장되어 있는 곳, 필요한 패키지를 활용하자. CGI는 느려서 최근에는 잘 쓰이지 않고, FastCGI, 파이썬 전용 WSGI 등이 쓰인다. web framework : 웹에서 사용되는 공통적 작업들만 잘 추려서 만든 APIdjango, flask 가 이에 해당. Database 연동 Crawling: 웹페이지를 다운로드, 분석이 필요 (urllib, beautiful Soup 패키지 활용 가능) github의 trending 탭을 보면 현재 가장 인기 있는 패키지를 볼 수 있다. ","permalink":"https://AswinBlue.github.io/post/pythoncgi/","summary":"python CGI CGI는 Common Gateway Interface의 약자다. web application을 만들 수 있는 언어는 ruby, java, php 등 다양하지만 모두 CGI 규약을 따라 web server와 통신한다. web server는 사용자의 요청을 받으면 약속된 이름의 데이터를 환경변수로 web application에 전달하여 서로 교류한다. apache에서 python을 이용해 web application을 만들어 web server와 통신해 보자. $ a2enmod CGI 명령으로 apache의 CGI를 켜 주고, sudo service apache2 restart 로 설정 적용 /var/log/apache2/error.log 안에 apache 실행시 발생한 에러 로그가 담겨있다.","title":"PythonCGI"},{"content":"JavaScript 기본적으로 HTML 위에서 돌아가는 코드 body 태그 안에 태그를 넣고 안에 작성\ndocument를 호출하고, .으로 함수를 호출한다.\nquerySelector(\u0026rsquo;\u0026rsquo;)로 원하는 element 선택 가능, \u0026lsquo;\u0026lsquo;안의 내용은 css 선택자 문법과 같음\nquerySelectorAll(\u0026rsquo;\u0026rsquo;)로 원하는 속성의 element들을 nodeList(배열과 유사)형태로 선택 가능\nex ) document.querySelector('body')\nex ) document.querySelector('#new')\nex ) document.write(\u0026quot;hello world\u0026quot;)\n태그 안에 javaScript를 사용하는 속성값으로 사용\nex ) \u0026lt;input type=\u0026quot;button\u0026quot; value=\u0026quot;hello\u0026quot; onclick=\u0026quot;alert('hello')\u0026quot;\u0026gt;\n특정 태그 안에서 자기자신을 호출할 때에는 querySelector를 호출하지 않고 this를 사용하면 된다.\nex ) \u0026lt;input type=\u0026quot;button\u0026quot; id=\u0026quot;hello\u0026quot; onclick=\u0026quot;document.querySelector('#hello').style.color='black';\u0026quot;\u0026gt;\nex ) \u0026lt;input type=\u0026quot;button\u0026quot; id=\u0026quot;hello\u0026quot; onclick=\u0026quot;this.style.color='black';\u0026quot;\u0026gt;\nvar 로 변수를 선언 가능하다. (var 이 없어도 된다)\n별도의 파일로 분리한 후 파일의 링크를 지정한다.\nex ) \u0026lt;script src=\u0026quot;script.js\u0026quot;\u0026gt; \u0026lt;/script\u0026gt;\n연산자 = : 대입 연산자\n== : 비교 연산자, 좌항과 우항이 같으면 true\n=== : 비교 연산자, 좌항과 우항의 type 까지 비교\nex ) null === undefined : false\nex ) null == undefined : true\nex ) 123 == \u0026quot;123\u0026quot; : true\nex ) 123 === \u0026quot;123\u0026quot; : false\n+ : 덧셈 연산자, 문자열 병합에도 사용 가능\n배열 var NAME = [] 형태로 선언 .length : 배열의 길이를 반환하는 메소드 함수 선언 function FUNCTION_NAME () {} 형태로 함수 선언, ()안에는 인자가, {}안에는 함수 body가 들어간다. 인자로 self를 넣으면 python의 함수가 호출된 객체를 지칭하도록 사용할 수 있다. return 예약어를 통해 함수 종료시 값을 반환 가능(return 필수 아님) 동일한 이름의 함수가 다시 정의되면 이전의 함수는 삭제된다. 객체 var NAME = {}; 형태로 선언 가능\nex ) var coworker = {\u0026quot;designer\u0026quot; : \u0026quot;A\u0026quot;, \u0026quot;programmer\u0026quot; : \u0026quot;B\u0026quot;, \u0026quot;data scientist\u0026quot; : \u0026quot;C\u0026quot;};\n객체의 값은 . 이나 [] 로 참조 가능, property라고 칭한다.\nex ) coworker.designer\nex ) coworker[\u0026quot;data scientist\u0026quot;]\n객체의 필드들은 ,로 구분해야 한다. 함수도 {} 다음에 ,를 찍어준다.\nex ) var coworker = { \u0026quot;designer\u0026quot;:\u0026quot;A\u0026quot;, showAll:function( ){ }, \u0026quot;programmer\u0026quot;:\u0026quot;B\u0026quot; }\n이미 선언된 객체에 새로운 값 추가 혹은 기존 값 변경 가능\nex ) coworker.new = \u0026quot;D\u0026quot;\nex ) coworker.programmer = \u0026quot;E\u0026quot;\nfor ( .. in ~~ ) {} : 객체 내부 순회, ..는 내부 원소를 지칭할 변수를 선언하고, ~~에는 객체를 넣어준다.\nex ) for (var key : coworker) {}\n객체 내부에 함수도 선언 가능, method라고 칭한다.\nex ) var body = { setColor:function( ){ } }\nex ) coworker.setColor = function() {}\n객체 내부의 메소드에서 객체를 칭할 때에는 this를 사용\nex ) funciton () { for (var key in this) {} }\n데이터 타입 primitive Boolean Null Undefined Number 연산으로 계산 가능 String \u0026rsquo; \u0026rsquo; 나 \u0026quot; \u0026quot; 로 묶어서 사용 + 으로 concatenate 가능 Symbol Object 이벤트 onclick : 클릭 이벤트가 일어났을 때 onchange : 텍스트 에디터의 내용이 변경되었을 경우 onkeydown : 키를 눌렀을 때 메소드 alert(\u0026rsquo; \u0026lsquo;) : 브라우저의 경고창에 \u0026rsquo;\u0026rsquo; 안의 내용을 띄움 .length : 문자열의 길이를 반환, 배열의 길이를 반환 .indexOf(\u0026rsquo; \u0026lsquo;) : 문자열 중 \u0026lsquo;\u0026lsquo;에 속하는 문자 혹은 문자열이 시작되는 index를 반환, 0부터 카운팅 .trim() : 문자열의 공백을 제거 .value : element의 값을 뜻하는 변수 호출 함수 var repeat = setInterval(function, time) : time 만큼 delay를 주고 function을 반복한다. 독립 thread로 동작한다. clearInterval(repeat) : 인자로 받은 interval 반복함수를 정지한다. var result = setTimeout(function, time) : time만큼 delay후 function을 실행한다. 실행후 result에는 \u0026rsquo;true\u0026rsquo;가 저장된다. Jquery javascript상에서 document를 대체하여 사용성을 높인 라이브러리\n$() 로 시작한다.\nex ) $('a').css('color','red') : 모든 \u0026lsquo;a\u0026rsquo; 태그의 css 속성 중 color을 red로 변경\n참조 document \u0026lt; DOM (Document Object Model) \u0026lt; window ajax : 웹페이지를 변경하지 않고 내용 변경 cookie : 사용자에게 개별화된 서비스 제공 offline web application : 인터넷이 끊겨도 동작하는 어플리케이션 webRTC : 화상통신 웹 speech(로 시작하는 API) : 사용자 음성 처리 webGL : 3차원 그래픽 webVR : 가상현실 ","permalink":"https://AswinBlue.github.io/post/javascript/","summary":"JavaScript 기본적으로 HTML 위에서 돌아가는 코드 body 태그 안에 태그를 넣고 안에 작성\ndocument를 호출하고, .으로 함수를 호출한다.\nquerySelector(\u0026rsquo;\u0026rsquo;)로 원하는 element 선택 가능, \u0026lsquo;\u0026lsquo;안의 내용은 css 선택자 문법과 같음\nquerySelectorAll(\u0026rsquo;\u0026rsquo;)로 원하는 속성의 element들을 nodeList(배열과 유사)형태로 선택 가능\nex ) document.querySelector('body')\nex ) document.querySelector('#new')\nex ) document.write(\u0026quot;hello world\u0026quot;)\n태그 안에 javaScript를 사용하는 속성값으로 사용\nex ) \u0026lt;input type=\u0026quot;button\u0026quot; value=\u0026quot;hello\u0026quot; onclick=\u0026quot;alert('hello')\u0026quot;\u0026gt;\n특정 태그 안에서 자기자신을 호출할 때에는 querySelector를 호출하지 않고 this를 사용하면 된다.","title":"JavaScript"},{"content":"CSS 특정 개체에 효과를 부과한다. 이를 declaration 이라 칭한다. 중복의 제거 가능, 유지보수 수월, 가독성 증가 위에서 부터 아래로 읽어가며 효과 적용, 중복 불가능한 효과에 대해서는 이전 효과가 사라짐 tag 선택자 \u0026lt; calss 선택자 \u0026lt; id 선택자 로 우선 순위가 높다. html 문서 안에 \u0026lt;style\u0026gt; 태그 안에 작성 가능\nex ) \u0026lt;style\u0026gt; a { color:black; } \u0026lt;/style\u0026gt;\n태그의 종류별로 속성 설정 가능\n여기서 태그 a 는 선택자(selector)라고 한다.\n선택자는 ,로 구별하여 함께 사용 가능\nex ) \u0026lt;style\u0026gt; a, h1 { color:black; } \u0026lt;/style\u0026gt;\n특정 태그의 자식태그 중 하나의 속성을 지정하고 싶다면 띄워쓰기로 구분한다. ex ) 중괄호{} 안에 declaration을 작성한다.\n하나의 declaration은 ;로 끝나서 다음 declaration과 구분된다.\n특정 태그 안에 style 속성을 넣어 작성 가능\nex ) \u0026lt;a style=\u0026quot;color:black\u0026quot;\u0026gt; \u0026lt;/a\u0026gt;\n다른 파일로 만들어 사용 가능\n재사용이 가능해 가장 효율적인 방법\n웹페이지 안에 직접 css를 넣는 것이 트래픽적 관점에서는 더 효율적이지만, 재사용성과 캐싱 기법에 의해 본 기법이 더 효율적이다.\nex ) \u0026lt;link rel=\u0026quot;stylesheet\u0026quot; href=\u0026quot;style.css\u0026quot;\u0026gt; 특정 태그(element)를 지정해 효과 설정이 가능하다.\nex ) \u0026lt;style\u0026gt; a { color:black; } \u0026lt;/style\u0026gt;\n특정 class를 지정해 효과 설정이 가능하다. class를 지칭할 때에는 이름 앞에 . 을 찍는다. 태그 선택자 보다 우선 순위가 높다.\nex ) \u0026lt;style\u0026gt; .saw{color:gray;} \u0026lt;/style\u0026gt;\n특정 id를 지정해 효과 설정이 가능하다. id를 지정할 때에는 이름 앞에 # 을 찍는다. class보다 우선 순위가 높다.\nex ) \u0026lt;style\u0026gt; #active{color:red;} \u0026lt;/style\u0026gt;\n스타일 PROPERTY:PROPERTY_VALUE; 형태로 존재한다. color:red : 색깔 변경(빨강) text-decoration:none : 꾸미기 없음 text-decoration:underline : 밑줄 font-size:45px : 글자 크기 설정 text-align:center : 글자 정렬 설정(가운데 정렬) border-width:5px : 테두리 굵기 설정 border-color:red : 테두리 색상 설정 border-style:solid : 테두리 모양 설정(직선) border 스타일 및 일부 스타일은 축약해서 사용 가능하다.\nex) \u0026lt;style\u0026gt; a{ border: 5px red solid;} \u0026lt;/style\u0026gt;\nborder-bottom: 1px solid gray : 아래쪽 테두리에만 설정 적용 display:inline : 태그의 레벨 속성(inline element - block element)을 변경 display:none : 화면에 표시 안함 display:grid : grid 형태로 표시 grid-template-colums: 150px 1fr : 그리드 형태를 열로 하고, 첫 열은 150, 둘째 열은 남은 공간을 사용하도록 설정 padding:20px : 테두리와 내용 사이의 버퍼 설정 margin:10px : 테두리 바깥과 다른 element 사이의 버퍼 설정 width:100px : element 폭 설정 단위 px : 픽셀 fr : 남은 자유공간으로 그 크기는 ((현재 fr 수치 / \u0026lt;총 사용된 fr\u0026gt;) * 남은 공간) 으로 계산된다. 미디어 쿼리 반응형 웹(responsive web) 을 위한 내용\n@media() {} 와 같이 표현되며, () 안에는 조건문이 들어가고, {} 안에는 적용 할 내용이 들어간다.\nex ) \u0026lt;style\u0026gt; @media(min-width:800px) {div {display:none;}} \u0026lt;/style\u0026gt;\nhttp://caniuse.com : 특정 스타일을 사용했을 때 몇 %의 브라우저가 해당 스타일을 지원하는지 확인 가능한 사이트\n","permalink":"https://AswinBlue.github.io/post/css/","summary":"CSS 특정 개체에 효과를 부과한다. 이를 declaration 이라 칭한다. 중복의 제거 가능, 유지보수 수월, 가독성 증가 위에서 부터 아래로 읽어가며 효과 적용, 중복 불가능한 효과에 대해서는 이전 효과가 사라짐 tag 선택자 \u0026lt; calss 선택자 \u0026lt; id 선택자 로 우선 순위가 높다. html 문서 안에 \u0026lt;style\u0026gt; 태그 안에 작성 가능\nex ) \u0026lt;style\u0026gt; a { color:black; } \u0026lt;/style\u0026gt;\n태그의 종류별로 속성 설정 가능\n여기서 태그 a 는 선택자(selector)라고 한다.\n선택자는 ,로 구별하여 함께 사용 가능","title":"Css"},{"content":"HTML W3C에서 HTML 규칙을 규정, 웹 브라우저 제작사들이 이를 참조하여 브라우저를 만든다. 태그 element라고 칭하기도 한다. 부모 자식 관계가 존재 \u0026lt;TAG_NAME\u0026gt; 로 시작하고 \u0026lt;/TAG_NAME\u0026gt;로 끝냄 태그별로 검색 엔진에서 노출되는 중요도가 다르다. 태그의 종류에 따라 줄 전체를 사용하거나(block level element), 내용의 크기 만큼의 공간만 사용하는 태그(lnline element)들이 있다. html : body와 head를 통틀어 묶은 최 고위 태그 관용적으로 \u0026lt;!doctype html\u0026gt; 을 붙여 쓴다. body : 본문을 묶는 태그 head : 본문을 설명하는 태그 body 태그 strong : 굵은 글씨\nu : 밑줄\nh1 : 제목 1\nh2 : 제목 2\nh6 : 제목 6\np : 단락 설정\nbr : 줄바꿈\nimg : 이미지\n\u0026lt;img src=\u0026quot;\u0026quot;\u0026gt; : src에 경로 지정\nli : 리스트\nul태그를 부모로 가짐 ul : 리스트 그루핑을 위한 태그\nli 태그를 자식으로 가짐 unordered-list ol : 넘버링 되는 리스트를 위한 태그\nordered-list a : 링크\nAnchor의 약자 href 속겅 필요 (hypertext reference) target : 창을 여는 방법, \u0026ldquo;_blank\u0026rdquo; : 새창 title : 마우스 오버레이시 툴팁 표시 input :\ntype=\u0026ldquo;checkbox\u0026rdquo; : 체크박스 type=\u0026ldquo;button\u0026rdquo; : 버튼 onclick=\u0026quot;\u0026quot; : \u0026quot;\u0026quot; 사이에는 javascript가 들어간다. 버튼 클릭 시 동작할 내용 \u0026lt;input\u0026gt; 으로 끝난다. \u0026lt;input/\u0026gt; 이나 \u0026lt;input\u0026gt; \u0026lt;/input\u0026gt; 으로 사용하지 않는다. font :\ncss가 등장하기 이전에 문자의 스타일을 설정하게 하기 위함 어껀 정보도 없는 태그, 기자인만을 위함 class : 태그들을 특정 그룹으로 묶기 위함\n하나의 태그에 두 개 이상의 class 지정 가능 id : 특정 태그에 명칭을 붙이기 위함\nclass 보다 높은 우선순위 단 한 번만 사용하도록 권장, 중복하여 사용하지 않도록 한다. div : 아무 의미 없이 디자인의 용도로만 사용하는 태그, block element\nspan : div와 같지만 inline element\nform : 폼 데이터 전송을 위한 태그, 하위\naction : 데이터를 어디로 전송할지 나타내는 속성 method : 데이터를 어떻게 전송할지 나타내는 속성. post/get을 사용 가능하다. head 태그 title : 제목 meta : 현재는 사용되자 않음 style : CSS 코드 삽입부 속성(attribute) \u0026lt;TAG_NAME ATTRIBUTE\u0026gt; 와 같은 형태로 태그 이름 뒤에 붙음\n","permalink":"https://AswinBlue.github.io/post/html/","summary":"HTML W3C에서 HTML 규칙을 규정, 웹 브라우저 제작사들이 이를 참조하여 브라우저를 만든다. 태그 element라고 칭하기도 한다. 부모 자식 관계가 존재 \u0026lt;TAG_NAME\u0026gt; 로 시작하고 \u0026lt;/TAG_NAME\u0026gt;로 끝냄 태그별로 검색 엔진에서 노출되는 중요도가 다르다. 태그의 종류에 따라 줄 전체를 사용하거나(block level element), 내용의 크기 만큼의 공간만 사용하는 태그(lnline element)들이 있다. html : body와 head를 통틀어 묶은 최 고위 태그 관용적으로 \u0026lt;!doctype html\u0026gt; 을 붙여 쓴다. body : 본문을 묶는 태그 head : 본문을 설명하는 태그 body 태그 strong : 굵은 글씨","title":"Html"},{"content":"Linux 서버에 개발 환경을 세팅하는데 뭔가 제대로 되지 않아 이미 환경설정을 해 본 다른 사람에게 원격으로 도움을 요청했다.\n하지만 그 사람이 리눅스에 익숙하지 않았는지, 우리 서버를 잘못 만져 apt가 먹통이 되는 현상이 발생했다.\n본 해프닝에 대해 서술하자면 아래와 같다.\n원인 /bin 디렉터리 안의 python bin파일을 강제로 삭제한 것이 원인으로 추정된다.\n환경 설정을 하는데 제대로 되지 않으니 sudo apt-get upgrade 명령도 남용하기도 했다.\n현상 apt를 이용해 install, remove를 하려 하면 py3compile, py3clean 등에서 오류가 발생하였다.\napt 명령을 수행하면\n/usr/bin/dpkg return an errorcode(1) 오류가 발생하며 정상 동작하지 않는다.\ninstall -f 명령도 먹히지 않았다.\n해결 python bin파일이 없어졌고, python이 없다는 내용이 떴으므로 python을 다시 설치해 봤다.\napt가 제대로 동작하지 않았으므로 git에서 python을 받아 빌드하여 설치했다.\ndpkg return an errorcode(1) 을 검색해보니 dpkg에 문제가 있을 수 있다는 내용이 많았다.\ndpkg를 재설정 해보라는 글들이 많아 내용대로 따라가 보았다.\n/var/lib/dpkg/info 에는 설치된 프로그램의 목록들이 저장되어 있는듯 하다.\napt 명령을 수행할 때 오류가 발생하는 프로그램들을 찾아 rm 명령으로 해당 프로그램의 내용을 삭제한다.\n삭제 후 dpkg --configure -a 명령을 사용하여 dpkg를 재설정 해준다.\n그 후 apt 명령을 사용하여 설치, 삭제를 해 보니 dpkg를 리셋한 내용들은 오류에 뜨지 않았다.\n오류가 나지 않을 때 까지 dpkg를 계속 재설정 해주니 정상 동작하게 되었다.\n결론 /bin 안의 파일들을 강제로 삭제하면 apt가 충돌이 일어나 동작하지 않을 수 있으므로 주의한다.\n/var/lib/dpkg/info 에서 설치된 패키지의 내용들을 확인 가능하다.\ndpkg --configure -a 명령으로 dpkg를 리셋할 수 있다.\n","permalink":"https://AswinBlue.github.io/post/linux_apt/","summary":"Linux 서버에 개발 환경을 세팅하는데 뭔가 제대로 되지 않아 이미 환경설정을 해 본 다른 사람에게 원격으로 도움을 요청했다.\n하지만 그 사람이 리눅스에 익숙하지 않았는지, 우리 서버를 잘못 만져 apt가 먹통이 되는 현상이 발생했다.\n본 해프닝에 대해 서술하자면 아래와 같다.\n원인 /bin 디렉터리 안의 python bin파일을 강제로 삭제한 것이 원인으로 추정된다.\n환경 설정을 하는데 제대로 되지 않으니 sudo apt-get upgrade 명령도 남용하기도 했다.\n현상 apt를 이용해 install, remove를 하려 하면 py3compile, py3clean 등에서 오류가 발생하였다.","title":"Linux_apt"},{"content":"Hugo를 이용해 블로그 만들기 Git과 markdown을 이용하여 git을 블로그처럼 이용하는 사람들이 있다는 것을 알았다.\n게다가 UI를 보기 좋게 꾸며줄 수 있는 툴들도 찾았는데, 그 중 Hugo를 사용해 보았다.\nHugo는 Go 언어로 짜여져 있어 apt-get으로도 설치가 가능하고, 소스 코드를 받아 빌드하여 쓸 수도 있다.\n내 컴퓨터에는 Go가 이미 설치되 있던 터라 apt-get으로 hugo를 받아서 사용해 보았다.\n설치는 정상적으로 되었고, 처음에는 잘 동작하는 듯 했는데, theme을 적용하니 ERROR들이 뜨기 시작했다.\n인터넷 검색을 아무리 해 봐도 해결책이 보이지 않고, 해당 git에 issue를 날려보기도 했는데 응답이 없어서 혼자 이것저것 뒤져 보았다.\n알고보니 내 hugo의 버전이 너무 낮아서 발생한 현상이었고, 덩달아 Go의 버전도 낮다는 것을 알아냈다.\nGo언어는 apt-get 대신 인터넷에서 tar파일을 받아서 압축을 풀어 사용했고, Hugo는 소스코드를 받아 Go 언어로 빌드하여 사용하였다.\n(brew를 이용해 보라고도 해서 brew를 설치 해 보기도 했는데, 잘 동작 하지 않아서 그만뒀다.)\n버전을 최신으로 맞추고 나니 모두 정상동작, git에 올려놓은 issue를 뻘쭘하게 혼자 close했다.\n링크 hugo 환경설정 및 사용방법 가이드\n아래 주소의 글쓴이도 hugo로 블로그를 만들어 관리하고 있다. 이분의 글을 토대로 환경을 세팅했다.\nhttps://github.com/Integerous/Integerous.github.io\nHugo git 사이트\nHugo의 소스파일을 다운받을 수 있다.\nhttps://github.com/gohugoio/hugo\n내가 사용한 theme의 git 주소\n설명대로 theme을 다운받고, config파일을 수정해 주어야 최종적으로 적용이 된다.\nhttps://github.com/cntrump/hugo-notepadium\nGo 언어 설치 가이드\nhttps://golang.org/doc/install\nHugo 설치 가이드\nhttps://gohugo.io/getting-started/installing/\n환경 세팅 (window) 리눅스 환경세팅은 apt, yum을 이용하면 간단하게 수행 가능하여 생략한다.\nGo 언어를 설치한다. 설치파일로 받아서 설치하면 간단하다. 리눅스에 설치할 경우, apt를 사용하면 낮은 버전이 설치될 수 있으니 코드를 받아 설치하는걸 추천한다. Hugo를 설치한다. 압축파일 형태로 제공되며, 압축을 푼 후 path 설정만 해주면 된다. 리눅스의 경우 코드를 이용해 설치할 수 있다. git 레퍼지토리를 2개 생성한다. 한개는 글 작성용, 한개는 publish용이다. (이 경우, \u0026lt;GITHUB_ID\u0026gt;.github.io 이름으로 repository를 생성한다. 그렇지 않으면 정상동작하지 않는다.)\nex) github.com/AswinBlue/AswinBlue.github.io 작성용은 소스코드에 해당하며 publish용은 컴파일된 바이너리에 해당한다고 보면 된다. 프로젝트를 생성한다. hugo new site \u0026lt;SITE\u0026gt; 명령으로 새로운 hugo 프로젝트를 생성한다. 생성한 프로젝트를 git과 연동시킨다. 프로젝트 root디렉터리에 (3)에서 만든 소스용 git을 연동시킨다. /public 디렉터리에 (3)에서 만든 publish용 git을 연동시킨다. git 폴더 안에 git을 연동하려면 git submodule add \u0026lt;URL\u0026gt;명령어를 이용한다. 테마를 선택한다. 인터넷에서 hugo 테마를 검색하여, 원하는 테마의 git repository를 /themes 경로에 clone 한다. 이후, 해당 테마에서 지원하는 config 파일을 root 경로에 복사한다. config 파일은 toml, yaml, json 형태로 작성이 가능하며, hugo에서는 toml -\u0026gt; yaml -\u0026gt; json 순서대로 config파일을 찾아 적용한다. (즉, config.toml파일이 있으면 config.yml파일은 적용되지 않음) 기본 탬플릿을 설정한다. /archtypes/default.md 파일을 수정하면, hugo new NEW_POST.md 를 이용해 새로운 파일을 생성할 때 사용되는 기본 md파일 탬플릿을 정의할 수 있다. 파일 생성시 .md 확장자가 붙여야 정상 동작함에 주의한다. 기본 동작 프로젝트 생성 새로운 Hugo 사이트를 생성하는 명령어, 폴더 안에 Hugo 구조에 맞게 폴더 및 파일이 자동 생성된다.\nhugo new site \u0026lt;NAME\u0026gt; 생성된 폴더에서 새로운 post를 생성하는 명령어, content 폴더 안에 archtype에 맞게 내용을 적어 파일을 생성한다.\nhugo new \u0026lt;POST\u0026gt;.md\rex) hugo new post/hugo.md 테마에 맞는 형식으로 content 폴더 안의 내용을 이용해 public 폴더 안에 내용을 생성한다.\nhugo -t \u0026lt;THEME\u0026gt; config파일에 따라 hugo --config config.yml 와 같이 명령어를 사용할 수도 있다.\n본 페이지는 hugo-PaperMod 테마를 사용했다.\n문서 최상단에 +++로 둘러쌓인 부분은 설정 부분이다. draft=false로 설정을 해야 화면에 표시됨에 주의한다.\ntoml을 사용한다면 +++로 formatter를 구성 하고, yaml은 ---, json은 {} 을 사용한다. public 폴더에 생성한 내용을 push 하기 전 테스트 해 본다.\nhugo server [--theme \u0026lt;THEME_PATH\u0026gt;] 서버 실행 후 http://localhost:1313 경로에서 웹 브라우저로 내용을 확인할 수 있다.\n내용이 완벽하다면 public 폴더 안의 git을 push 하면 \u0026lt;GIT_ID\u0026gt;.github.io 주소에서 방금 본 내용을 볼 수 있다. ex : aswinblue.github.io\nGo와 Hugo의 설치만 잘 하면 사용 가이드는 인터넷에 잘 정리된 글들이 많다. 참조하면 활용에 문제는 없을 것이다.\n문법 Hugo 문법 hugo는 html 안에 {{ }} 형태로 hugo용 구문을 넣을 수 있다. {{ }}안에 --, %%, \u0026lt;\u0026gt; 를 넣어 용도에 따라 다양한 변형이 있을 수 있다. {{- }}, {{ -}}, {{- -}} 를 사용하면 앞/뒤쪽의 줄바꿈 및 빈 여백을 모두 제거해 준다. 변수 선언 변수는 site, page 에 따라 다르게 선언 할 수 있다. config.yml 파일에 선언하면 site 단위로 선언되며, 전역 변수처럼 모든 page에서 참조 가능하다. .Params 은 page 변수를 참조하며, site.Params 은 site 변수를 참조하는 방식이다. {{- $isHidden := Params.cover.hidden | default site.Params.cover.hiddenInSingle | default site.Params.cover.hidden }} : page 내에서 변수를 선언하는 조건문 {{- if (.Param \u0026quot;ShowToc\u0026quot;) }} : page변수에서 ShotToc가 있는지 체크 Adsense 추가 구글 애드센스를 휴고 Blog에 넣고싶다면, 아래와 같은 절차를 거치면 된다.\nthemes/원하는_테마/layouts/partials/ 디렉터리 안에 adsense.html 파일을 만들고, 애드센스에 필요한 script를 붙여넣은 후 저장한다. themes/원하는_테마/layouts/partials/ 디렉터리 안에 head.html 파일을 열고, {{- partial \u0026quot;adsense.html\u0026quot; . -}} 한줄을 추가하고 저장한다. hugo -t 원하는_테마 명령으로 다시 빌드하고, 서버에 push한다. sidebar 형태의 구문을 넣고싶다면, baseof.html 파일을 수정해야 한다. \u0026lt;div class=\u0026quot;grid-container\u0026quot;\u0026gt; 태그로 main을 감싸고, main과 sidebar을 동일한 level에 배치한다.\n# before\r\u0026lt;main class=\u0026#34;main\u0026#34;\u0026gt;\r{{- block \u0026#34;main\u0026#34; . }}{{ end }}\r\u0026lt;/main\u0026gt; # after\r\u0026lt;div class=\u0026#34;grid-container\u0026#34;\u0026gt;\r{{ partial \u0026#34;sidebar.html\u0026#34; . }}\r\u0026lt;main class=\u0026#34;main\u0026#34;\u0026gt;\r{{- block \u0026#34;main\u0026#34; . }}{{ end }}\r\u0026lt;/main\u0026gt;\r\u0026lt;/div\u0026gt; github page 자동화 github에서 제공하는 CI/CD 인 github actions 를 사용하면 push시 자동으로 배포를 할 수 있다.\ngithub actions -\u0026gt; Categories:Pages -\u0026gt; Hugo 선택 템플릿 파일로 HugoBlog/.github/workflows/hugo.yml 파일을 제공한다. 본인의 상황에 맞게 작성한 후 remote branch에 반영한다. # Sample workflow for building and deploying a Hugo site to GitHub Pages\rname: Deploy Hugo site to Pages\ron:\r# Runs on pushes targeting the default branch\rpush:\rbranches: [\u0026#34;master\u0026#34;]\r# Allows you to run this workflow manually from the Actions tab\rworkflow_dispatch:\r# Sets permissions of the GITHUB_TOKEN to allow deployment to GitHub Pages\rpermissions:\rcontents: read\rpages: write\rid-token: write\r# Allow only one concurrent deployment, skipping runs queued between the run in-progress and latest queued.\r# However, do NOT cancel in-progress runs as we want to allow these production deployments to complete.\rconcurrency:\rgroup: \u0026#34;pages\u0026#34;\rcancel-in-progress: false\r# Default to bash\rdefaults:\rrun:\rshell: bash\rjobs:\r# Build job\rbuild:\rruns-on: ubuntu-latest\renv:\rHUGO_VERSION: 0.108.0\rsteps:\r- name: Install Hugo CLI\rrun: |\rwget -O ${{ runner.temp }}/hugo.deb https://github.com/gohugoio/hugo/releases/download/v${HUGO_VERSION}/hugo_extended_${HUGO_VERSION}_linux-amd64.deb \\\r\u0026amp;\u0026amp; sudo dpkg -i ${{ runner.temp }}/hugo.deb\r- name: Install Dart Sass Embedded\rrun: sudo snap install dart-sass-embedded\r- name: Checkout\ruses: actions/checkout@v3\rwith:\rsubmodules: recursive\r- name: Setup Pages\rid: pages\ruses: actions/configure-pages@v3\r- name: Install Node.js dependencies\rrun: \u0026#34;[[ -f package-lock.json || -f npm-shrinkwrap.json ]] \u0026amp;\u0026amp; npm ci || true\u0026#34;\r- name: Build with Hugo\renv:\r# For maximum backward compatibility with Hugo modules\rHUGO_ENVIRONMENT: production\rHUGO_ENV: production\rrun: |\rhugo --minify --config config.yml\r- name: Upload artifact\ruses: actions/upload-pages-artifact@v1\rwith:\rpath: ./public\r# Deployment job\rdeploy:\renvironment:\rname: github-pages\rurl: ${{ steps.deployment.outputs.page_url }}\rruns-on: ubuntu-latest\rneeds: build\rsteps:\r- name: Deploy to GitHub Pages\rid: deployment\ruses: actions/deploy-pages@v2 오류 해결 fatal: remote error: upload-pack: not our ref 7821df1a10579b4a62917f0f07d3a5c482e872f6 github actions/checkout@v3 에서 submodule의 특정 commit으로 checkout 이 안되는 현상이다. render of \u0026quot;page\u0026quot; failed: \u0026quot;C:\\HugoBlog\\themes\\hugo-PaperMod\\layouts\\_default\\baseof.html:5:8\u0026quot;: execute of template failed: template: _default/single.html:5:8: executing \u0026quot;_default/single.html\u0026quot; at \u0026lt;partial \u0026quot;head.html\u0026quot; .\u0026gt;: error calling partial: execute of template failed: template: partials/templates/opengraph.html:5:14: executing \u0026quot;partials/templates/opengraph.html\u0026quot; at \u0026lt;.Params.cover.image\u0026gt;: can't evaluate field image in type string 빌드 했을 때 위와같은 오류가 발생 한다면, golang과 hugo 버전 차이에 따라 페이지가 파싱이 제대로 되지 않는 경우이다. hugo 문법에 따라 페이지를 수정하거나 golang, hugo 버전을 최신으로 업데이트 해 본다. ","permalink":"https://AswinBlue.github.io/post/hugo_dev/","summary":"Hugo를 이용해 블로그 만들기 Git과 markdown을 이용하여 git을 블로그처럼 이용하는 사람들이 있다는 것을 알았다.\n게다가 UI를 보기 좋게 꾸며줄 수 있는 툴들도 찾았는데, 그 중 Hugo를 사용해 보았다.\nHugo는 Go 언어로 짜여져 있어 apt-get으로도 설치가 가능하고, 소스 코드를 받아 빌드하여 쓸 수도 있다.\n내 컴퓨터에는 Go가 이미 설치되 있던 터라 apt-get으로 hugo를 받아서 사용해 보았다.\n설치는 정상적으로 되었고, 처음에는 잘 동작하는 듯 했는데, theme을 적용하니 ERROR들이 뜨기 시작했다.\n인터넷 검색을 아무리 해 봐도 해결책이 보이지 않고, 해당 git에 issue를 날려보기도 했는데 응답이 없어서 혼자 이것저것 뒤져 보았다.","title":"Hugo 환경세팅"},{"content":"This article offers a sample of basic Markdown syntax that can be used in Hugo content files, also it shows whether basic HTML elements are decorated with CSS in a Hugo theme.\nHeadings The following HTML \u0026lt;h1\u0026gt;—\u0026lt;h6\u0026gt; elements represent six levels of section headings. \u0026lt;h1\u0026gt; is the highest section level while \u0026lt;h6\u0026gt; is the lowest.\nH1 H2 H3 H4 H5 H6 `` The following HTML \u0026lt;h1\u0026gt;—\u0026lt;h6\u0026gt; elements represent six levels of section headings. \u0026lt;h1\u0026gt; is the highest section level while \u0026lt;h6\u0026gt; is the lowest.\nH1 H2 H3 H4 H5 H6 ``\nParagraph Xerum, quo qui aut unt expliquam qui dolut labo. Aque venitatiusda cum, voluptionse latur sitiae dolessi aut parist aut dollo enim qui voluptate ma dolestendit peritin re plis aut quas inctum laceat est volestemque commosa as cus endigna tectur, offic to cor sequas etum rerum idem sintibus eiur? Quianimin porecus evelectur, cum que nis nust voloribus ratem aut omnimi, sitatur? Quiatem. Nam, omnis sum am facea corem alique molestrunt et eos evelece arcillit ut aut eos eos nus, sin conecerem erum fuga. Ri oditatquam, ad quibus unda veliamenimin cusam et facea ipsamus es exerum sitate dolores editium rerore eost, temped molorro ratiae volorro te reribus dolorer sperchicium faceata tiustia prat.\nItatur? Quiatae cullecum rem ent aut odis in re eossequodi nonsequ idebis ne sapicia is sinveli squiatum, core et que aut hariosam ex eat.\n`` Xerum, quo qui aut unt expliquam qui dolut labo. Aque venitatiusda cum, voluptionse latur sitiae dolessi aut parist aut dollo enim qui voluptate ma dolestendit peritin re plis aut quas inctum laceat est volestemque commosa as cus endigna tectur, offic to cor sequas etum rerum idem sintibus eiur? Quianimin porecus evelectur, cum que nis nust voloribus ratem aut omnimi, sitatur? Quiatem. Nam, omnis sum am facea corem alique molestrunt et eos evelece arcillit ut aut eos eos nus, sin conecerem erum fuga. Ri oditatquam, ad quibus unda veliamenimin cusam et facea ipsamus es exerum sitate dolores editium rerore eost, temped molorro ratiae volorro te reribus dolorer sperchicium faceata tiustia prat.\nItatur? Quiatae cullecum rem ent aut odis in re eossequodi nonsequ idebis ne sapicia is sinveli squiatum, core et que aut hariosam ex eat.\n``\nBlockquotes The blockquote element represents content that is quoted from another source, optionally with a citation which must be within a footer or cite element, and optionally with in-line changes such as annotations and abbreviations.\nBlockquote without attribution Tiam, ad mint andaepu dandae nostion secatur sequo quae. Note that you can use Markdown syntax within a blockquote.\nBlockquote with attribution Don\u0026rsquo;t communicate by sharing memory, share memory by communicating.\n— Rob Pike1\nTables Tables aren\u0026rsquo;t part of the core Markdown spec, but Hugo supports supports them out-of-the-box.\nName Age Bob 27 Alice 23 Inline Markdown within tables Inline Markdown In Table italics bold strikethrough code Code Blocks Code block with backticks html\r\u0026lt;!DOCTYPE html\u0026gt;\r\u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt;\r\u0026lt;head\u0026gt;\r\u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt;\r\u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt;\r\u0026lt;/head\u0026gt;\r\u0026lt;body\u0026gt;\r\u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt;\r\u0026lt;/body\u0026gt;\r\u0026lt;/html\u0026gt; Code block indented with four spaces \u0026lt;!DOCTYPE html\u0026gt;\r\u0026lt;html lang=\u0026quot;en\u0026quot;\u0026gt;\r\u0026lt;head\u0026gt;\r\u0026lt;meta charset=\u0026quot;UTF-8\u0026quot;\u0026gt;\r\u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt;\r\u0026lt;/head\u0026gt;\r\u0026lt;body\u0026gt;\r\u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt;\r\u0026lt;/body\u0026gt;\r\u0026lt;/html\u0026gt;\rCode block with Hugo\u0026rsquo;s internal highlight shortcode \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; List Types Ordered List First item Second item Third item Unordered List List item Another item And another item Nested list Item First Sub-item Second Sub-item Other Elements — abbr, sub, sup, kbd, mark GIF is a bitmap image format.\nH2O\nXn + Yn = Zn\nPress CTRL+ALT+Delete to end the session.\nMost salamanders are nocturnal, and hunt for insects, worms, and other small creatures.\nWelcome to StackEdit! Hi! I\u0026rsquo;m your first Markdown file in StackEdit. If you want to learn about StackEdit, you can read me. If you want to play with Markdown, you can edit me. Once you have finished with me, you can create new files by opening the file explorer on the left corner of the navigation bar.\nFiles StackEdit stores your files in your browser, which means all your files are automatically saved locally and are accessible offline!\nCreate files and folders The file explorer is accessible using the button in left corner of the navigation bar. You can create a new file by clicking the New file button in the file explorer. You can also create folders by clicking the New folder button.\nSwitch to another file All your files and folders are presented as a tree in the file explorer. You can switch from one to another by clicking a file in the tree.\nRename a file You can rename the current file by clicking the file name in the navigation bar or by clicking the Rename button in the file explorer.\nDelete a file You can delete the current file by clicking the Remove button in the file explorer. The file will be moved into the Trash folder and automatically deleted after 7 days of inactivity.\nExport a file You can export the current file by clicking Export to disk in the menu. You can choose to export the file as plain Markdown, as HTML using a Handlebars template or as a PDF.\nSynchronization Synchronization is one of the biggest features of StackEdit. It enables you to synchronize any file in your workspace with other files stored in your Google Drive, your Dropbox and your GitHub accounts. This allows you to keep writing on other devices, collaborate with people you share the file with, integrate easily into your workflow\u0026hellip; The synchronization mechanism takes place every minute in the background, downloading, merging, and uploading file modifications.\nThere are two types of synchronization and they can complement each other:\nThe workspace synchronization will sync all your files, folders and settings automatically. This will allow you to fetch your workspace on any other device.\nTo start syncing your workspace, just sign in with Google in the menu.\nThe file synchronization will keep one file of the workspace synced with one or multiple files in Google Drive, Dropbox or GitHub. Before starting to sync files, you must link an account in the Synchronize sub-menu.\nOpen a file You can open a file from Google Drive, Dropbox or GitHub by opening the Synchronize sub-menu and clicking Open from. Once opened in the workspace, any modification in the file will be automatically synced.\nSave a file You can save any file of the workspace to Google Drive, Dropbox or GitHub by opening the Synchronize sub-menu and clicking Save on. Even if a file in the workspace is already synced, you can save it to another location. StackEdit can sync one file with multiple locations and accounts.\nSynchronize a file Once your file is linked to a synchronized location, StackEdit will periodically synchronize it by downloading/uploading any modification. A merge will be performed if necessary and conflicts will be resolved.\nIf you just have modified your file and you want to force syncing, click the Synchronize now button in the navigation bar.\nNote: The Synchronize now button is disabled if you have no file to synchronize.\nManage file synchronization Since one file can be synced with multiple locations, you can list and manage synchronized locations by clicking File synchronization in the Synchronize sub-menu. This allows you to list and remove synchronized locations that are linked to your file.\nPublication Publishing in StackEdit makes it simple for you to publish online your files. Once you\u0026rsquo;re happy with a file, you can publish it to different hosting platforms like Blogger, Dropbox, Gist, GitHub, Google Drive, WordPress and Zendesk. With Handlebars templates, you have full control over what you export.\nBefore starting to publish, you must link an account in the Publish sub-menu.\nPublish a File You can publish your file by opening the Publish sub-menu and by clicking Publish to. For some locations, you can choose between the following formats:\nMarkdown: publish the Markdown text on a website that can interpret it (GitHub for instance), HTML: publish the file converted to HTML via a Handlebars template (on a blog for example). Update a publication After publishing, StackEdit keeps your file linked to that publication which makes it easy for you to re-publish it. Once you have modified your file and you want to update your publication, click on the Publish now button in the navigation bar.\nNote: The Publish now button is disabled if your file has not been published yet.\nManage file publication Since one file can be published to multiple locations, you can list and manage publish locations by clicking File publication in the Publish sub-menu. This allows you to list and remove publication locations that are linked to your file.\nMarkdown extensions StackEdit extends the standard Markdown syntax by adding extra Markdown extensions, providing you with some nice features.\nProTip: You can disable any Markdown extension in the File properties dialog.\nSmartyPants SmartyPants converts ASCII punctuation characters into \u0026ldquo;smart\u0026rdquo; typographic punctuation HTML entities. For example:\nASCII HTML Single backticks 'Isn't this fun?' \u0026lsquo;Isn\u0026rsquo;t this fun?\u0026rsquo; Quotes \u0026quot;Isn't this fun?\u0026quot; \u0026ldquo;Isn\u0026rsquo;t this fun?\u0026rdquo; Dashes -- is en-dash, --- is em-dash \u0026ndash; is en-dash, \u0026mdash; is em-dash KaTeX You can render LaTeX mathematical expressions using KaTeX:\nThe Gamma function satisfying $\\Gamma(n) = (n-1)!\\quad\\forall n\\in\\mathbb N$ is via the Euler integral\n$$ \\Gamma(z) = \\int_0^\\infty t^{z-1}e^{-t}dt,. $$\nYou can find more information about LaTeX mathematical expressions here.\nUML diagrams You can render UML diagrams using Mermaid. For example, this will produce a sequence diagram:\nsequenceDiagram\rAlice -\u0026gt;\u0026gt; Bob: Hello Bob, how are you?\rBob--\u0026gt;\u0026gt;John: How about you John?\rBob--x Alice: I am good thanks!\rBob-x John: I am good thanks!\rNote right of John: Bob thinks a long\u0026lt;br/\u0026gt;long time, so long\u0026lt;br/\u0026gt;that the text does\u0026lt;br/\u0026gt;not fit on a row.\rBob--\u0026gt;Alice: Checking with John...\rAlice-\u0026gt;John: Yes... John, how are you? And this will produce a flow chart:\ngraph LR\rA[Square Rect] -- Link text --\u0026gt; B((Circle))\rA --\u0026gt; C(Round Rect)\rB --\u0026gt; D{Rhombus}\rC --\u0026gt; D The above quote is excerpted from Rob Pike\u0026rsquo;s talk during Gopherfest, November 18, 2015.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","permalink":"https://AswinBlue.github.io/post/sample/","summary":"\u003cp\u003eThis article offers a sample of basic Markdown syntax that can be used in Hugo content files, also it shows whether basic HTML elements are decorated with CSS in a Hugo theme.\u003c/p\u003e","title":"Markdown Syntax Guide"},{"content":"Written in Go, Hugo is an open source static site generator available under the Apache Licence 2.0. Hugo supports TOML, YAML and JSON data file types, Markdown and HTML content files and uses shortcodes to add rich content. Other notable features are taxonomies, multilingual mode, image processing, custom output formats, HTML/CSS/JS minification and support for Sass SCSS workflows.\nHugo makes use of a variety of open source projects including:\nhttps://github.com/russross/blackfriday https://github.com/alecthomas/chroma https://github.com/muesli/smartcrop https://github.com/spf13/cobra https://github.com/spf13/viper Hugo is ideal for blogs, corporate websites, creative portfolios, online magazines, single page applications or even a website with thousands of pages.\nHugo is for people who want to hand code their own website without worrying about setting up complicated runtimes, dependencies and databases.\nWebsites built with Hugo are extremelly fast, secure and can be deployed anywhere including, AWS, GitHub Pages, Heroku, Netlify and any other hosting provider.\nLearn more and contribute on GitHub.\n","permalink":"https://AswinBlue.github.io/about/","summary":"Written in Go, Hugo is an open source static site generator available under the Apache Licence 2.0. Hugo supports TOML, YAML and JSON data file types, Markdown and HTML content files and uses shortcodes to add rich content. Other notable features are taxonomies, multilingual mode, image processing, custom output formats, HTML/CSS/JS minification and support for Sass SCSS workflows.\nHugo makes use of a variety of open source projects including:\nhttps://github.com/russross/blackfriday https://github.","title":"About"},{"content":"./+++ title = \u0026ldquo;Docker\u0026rdquo; date = 2021-08-12T10:41:00+09:00 lastmod = 2021-08-12T10:41:00+09:00 tags = [ \u0026ldquo;docker\u0026rdquo;,] categories = [\u0026ldquo;dev\u0026rdquo;,] imgs = [] cover = \u0026quot;\u0026quot; # image show on top readingTime = true # show reading time after article date toc = true comments = false justify = false # text-align: justify; single = false # display as a single page, hide navigation on bottom, like as about page. license = \u0026quot;\u0026quot; # CC License draft = false +++\nDocker 리눅스 커널의 cgroups와 namespace에 의해 제공되는 기술 가상화 기능의 일종으로, 별도의 OS를 갖지 않아 VM(Virtual Machine) 보다 가볍다. 게스트는 호스트 OS와 자원을 공유한다. immutable infrastructure : 서비스 운영 환경을 통째로 이미지화 하여 배포하는 형태 설치 링크 참조\n실행 DockerFile 이름의 파일을 생성하고 내용을 채워넣는다. https://docs.docker.com/engine/reference/builder/ DockerFile 명령어\nFROM: base image를 지정하는 명령어 DockerFile의 시작은 무조건 FORM 이 필요하다. FROM \u0026lt;IMAGE\u0026gt;:\u0026lt;VERSION\u0026gt; 형태로 사용한다. FROM base:${CODE_VERSION} ARG: 변수를 선언 ARG CODE_VERSION=latest 선언한 변수는 ${CODE_VERSION} 형태로 참조 가능하며, build시 자동으로 argument로 사용된다. ARG port 와 같이 값을 정의하지 않고 선언만 한 경우에는, \u0026ndash;build-arg 옵션으로 값 설정이 가능하다. docker build --build-arg port=80 CMD: 컨테이너 실행 시 디폴트로 실행할 커맨드를 설정 CMD [\u0026quot;executable\u0026quot;,\u0026quot;param1\u0026quot;,\u0026quot;param2\u0026quot;] 형태로 사용 ENTRYPOINT와 조합하여 사용 가능하며, ENTRYPOINT에서 \u0026ldquo;executable\u0026rdquo;(명령어) 를 선언한 상태라면 CMD에서 executable 없이 param만 선언 가능하다. CMD [\u0026quot;param1\u0026quot;,\u0026quot;param2\u0026quot;] 여러개의 CMD를 선언하면 가장 마지막의 것만 동작 CMD /code/run-app 와 같이 사용 COPY: 호스트 컴퓨터의 디렉터리나 파일을 Docker 이미지의 파일 시스템으로 복사 COPY: \u0026lt;SRC\u0026gt; \u0026lt;DEST\u0026gt; COPY: [\u0026quot;\u0026lt;SRC1\u0026gt;\u0026quot;, \u0026quot;\u0026lt;SRC2\u0026gt;\u0026quot;, ... \u0026lt;DEST\u0026gt;] ADD: COPY의 상위호환 명령어로, 압축 파일이나 링크상의 파일도 추가 가능하다. ENV: 환경변수를 설정하기 위한 명령어 EXPOSE: 컨테이너로 유입되는 트래픽에 대한 처리 EXPOSE \u0026lt;port\u0026gt; [\u0026lt;port\u0026gt;/\u0026lt;protocol\u0026gt;...] 프로토콜은 tcp,udp 중 선택 가능 ENTRYPOINT: 컨테이너 시작시 수행할 명령어 ENTRYPOINT [\u0026quot;\u0026lt;CMD\u0026gt;\u0026quot;, \u0026quot;\u0026lt;PARAM1\u0026gt;\u0026quot;, \u0026quot;\u0026lt;PARAM2\u0026gt;\u0026quot;] 형태로 사용 ENTRYPOINT [\u0026quot;npm\u0026quot;, \u0026quot;start\u0026quot;] LABEL: 이미지에 metadata를 정의하는 명령어 LABEL \u0026lt;key\u0026gt;=\u0026lt;value\u0026gt; \u0026lt;key\u0026gt;=\u0026lt;value\u0026gt; \u0026lt;key\u0026gt;=\u0026lt;value\u0026gt; ... STOPSIGNAL: 시스템이 종료하기 위한 SIGNAL을 설정한다. SIGINT, SIGKILL 등을 설정할 수 있으며, 이를 전달받으면 컨테이너가 종료하게 된다. 설정하지 않으면 SIGTERM 이 자동으로 세팅된다. USER: RUN: 쉘 프롬프트에 명령어를 입력하는 효과 VOLUME: 볼륨을 mount 하기 위한 자리를 세팅하는 명령어 WORKDIR: 컨테이너에서 작업 디렉터리 이동 리눅스의 cd 명령과 유사 ONBUILD: 빌드 후에 동작해야 할 명령들을 설정하는 명령어 DockerFile 명령어는 이미지 빌드를 위한 명령어이며, 빌드 할 때 마다 동일한 결과물을 산출한다. 하지만 빌드된 이미지의 결과물을 다음 빌드 때 사용하고 싶다면 이 명령을 사용한다. ONBUILD\rLearn more about the \u0026#34;ONBUILD\u0026#34; Dockerfile command.\rADD . /app/src\rONBUILD RUN /usr/local/bin/python-build --dir /app/src 다음 빌드 때 ONBUILD가 호출된 순서대로 명령이 동작한다. docker inspect 명령어로 확인 가능 예시\n# python:3.10의 이미지로 부터\rFROM python:3.9\r# 제작자 및 author 기입\rLABEL maintainer=\u0026#34;huisam@naver.com\u0026#34;\r# 해당 디렉토리에 있는 모든 하위항목들을 \u0026#39;/app/server`로 복사한다\rCOPY . /app/server\r# image의 directory로 이동하고\rWORKDIR /app/server\r# 필요한 의존성 file들 설치\rRUN pip3 install -r requirements.txt\r# 환경 설정 세팅\rRUN python setup.py install\r# container가 구동되면 실행\rENTRYPOINT [\u0026#34;python\u0026#34;, \u0026#34;Server.py\u0026#34;] 오류 와 해결방법 is docker daemon running? 에러 service docker status 입력시 docker daemon이 꺼져있는지 확인 service docker start 명령으로 daemon 실행 만약 명령은 수행되나 켜지지 않는다면 systemctl명령 수행 systemctl start docker : docker를 daemon으로 실행 systemctl enable docker : OS실행시 docker daemon을 기본 실행 systemctl 명령도 안된다면 /lib/systemd/system/docker.service , /lib/systemd/system/docker.socket 이 제대로 있는지 확인하여 설치 여부를 재확인한다. 참조 init 프로세스(PID 1)이 /bin/bash로 실행되지 않을 때, docker 실행 방법\ndocker run -t -i ubuntu:16.04 /bin/bash docker 명령어 이미지 : 특정 환경을 만들기 위해 세팅된 정보. 컨테이너 : 실행가능한 상태의 프로세스. 이미지를 컨테이너에 담아 실행시킬 수 있다. 생성 및 설정 버전 확인 docker -v 이미지 다운 docker pull \u0026lt;이미지명\u0026gt;[:태그] 이미지 생성 : 현재 경로에서 Dockerfile을 찾아 그 안의 docker build -t \u0026lt;이미지명\u0026gt; 설치된 도커 이미지 확인 docker images 실행 컨테이너 생성, 실행하지 않고 정지 docker create [옵션] \u0026lt;이미지명\u0026gt;[:태그] 컨테이너 실행 후 CLI 접속 docker attach \u0026lt;컨테이너 id 또는 이름\u0026gt; 컨테이너 실행. 지정된 작업이 수행된다. docker start \u0026lt;이미지명\u0026gt; 이미지 다운받아 실행 docker run \u0026lt;이미지명\u0026gt; 환경변수 설정 docker run -e \u0026lt;환경변수=설정값\u0026gt; 옵션 이미지 다운받아 실행 후 CLI 접속 docker run -it \u0026lt;이미지명\u0026gt; 컨테이너 실행시 이름 지정 docker run --name \u0026lt;컨테이너명\u0026gt; \u0026lt;이미지명\u0026gt; 디렉터리 연결 docker run -v \u0026lt;로컬경로\u0026gt;:\u0026lt;컨테이너 내부 경로\u0026gt; \u0026lt;이미지명\u0026gt; 포트 연결 docker run -p \u0026lt;로컬포트\u0026gt;:\u0026lt;컨테이너 포트\u0026gt; \u0026lt;이미지명\u0026gt; 백그라운드 실행 docker run -d \u0026lt;이미지명\u0026gt; 프로세스 종료시 컨테이너 자동 삭제 docker run -rm \u0026lt;이미지명\u0026gt; 관리 실행중인 컨테이너 확인 docker ps 일시중지 docker container pause \u0026lt;컨테이너명\u0026gt; 일시중지 해제 docker container unpause \u0026lt;컨테이너명\u0026gt; 컨테이너 삭제 docker rm \u0026lt;컨테이너 id 또는 이름\u0026gt; 모든 컨테이너 삭제 docker rmdocker ps -a -q 볼륨까지 같이 삭제 docker rm -v \u0026lt;컨테이너 id 또는 이름\u0026gt; 이미지 삭제 docker rmi [옵션] \u0026lt;이미지 id\u0026gt; 컨테이너 내부에서 커맨드라인을 수행하도록 외부에서 입력 ` docker exec [옵션] \u0026lt;컨테이너 id 또는 이름\u0026gt; \u0026lt;커맨드\u0026gt; 컨테이너 실행 후 지정된 명령어 수행 docker exec -it \u0026lt;컨테이너 id 또는 이름\u0026gt; [명령어] 백그라운드 실행중인 도커 로그 확인 docker logs -f \u0026lt;컨테이너 id 또는 이름\u0026gt; Dockerfile FROM \u0026lt;이미지명\u0026gt; : 이미 생성된 이미지에 덧붙여서 아래 내용을 수행, import와 비슷한 느낌 MAINTAINER : 메인테이너 정보 WORKDIR : 명령어를 실행할 위치 설멍, 리눅스 cd에 해당 VOLUME [\u0026ldquo;경로1\u0026rdquo;, \u0026ldquo;경로2\u0026rdquo;, \u0026hellip;]: run의 -v 옵션과 유사하지만, docker가 임의로 생성한 디렉터리에 volume을 연결한다. 이는 docker volume 명령어로 관리 가능하지만, 컨테이너가 삭제되고 나면 직접 접근하기 힘들다. ADD \u0026lt;DIR_SOURCE\u0026gt; \u0026lt;DIR_DEST\u0026gt;: 현재 이미지의 파일들을 내부 이미지의 특정 디렉터리에 복사. 이미지 안에 해당 경로가 없으면 생성하여 추가 RUN \u0026lt;명령어\u0026gt; : 컨테이너가 이미지를 실행하기 전 수행할 쉘 명령어 CMD \u0026lt;명령\u0026gt; : 실행하고 나서 수행할 명령어, 쉘을 불러 실행한다. CMD [\u0026ldquo;인자 1\u0026rdquo;, \u0026ldquo;인자 2\u0026rdquo;, \u0026hellip;] : 쉘 없이 명령 실행. \u0026lsquo;[]\u0026rsquo; 안에 문자열 배열로 치환해 넘겨주는 형태 EXPOSE : 외부와 연결할 포트, 컨테이너 실행시 -p 옵션을 사용하기 위해 설정해 두어야 함. ARG \u0026lt;옵션\u0026gt; : 설정 옵션들을 정의 ENV \u0026lt;환경변수\u0026gt; : 환경변수 설정 .dockerignore Docker 이미지 생성시 들어가지 않을 파일들을 지정 가능 docker-compose 각각의 Dockerfile들을 묶어 하나의 시스템을 구성하는 도구 docker 실행시 명령어를 미리 작성해 놓은 스크립트라고 보면 된다. docker-compose up 명령으로 docker-compose 파일 빌드 가능. 하위 경로에 Dockerfile들이 각각의 서비스에 해당됨 version: \u0026#39;3\u0026#39; // 도커 컴퍼즈 버전 3이상 요구\rservices: // 서비스 내용들이 아래에 옴\rservice1: // 서비스 이름으로, 마음대로 정의 가능\rbuild: ./S1 // docker-compose 파일로부터 경로를 지정\rvolumes:\r- ./S1:/home/root //\tdocker run -v 옵션 적용과 동일\rports:\r- \u0026#34;1234:1234\u0026#34;\t// docker run -p 옵션 적용과 동일\renvironment:\r- DEBUG_LEVEL=debug\t//\t환경변수 설정 가능\rlinks: // docker-compose 3부터는 필요없어진 기능, 네트워크 연결을 위해 사용\r- service2\rservice2: // 또다른 서비스, 위와 같이 작성 가능\r... ","permalink":"https://AswinBlue.github.io/post/docker/","summary":"./+++ title = \u0026ldquo;Docker\u0026rdquo; date = 2021-08-12T10:41:00+09:00 lastmod = 2021-08-12T10:41:00+09:00 tags = [ \u0026ldquo;docker\u0026rdquo;,] categories = [\u0026ldquo;dev\u0026rdquo;,] imgs = [] cover = \u0026quot;\u0026quot; # image show on top readingTime = true # show reading time after article date toc = true comments = false justify = false # text-align: justify; single = false # display as a single page, hide navigation on bottom, like as about page. license = \u0026quot;\u0026quot; # CC License draft = false +++","title":""}]