<!DOCTYPE html>
<html lang="en"><meta charset="utf-8"><meta name="generator" content="Hugo 0.87.0" /><meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover">
<meta name="color-scheme" content="light dark">
<meta name="supported-color-schemes" content="light dark"><title>React_adv&nbsp;&ndash;&nbsp;AsWindBlew</title><link rel="stylesheet" href="/css/core.min.df05809cfa75ea0a430dc942a79e54236823f6be194b5bc34f0c64744ba5a1b55f91020ad551b34b8af7f2ebee758cc8.css" integrity="sha384-3wWAnPp16gpDDclCp55UI2gj9r4ZS1vDTwxkdEulobVfkQIK1VGzS4r38uvudYzI"><meta name="twitter:card" content="summary" />
<meta name="twitter:title" content="React_adv" /><body><section id="header">
    <div class="header wrap"><span class="header left-side"><a class="site home" href="/"><span class="site name">AsWindBlew</span></a></span>
        <span class="header right-side"><div class="nav wrap"><nav class="nav"><a class="nav item" href="/categories/">Categories</a><a class="nav item" href="/tags/">Tags</a><a class="nav item" href="/about/">About</a><a class="nav item" href="https://gohugo%2eio/"target="_blank">Hugo</a></nav></div></span></div><div class="site slogan"><span class="title">published by AswinBlue</span></div></section><section id="content"><div class="article-container"><section class="article header">
    <h1 class="article title">React_adv</h1><p class="article date">Aug 24, 2021<span class="reading-time"> • 4 minutes to read</span></p></section><article class="article markdown-body"><h1 id="react-advanced">React Advanced</h1>
<h2 id="라이프사이클">라이프사이클</h2>
<ul>
<li>컴퍼넌트는 &lsquo;마운트 -&gt; 업데이트 -&gt; 언마운트&rsquo; 생명주기를 갖는다.</li>
</ul>
<h3 id="마운트">마운트</h3>
<ul>
<li>마운트 단계 메서드로는 다음이 존재한다.
<ul>
<li><code>constructor</code> :  생성시 호출되는 메서드 (생성자)</li>
<li><code>getDerivedStateFromProps</code> : props 값을 state에 넣는 메서드</li>
<li><code>render</code> : UI를 렌더링 하는 메서드(화면 재구성)</li>
<li><code>componentDidMount</code> : 컴퍼넌트 랜더링 완료 후 호출되는 메서드</li>
</ul>
</li>
</ul>
<h3 id="업데이트">업데이트</h3>
<ul>
<li>
<p>컴퍼넌트가 업데이트 되는 경우는 아래의 경우들이 속한다.</p>
<ol>
<li>setProps를 이용한 props변경시</li>
<li>setState를 이용한 state변경시</li>
<li>부모 컴퍼넌트가 리렌더링 될 시</li>
<li>this.forceUpdate로 강제 렌더링시</li>
</ol>
</li>
<li>
<p>업데이트 단계의 메서드로는 다음이 존재한다.</p>
<ul>
<li><code>getDerivedStateFromProps</code> : props의 값을 state에 입력</li>
<li><code>shouldComponentUpdate</code> : 컴퍼넌트의 변화를 인지하고, 랜더링 필요 여부를 판단. true: 랜더링 필요, false: 랜더링 불필요.</li>
<li><code>render</code> : 컴퍼넌트 리렌더링</li>
<li><code>getSnapshotBeforeUpdate</code> : 컴퍼넌트 변화를 DOM에 반영하기 바로 직전에 호출되 메서드</li>
<li><code>componentDidUpdate</code> : 컴퍼넌트 업데이트 작업이 끝난 후 호출되 메서드</li>
</ul>
</li>
</ul>
<h3 id="언마운트">언마운트</h3>
<ul>
<li>언마운트 단계의 메서드로는 다음이 존재한다.
<ul>
<li><code>componentWillUnmount</code> : 컴퍼넌트가 브라우저상에서 사라지기 직전 호출되는 메서드</li>
</ul>
</li>
</ul>
<h2 id="this">this</h2>
<ul>
<li>javascript 문법의 this와 동일하게 동작한다.</li>
<li>class 안에서는 this를 호출하면 class(컴퍼넌트)에 소속된 요소들에 접근할 수 있다.</li>
<li>일반 function 안에서 this를 호출하면 자신이 종속된 객체에 접근한다.</li>
<li>arrow function 안에서 this를 호출하면 자신이 종속된 인스턴스(컴퍼넌트)에 접근한다.</li>
</ul>
<pre><code>  function func1() {
    this.name = &quot;func1&quot;
    return {
        name : &quot;return&quot;
        arrow : () =&gt; {
          console.log(this.name) // 'func1' 출력
        }
        normal : function() {
          console.log(this.name) // 'return' 출력
        }
    }
  }
</code></pre><h2 id="hook">hook</h2>
<ul>
<li>class component에는 this.state가 있지만 function component 에서는 this.state가 없다. 대신 hook을 사용하여 동일한 기능을 수행한다.</li>
<li>React에서는 built-in hook을 지원하고, 사용자가 직접 정의해서 사용할 수도 있다.</li>
</ul>
<h3 id="hook의-조건">hook의 조건</h3>
<ol>
<li>hook은 React 함수에서만 호출해야 한다. 일반 javascript 함수에서 호출하면 안된다.</li>
<li>hook은 반복문, 조건문, nested function에서 호출되면 안된다.</li>
</ol>
<blockquote>
<p>위 두 조건을 이해하려면 hook의 동작 원리를 이해해야한다.<br>
React는 컴퍼넌트를 처리할때 hook 함수들을 호출된 순서대로 관리한다.<br>
만약 컴퍼넌트를 업데이트할 때 hook 함수들의 순서가 변경된다면 React는 이를 정상적으로 처리하지 못한다.<br>
이때문에 hook은 항상 컴퍼넌트의 최상단에서 호출되어야 한다.</p>
</blockquote>
<h3 id="hook의-종류">hook의 종류</h3>
<ol>
<li>State Hooks</li>
</ol>
<ul>
<li><code>import { useState } from 'react'</code> 로 참조한다.</li>
<li><code>[state, updateState] = useState( VALUE )</code>: 컴퍼넌트에 VALUE값을 저장하고, 배열을 반환한다. &lsquo;state&rsquo; 는 VALUE 와 동일한 값이며, &lsquo;updateState&rsquo; 는 state값을 업데이트할 수 있는 함수 페어를 반환한다. &lsquo;updateState&rsquo; 는 <code>this.setState</code>와 유사한 효과를 가진다.</li>
<li>VALUE값으로는 숫자, 문자열, 객체 모두 수용 가능하다.</li>
</ul>
<ol start="2">
<li>Effect Hooks</li>
</ol>
<ul>
<li><code>import React, { useEffect } from 'react';</code>로 참조한다.</li>
<li>componentDidMount, componentWillUnmount 혹은 componentDidUpdate 와 유사한 효과를 발생시키며, 한 함수에서 여러번 선언 가능하다.</li>
<li>useEffect의 첫번째 인자로 함수가 들어가는데, 이 함수는 componentDidMount와 같은 시점에 동작된다.</li>
<li>useEffect의 첫번째 인자로 들어간 함수는 return값으로 함수를 반환하는데, 이 반환된 함수는 componentWillUnmount와 같은 시점에 동작된다.</li>
<li>useEffect의 두번째 인자로는 배열이 들어가는데, 이 배열 요소의 값이 바뀔경우 useEffect의 첫번째 인자로 들어간 함수를 실행시킨다. componentDidUpdate와 유사하게 특정 변수가 변할때 rerendering을 할 수 있다.</li>
</ul>
<pre><code>    // return 없는 함수만 오는 경우
    useEffect( () =&gt; {
      console.log(&quot;componentDidUpdate&quot;);
    }
    // return 이 포함된 함수가 오는 경우
    useEffect( () =&gt; {
      console.log(&quot;componentDidMount&quot;);
      return (
        () =&gt; { console.log(&quot;componentWillUnmount&quot;) }
      )
    })
    // 두번쨰 인자가 들어간 경우
    useEffect( () =&gt; {
      console.log(&quot;componentDidUpdate only when 'value' changes&quot;);
    }, [value])
</code></pre><ul>
<li>class 의 componentdidMount와 같은 함수에 비해 간단하고 직관적으로 사용할 수 있다.</li>
</ul>
<ol start="3">
<li>Context Hooks</li>
</ol>
<ul>
<li><code>useContext</code></li>
</ul>
<ol start="4">
<li>Reducer Hooks</li>
</ol>
<ul>
<li><code>useReducer</code></li>
</ul>
<ol start="5">
<li>Custom Hooks</li>
</ol>
<ul>
<li>hook을 담고 있는 사용자 정의 함수를 custom hook이라 칭한다. 반복되는 hook 호출 + 일련의 처리 과정을 하나의 함수로 묶어서 사용할 수 있다.</li>
<li>통념적으로 &lsquo;use&rsquo;로 시작하는 이름을 붙여준다.</li>
<li>호출된 custom hook도 일반 hook과 마찬가지로 중복해서 사용이 가능하며 각 hook들 끼리는 독립적이다.</li>
</ul>
<h2 id="기타">기타</h2>
<ul>
<li><code>debugger</code>라는 예약어는, chrome에서 실행할 때 break point역할을 한다. 개발시 코드로 break point를 설정할 수 있다.</li>
<li>link는 페이지의 개념이고, button은 operation의 개념이다. 모두 event를 발생시킬 수 있지만 구분을 하는게 좋다.</li>
</ul>
<h2 id="참조">참조</h2>
<p><a href="https://devowen.com/307?category=778540"target="_blank">React LifeCycle</a>
<a href="https://reactjs.org/docs/hooks-intro.html#motivation"target="_blank">What &amp; Why Hook</a></p>
</article><section class="article labels"><a class="category" href=/categories/dev/>dev</a><a class="category" href=/categories/advanced/>advanced</a><a class="tag" href=/tags/react/>react</a><a class="tag" href=/tags/javascript/>javascript</a><a class="tag" href=/tags/web-application/>web application</a></section><section class="article author"><img class="avatar" src="https://d33wubrfki0l68.cloudfront.net/ddf49425628d8aec7523db143916b34ae1641e11/b97e8/images/gopher-side_color.svg" alt><p class="name">gohugo</p><div class="bio">Hugo is one of the most popular open-source static site generators. With its amazing speed and flexibility, Hugo makes building websites fun again.</div><div class="details"><a class="item" href="https://github.com/gohugoio" target="_blank"><span class="iconfont icon-github"></span>&nbsp;gohugoio</a><a class="item" href="https://twitter.com/GoHugoIO" target="_blank"><span class="iconfont icon-twitter"></span>&nbsp;@GoHugoIO</a></div>
</section></div>
<div class="article bottom"><section class="article navigation"><p><a class="link" href="/post/python/"><span class="li iconfont icon-article"></span>Python</a></p><p><a class="link" href="/post/angular/"><span class="li iconfont icon-article"></span>Angular</a></p></section></div></section><section id="footer"><div class="footer-wrap">
    <p class="copyright">©2020 Notepadium.</p>
    <p class="powerby"><span>Powered by </span><a href="https://gohugo.io" 
        target="_blank">Hugo</a><span> and the </span><a href="https://themes.gohugo.io/hugo-notepadium/" 
        target="_blank">Notepadium</a></p>
</div></section></body>

</html>